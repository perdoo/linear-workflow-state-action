import { TypedDocumentNode as DocumentNode } from "@graphql-typed-document-node/core";
export declare type Maybe<T> = T | null;
export declare type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
export declare type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]?: Maybe<T[SubKey]>;
};
export declare type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]: Maybe<T[SubKey]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export declare type Scalars = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    /** Represents a date and time in ISO 8601 format. Accepts shortcuts like `2021` to represent midnight Fri Jan 01 2021. Also accepts ISO 8601 durations strings which are added to the current date to create the represented date (e.g '-P2W1D' represents the date that was two weeks and 1 day ago) */
    DateTime: Date;
    /** The `JSON` scalar type represents JSON values */
    JSON: Record<string, unknown>;
    /** The `JSONObject` scalar type represents JSON values as a string */
    JSONObject: Record<string, unknown>;
    /** Represents a date in ISO 8601 format. Accepts shortcuts like `2021` to represent midnight Fri Jan 01 2021. Also accepts ISO 8601 durations strings which are added to the current date to create the represented date (e.g '-P2W1D' represents the date that was two weeks and 1 day ago) */
    TimelessDate: any;
    /** A universally unique identifier as specified by RFC 4122. */
    UUID: any;
};
/** An API key. Grants access to the user's resources. */
export declare type ApiKey = Node & {
    __typename?: "ApiKey";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The label of the API key. */
    label: Scalars["String"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type ApiKeyConnection = {
    __typename?: "ApiKeyConnection";
    edges: Array<ApiKeyEdge>;
    nodes: Array<ApiKey>;
    pageInfo: PageInfo;
};
export declare type ApiKeyCreateInput = {
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The API key value. */
    key: Scalars["String"];
    /** The label for the API key. */
    label: Scalars["String"];
};
export declare type ApiKeyEdge = {
    __typename?: "ApiKeyEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: ApiKey;
};
export declare type ApiKeyPayload = {
    __typename?: "ApiKeyPayload";
    /** The API key that was created. */
    apiKey: ApiKey;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** Public information of the OAuth application. */
export declare type Application = {
    __typename?: "Application";
    /** OAuth application's client ID. */
    clientId: Scalars["String"];
    /** Information about the application. */
    description?: Maybe<Scalars["String"]>;
    /** Name of the developer. */
    developer: Scalars["String"];
    /** Url of the developer (homepage or docs). */
    developerUrl: Scalars["String"];
    /** Image of the application. */
    imageUrl?: Maybe<Scalars["String"]>;
    /** Application name. */
    name: Scalars["String"];
};
export declare type ArchivePayload = {
    __typename?: "ArchivePayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** Contains requested archived model objects. */
export declare type ArchiveResponse = {
    __typename?: "ArchiveResponse";
    /** A JSON serialized collection of model objects loaded from the archive */
    archive: Scalars["String"];
    /** The version of the remote database. Incremented by 1 for each migration run on the database. */
    databaseVersion: Scalars["Float"];
    /** The total number of entities in the archive. */
    totalCount: Scalars["Float"];
};
/** [Alpha] Issue attachment (e.g. support ticket, pull request). */
export declare type Attachment = Node & {
    __typename?: "Attachment";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The creator of the attachment. */
    creator?: Maybe<User>;
    /** Indicates if attachments for the same source application should be grouped in the Linear UI. */
    groupBySource: Scalars["Boolean"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The issue this attachment belongs to. */
    issue: Issue;
    /** Custom metadata related to the attachment. */
    metadata: Scalars["JSONObject"];
    /** Information about the source which created the attachment. */
    source?: Maybe<Scalars["JSONObject"]>;
    /** An accessor helper to source.type, defines the source type of the attachment. */
    sourceType?: Maybe<Scalars["JSONObject"]>;
    /** Content for the subtitle line in the Linear attachment widget. */
    subtitle?: Maybe<Scalars["String"]>;
    /** Content for the title line in the Linear attachment widget. */
    title: Scalars["String"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** Location of the attachment which is also used as an identifier. */
    url: Scalars["String"];
};
export declare type AttachmentConnection = {
    __typename?: "AttachmentConnection";
    edges: Array<AttachmentEdge>;
    nodes: Array<Attachment>;
    pageInfo: PageInfo;
};
export declare type AttachmentCreateInput = {
    /** Create a linked comment with markdown body. */
    commentBody?: Maybe<Scalars["String"]>;
    /** [Internal] Create a linked comment with Prosemirror body. Please use `commentBody` instead */
    commentBodyData?: Maybe<Scalars["JSONObject"]>;
    /** Indicates if attachments for the same source application should be grouped in the Linear UI. */
    groupBySource?: Maybe<Scalars["Boolean"]>;
    /** An icon url to display with the attachment. Should be of jpg or png format. Maximum of 1MB in size. Dimensions should be 20x20px for optimal display quality. */
    iconUrl?: Maybe<Scalars["String"]>;
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The issue to associate the attachment with. */
    issueId: Scalars["String"];
    /** Attachment metadata object with string and number values. */
    metadata?: Maybe<Scalars["JSONObject"]>;
    /** The attachment subtitle. */
    subtitle?: Maybe<Scalars["String"]>;
    /** The attachment title. */
    title: Scalars["String"];
    /** Attachment location which is also used as an unique identifier for the attachment. If another attachment is created with the same `url` value, existing record is updated instead. */
    url: Scalars["String"];
};
export declare type AttachmentEdge = {
    __typename?: "AttachmentEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Attachment;
};
/** [Alpha] Attachment filtering options. */
export declare type AttachmentFilter = {
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Filters that the attachments creator must satisfy. */
    creator?: Maybe<NullableUserFilter>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Comparator for the source type. */
    sourceType?: Maybe<NestedStringComparator>;
    /** Comparator for the subtitle. */
    subtitle?: Maybe<NullableStringComparator>;
    /** Comparator for the title. */
    title?: Maybe<StringComparator>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
    /** Comparator for the url. */
    url?: Maybe<StringComparator>;
};
export declare type AttachmentPayload = {
    __typename?: "AttachmentPayload";
    /** The issue attachment that was created. */
    attachment: Attachment;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type AttachmentUpdateInput = {
    /** An icon url to display with the attachment. Should be of jpg or png format. Maximum of 1MB in size. Dimensions should be 20x20px for optimal display quality. */
    iconUrl?: Maybe<Scalars["String"]>;
    /** Attachment metadata object with string and number values. */
    metadata?: Maybe<Scalars["JSONObject"]>;
    /** The attachment subtitle. */
    subtitle?: Maybe<Scalars["String"]>;
    /** The attachment title. */
    title: Scalars["String"];
};
/** Workspace audit log entry object. */
export declare type AuditEntry = Node & {
    __typename?: "AuditEntry";
    /** The user that caused the audit entry to be created. */
    actor?: Maybe<User>;
    /** The ID of the user that caused the audit entry to be created. */
    actorId?: Maybe<Scalars["String"]>;
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** Country code of request resulting to audit entry. */
    countryCode?: Maybe<Scalars["String"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** IP from actor when entry was recorded. */
    ip?: Maybe<Scalars["String"]>;
    /** Additional metadata related to the audit entry. */
    metadata?: Maybe<Scalars["JSONObject"]>;
    type: Scalars["String"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type AuditEntryConnection = {
    __typename?: "AuditEntryConnection";
    edges: Array<AuditEntryEdge>;
    nodes: Array<AuditEntry>;
    pageInfo: PageInfo;
};
export declare type AuditEntryEdge = {
    __typename?: "AuditEntryEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: AuditEntry;
};
/** [Alpha] Audit entry filtering options. */
export declare type AuditEntryFilter = {
    /** Filters that the audit entry actor must satisfy. */
    actor?: Maybe<NullableUserFilter>;
    /** Comparator for the country code. */
    countryCode?: Maybe<StringComparator>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Comparator for the IP address. */
    ip?: Maybe<StringComparator>;
    /** Comparator for the type. */
    type?: Maybe<StringComparator>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
export declare type AuditEntryType = {
    __typename?: "AuditEntryType";
    /** Description of the audit entry type. */
    description: Scalars["String"];
    /** The audit entry type. */
    type: Scalars["String"];
};
export declare type AuthResolverResponse = {
    __typename?: "AuthResolverResponse";
    /** Should the signup flow allow access for the domain. */
    allowDomainAccess?: Maybe<Scalars["Boolean"]>;
    /** Organizations this account has access to, but is not yet a member. */
    availableOrganizations?: Maybe<Array<Organization>>;
    /** Email for the authenticated account. */
    email?: Maybe<Scalars["String"]>;
    /** User account ID. */
    id: Scalars["String"];
    /** ID of the organization last accessed by the user. */
    lastUsedOrganizationId?: Maybe<Scalars["String"]>;
    /** JWT token for authentication of the account. */
    token?: Maybe<Scalars["String"]>;
    /** Users belonging to this account. */
    users: Array<User>;
};
/** Public information of the OAuth application, plus the authorized scopes for a given user. */
export declare type AuthorizedApplication = {
    __typename?: "AuthorizedApplication";
    /** OAuth application's ID. */
    appId: Scalars["String"];
    /** OAuth application's client ID. */
    clientId: Scalars["String"];
    /** Information about the application. */
    description?: Maybe<Scalars["String"]>;
    /** Name of the developer. */
    developer: Scalars["String"];
    /** Url of the developer (homepage or docs). */
    developerUrl: Scalars["String"];
    /** Image of the application. */
    imageUrl?: Maybe<Scalars["String"]>;
    /** Application name. */
    name: Scalars["String"];
    /** Scopes that are authorized for this application for a given user. */
    scope: Array<Scalars["String"]>;
    /** Whether or not webhooks are enabled for the application. */
    webhooksEnabled: Scalars["Boolean"];
};
/** Relation load request. */
export declare type BatchRequest = {
    /** The indexed key to load models for. */
    indexedKey: Scalars["String"];
    /** The value of the indexed key to load models for. */
    keyValue: Scalars["String"];
    /** The class name of the model to load. */
    modelClass: Scalars["String"];
};
export declare type BillingDetailsPayload = {
    __typename?: "BillingDetailsPayload";
    /** The customer's email address the invoices are sent to. */
    email?: Maybe<Scalars["String"]>;
    /** List of invoices, if any. */
    invoices: Array<Invoice>;
    /** The payment method. */
    paymentMethod?: Maybe<Card>;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type BillingEmailPayload = {
    __typename?: "BillingEmailPayload";
    /** The customer's email address the invoices are sent to. */
    email?: Maybe<Scalars["String"]>;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type BillingEmailUpdateInput = {
    /** The email address to which to send invoices. */
    email: Scalars["String"];
};
/** Comparator for booleans. */
export declare type BooleanComparator = {
    /** Equals constraint. */
    eq?: Maybe<Scalars["Boolean"]>;
};
export declare type Card = {
    __typename?: "Card";
    /** The brand of the card, e.g. Visa. */
    brand: Scalars["String"];
    /** The last four digits used to identify the card. */
    last4: Scalars["String"];
};
export declare type CollaborationDocumentUpdateInput = {
    /** Client identifier. */
    clientId: Scalars["String"];
    /** Document identifier. */
    issueId: Scalars["String"];
    /** New document steps from the client. */
    steps: Array<Scalars["JSON"]>;
    /** Client's document version number. */
    version: Scalars["Int"];
};
export declare type CollaborationDocumentUpdatePayload = {
    __typename?: "CollaborationDocumentUpdatePayload";
    /** Document steps the client has not seen yet and need to rebase it's local steps on. */
    steps?: Maybe<StepsResponse>;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** A comment associated with an issue. */
export declare type Comment = Node & {
    __typename?: "Comment";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The comment content in markdown format. */
    body: Scalars["String"];
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The time user edited the comment. */
    editedAt?: Maybe<Scalars["DateTime"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The issue that the comment is associated with. */
    issue: Issue;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** Comment's URL. */
    url: Scalars["String"];
    /** The user who wrote the comment. */
    user: User;
};
/** [Alpha] Comment filtering options. */
export declare type CommentCollectionFilter = {
    /** Compound filters, all of which need to be matched by the comment. */
    and?: Maybe<Array<CommentFilter>>;
    /** Comparator for the comments body. */
    body?: Maybe<StringComparator>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Filters that needs to be matched by all comments. */
    every?: Maybe<CommentFilter>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Filters that the comments issue must satisfy. */
    issue?: Maybe<IssueFilter>;
    /** Compound filters, one of which need to be matched by the comment. */
    or?: Maybe<Array<CommentFilter>>;
    /** Filters that needs to be matched by some comments. */
    some?: Maybe<CommentFilter>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
    /** Filters that the comments creator must satisfy. */
    user?: Maybe<UserFilter>;
};
export declare type CommentConnection = {
    __typename?: "CommentConnection";
    edges: Array<CommentEdge>;
    nodes: Array<Comment>;
    pageInfo: PageInfo;
};
export declare type CommentCreateInput = {
    /** The comment content in markdown format. */
    body?: Maybe<Scalars["String"]>;
    /** The comment content as a Prosemirror document. */
    bodyData?: Maybe<Scalars["JSON"]>;
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The issue to associate the comment with. */
    issueId: Scalars["String"];
};
export declare type CommentEdge = {
    __typename?: "CommentEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Comment;
};
/** [Alpha] Comment filtering options. */
export declare type CommentFilter = {
    /** Compound filters, all of which need to be matched by the comment. */
    and?: Maybe<Array<CommentFilter>>;
    /** Comparator for the comments body. */
    body?: Maybe<StringComparator>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Filters that the comments issue must satisfy. */
    issue?: Maybe<IssueFilter>;
    /** Compound filters, one of which need to be matched by the comment. */
    or?: Maybe<Array<CommentFilter>>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
    /** Filters that the comments creator must satisfy. */
    user?: Maybe<UserFilter>;
};
export declare type CommentPayload = {
    __typename?: "CommentPayload";
    /** The comment that was created or updated. */
    comment: Comment;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type CommentUpdateInput = {
    /** The comment content. */
    body?: Maybe<Scalars["String"]>;
    /** The comment content as a Prosemirror document. */
    bodyData?: Maybe<Scalars["JSON"]>;
};
/** GitHub's commit data */
export declare type CommitPayload = {
    __typename?: "CommitPayload";
    added: Array<Scalars["String"]>;
    id: Scalars["String"];
    message: Scalars["String"];
    modified: Array<Scalars["String"]>;
    removed: Array<Scalars["String"]>;
    timestamp: Scalars["String"];
    url: Scalars["String"];
};
export declare type ContactCreateInput = {
    /** User's browser information. */
    browser?: Maybe<Scalars["String"]>;
    /** User's device information. */
    device?: Maybe<Scalars["String"]>;
    /** How disappointed the user would be if they could no longer use Linear. */
    disappointmentRating?: Maybe<Scalars["Int"]>;
    /** The message the user sent. */
    message: Scalars["String"];
    /** User's operating system. */
    operatingSystem?: Maybe<Scalars["String"]>;
    /** The type of support contact. */
    type: Scalars["String"];
};
export declare type ContactPayload = {
    __typename?: "ContactPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type CreateCsvExportReportPayload = {
    __typename?: "CreateCsvExportReportPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type CreateOrJoinOrganizationResponse = {
    __typename?: "CreateOrJoinOrganizationResponse";
    organization: Organization;
    user: User;
};
export declare type CreateOrganizationInput = {
    /** Whether the organization should allow email domain access. */
    domainAccess?: Maybe<Scalars["Boolean"]>;
    /** The name of the organization. */
    name: Scalars["String"];
    /** The timezone of the organization, passed in by client. */
    timezone?: Maybe<Scalars["String"]>;
    /** The URL key of the organization. */
    urlKey: Scalars["String"];
    /** JSON serialized UTM parameters associated with the creation of the workspace. */
    utm?: Maybe<Scalars["String"]>;
};
/** A custom view that has been saved by a user. */
export declare type CustomView = Node & {
    __typename?: "CustomView";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The color of the icon of the custom view. */
    color?: Maybe<Scalars["String"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the custom view. */
    creator: User;
    /** The description of the custom view. */
    description?: Maybe<Scalars["String"]>;
    /** [Alpha] The filter applied to issues in the custom view. */
    filterData: Scalars["JSONObject"];
    /**
     * The filters applied to issues in the custom view.
     * @deprecated Will be replaced by `filterData` in a future update
     */
    filters: Scalars["JSONObject"];
    /** The icon of the custom view. */
    icon?: Maybe<Scalars["String"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The name of the custom view. */
    name: Scalars["String"];
    /** The organization of the custom view. */
    organization: Organization;
    /** Whether the custom view is shared with everyone in the organization. */
    shared: Scalars["Boolean"];
    /** The team associated with the custom view. */
    team?: Maybe<Team>;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type CustomViewConnection = {
    __typename?: "CustomViewConnection";
    edges: Array<CustomViewEdge>;
    nodes: Array<CustomView>;
    pageInfo: PageInfo;
};
export declare type CustomViewCreateInput = {
    /** The color of the icon of the custom view. */
    color?: Maybe<Scalars["String"]>;
    /** The description of the custom view. */
    description?: Maybe<Scalars["String"]>;
    /** The filter applied to issues in the custom view. */
    filterData?: Maybe<Scalars["JSONObject"]>;
    /** The filters applied to issues in the custom view. */
    filters?: Maybe<Scalars["JSONObject"]>;
    /** The icon of the custom view. */
    icon?: Maybe<Scalars["String"]>;
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The name of the custom view. */
    name: Scalars["String"];
    /** Whether the custom view is shared with everyone in the organization. */
    shared?: Maybe<Scalars["Boolean"]>;
    /** The id of the team associated with the custom view. */
    teamId?: Maybe<Scalars["String"]>;
};
export declare type CustomViewEdge = {
    __typename?: "CustomViewEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: CustomView;
};
export declare type CustomViewPayload = {
    __typename?: "CustomViewPayload";
    /** The custom view that was created or updated. */
    customView: CustomView;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type CustomViewUpdateInput = {
    /** The color of the icon of the custom view. */
    color?: Maybe<Scalars["String"]>;
    /** The description of the custom view. */
    description?: Maybe<Scalars["String"]>;
    /** The filter applied to issues in the custom view. */
    filterData?: Maybe<Scalars["JSONObject"]>;
    /** The filters applied to issues in the custom view. */
    filters?: Maybe<Scalars["JSONObject"]>;
    /** The icon of the custom view. */
    icon?: Maybe<Scalars["String"]>;
    /** The name of the custom view. */
    name?: Maybe<Scalars["String"]>;
    /** Whether the custom view is shared with everyone in the organization. */
    shared?: Maybe<Scalars["Boolean"]>;
    /** The id of the team associated with the custom view. */
    teamId?: Maybe<Scalars["String"]>;
};
/** A set of issues to be resolved in a specified amount of time. */
export declare type Cycle = Node & {
    __typename?: "Cycle";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the cycle was automatically archived by the auto pruning process. */
    autoArchivedAt?: Maybe<Scalars["DateTime"]>;
    /** The completion time of the cycle. If null, the cycle hasn't been completed. */
    completedAt?: Maybe<Scalars["DateTime"]>;
    /** The number of completed issues in the cycle after each day. */
    completedIssueCountHistory: Array<Scalars["Float"]>;
    /** The number of completed estimation points after each day. */
    completedScopeHistory: Array<Scalars["Float"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The end time of the cycle. */
    endsAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The total number of issues in the cycle after each day. */
    issueCountHistory: Array<Scalars["Float"]>;
    /** Issues associated with the cycle. */
    issues: IssueConnection;
    /** The custom name of the cycle. */
    name?: Maybe<Scalars["String"]>;
    /** The number of the cycle. */
    number: Scalars["Float"];
    /** The overall progress of the cycle. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points. */
    progress: Scalars["Float"];
    /** The total number of estimation points after each day. */
    scopeHistory: Array<Scalars["Float"]>;
    /** The start time of the cycle. */
    startsAt: Scalars["DateTime"];
    /** The team that the cycle is associated with. */
    team: Team;
    /** Issues that weren't completed when the cycle was closed. */
    uncompletedIssuesUponClose: IssueConnection;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
};
/** A set of issues to be resolved in a specified amount of time. */
export declare type CycleIssuesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A set of issues to be resolved in a specified amount of time. */
export declare type CycleUncompletedIssuesUponCloseArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type CycleConnection = {
    __typename?: "CycleConnection";
    edges: Array<CycleEdge>;
    nodes: Array<Cycle>;
    pageInfo: PageInfo;
};
export declare type CycleCreateInput = {
    /** The completion time of the cycle. If null, the cycle hasn't been completed. */
    completedAt?: Maybe<Scalars["DateTime"]>;
    /** The end date of the cycle. */
    endsAt: Scalars["DateTime"];
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The custom name of the cycle. */
    name?: Maybe<Scalars["String"]>;
    /** The start date of the cycle. */
    startsAt: Scalars["DateTime"];
    /** The team to associate the cycle with. */
    teamId: Scalars["String"];
};
export declare type CycleEdge = {
    __typename?: "CycleEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Cycle;
};
/** [Alpha] Project filtering options. */
export declare type CycleFilter = {
    /** Compound filters, all of which need to be matched by the cycle. */
    and?: Maybe<Array<CycleFilter>>;
    /** Comparator for the cycle completed at date. */
    completedAt?: Maybe<DateComparator>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Comparator for the cycle ends at date. */
    endsAt?: Maybe<DateComparator>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Filters that the cycles issues must satisfy. */
    issues?: Maybe<IssueCollectionFilter>;
    /** Comparator for the cycle name. */
    name?: Maybe<StringComparator>;
    /** Comparator for the cycle number. */
    number?: Maybe<NumberComparator>;
    /** Compound filters, one of which need to be matched by the cycle. */
    or?: Maybe<Array<CycleFilter>>;
    /** Comparator for the cycle start date. */
    startsAt?: Maybe<DateComparator>;
    /** Filters that the cycles team must satisfy. */
    team?: Maybe<TeamFilter>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
export declare type CyclePayload = {
    __typename?: "CyclePayload";
    /** The Cycle that was created or updated. */
    cycle?: Maybe<Cycle>;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type CycleUpdateInput = {
    /** The end date of the cycle. */
    completedAt?: Maybe<Scalars["DateTime"]>;
    /** The end date of the cycle. */
    endsAt?: Maybe<Scalars["DateTime"]>;
    /** The custom name of the cycle. */
    name?: Maybe<Scalars["String"]>;
    /** The start date of the cycle. */
    startsAt?: Maybe<Scalars["DateTime"]>;
};
/** Comparator for dates. */
export declare type DateComparator = {
    /** Equals constraint. */
    eq?: Maybe<Scalars["DateTime"]>;
    /** Greater-than constraint. Matches any values that are greater than the given value. */
    gt?: Maybe<Scalars["DateTime"]>;
    /** Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value. */
    gte?: Maybe<Scalars["DateTime"]>;
    /** In-array constraint. */
    in?: Maybe<Array<Scalars["DateTime"]>>;
    /** Less-than constraint. Matches any values that are less than the given value. */
    lt?: Maybe<Scalars["DateTime"]>;
    /** Less-than-or-equal constraint. Matches any values that are less than or equal to the given value. */
    lte?: Maybe<Scalars["DateTime"]>;
    /** Not-equals constraint. */
    neq?: Maybe<Scalars["DateTime"]>;
    /** Not-in-array constraint. */
    nin?: Maybe<Array<Scalars["DateTime"]>>;
};
export declare type DebugPayload = {
    __typename?: "DebugPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type DeleteOrganizationInput = {
    /** The deletion code to confirm operation. */
    deletionCode: Scalars["String"];
};
/** Contains the requested dependencies. */
export declare type DependencyResponse = {
    __typename?: "DependencyResponse";
    /** A JSON serialized collection of dependencies. */
    dependencies: Scalars["String"];
};
/** A document for a project. */
export declare type Document = Node & {
    __typename?: "Document";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The color of the icon. */
    color?: Maybe<Scalars["String"]>;
    /** The document content in markdown format. */
    content?: Maybe<Scalars["String"]>;
    /** The document content as JSON. */
    contentData?: Maybe<Scalars["JSONObject"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the document. */
    creator: User;
    /** The icon of the document. */
    icon?: Maybe<Scalars["String"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The project that the document is associated with. */
    project: Project;
    /** The document's unique URL slug. */
    slugId: Scalars["String"];
    /** The document title. */
    title: Scalars["String"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The user who last updated the document. */
    updatedBy: User;
};
export declare type DocumentConnection = {
    __typename?: "DocumentConnection";
    edges: Array<DocumentEdge>;
    nodes: Array<Document>;
    pageInfo: PageInfo;
};
export declare type DocumentCreateInput = {
    /** The color of the icon. */
    color?: Maybe<Scalars["String"]>;
    /** The document content as markdown. */
    content?: Maybe<Scalars["String"]>;
    /** [Internal] The document content as a Prosemirror document. */
    contentData?: Maybe<Scalars["JSONObject"]>;
    /** The icon of the document. */
    icon?: Maybe<Scalars["String"]>;
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** Related project for the document. */
    projectId: Scalars["String"];
    /** The title of the document. */
    title: Scalars["String"];
};
export declare type DocumentEdge = {
    __typename?: "DocumentEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Document;
};
export declare type DocumentPayload = {
    __typename?: "DocumentPayload";
    /** The document that was created or updated. */
    document: Document;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** Collaborative editing steps for documents. */
export declare type DocumentStep = Node & {
    __typename?: "DocumentStep";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** Connected client ID. */
    clientId: Scalars["String"];
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Step data. */
    step: Scalars["JSON"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** Step version. */
    version: Scalars["Float"];
};
export declare type DocumentUpdateInput = {
    /** The color of the icon. */
    color?: Maybe<Scalars["String"]>;
    /** The document content as markdown. */
    content?: Maybe<Scalars["String"]>;
    /** [Internal] The document content as a Prosemirror document. */
    contentData?: Maybe<Scalars["JSONObject"]>;
    /** The icon of the document. */
    icon?: Maybe<Scalars["String"]>;
    /** Related project for the document. */
    projectId?: Maybe<Scalars["String"]>;
    /** The title of the document. */
    title?: Maybe<Scalars["String"]>;
};
/** A version of a document. */
export declare type DocumentVersion = Node & {
    __typename?: "DocumentVersion";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The document's content in markdown format. */
    content?: Maybe<Scalars["String"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the version. */
    creator: User;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The project that the document is associated with. */
    project: Project;
    /** The version revision number. */
    revision: Scalars["Float"];
    /** The document's title. */
    title: Scalars["String"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type DocumentVersionConnection = {
    __typename?: "DocumentVersionConnection";
    edges: Array<DocumentVersionEdge>;
    nodes: Array<DocumentVersion>;
    pageInfo: PageInfo;
};
export declare type DocumentVersionEdge = {
    __typename?: "DocumentVersionEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: DocumentVersion;
};
export declare type EmailSubscribeInput = {
    /** Email to subscribe. */
    email: Scalars["String"];
};
export declare type EmailSubscribePayload = {
    __typename?: "EmailSubscribePayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type EmailUnsubscribeInput = {
    /** The user's email validation token. */
    token: Scalars["String"];
    /** Email type to unsubscribed from. */
    type: Scalars["String"];
    /** The identifier of the user. */
    userId: Scalars["String"];
};
export declare type EmailUnsubscribePayload = {
    __typename?: "EmailUnsubscribePayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type EmailUserAccountAuthChallengeInput = {
    /** Auth code for the client initiating the sequence. */
    clientAuthCode?: Maybe<Scalars["String"]>;
    /** The email for which to generate the magic login code. */
    email: Scalars["String"];
    /** Whether the login was requested from the desktop app. */
    isDesktop?: Maybe<Scalars["Boolean"]>;
    /** Signup code. */
    signupCode?: Maybe<Scalars["String"]>;
};
export declare type EmailUserAccountAuthChallengeResponse = {
    __typename?: "EmailUserAccountAuthChallengeResponse";
    /** Supported challenge for this user account. Can be either verificationCode or password. */
    authType: Scalars["String"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** A custom emoji. */
export declare type Emoji = Node & {
    __typename?: "Emoji";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the emoji. */
    creator: User;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The emoji's name. */
    name: Scalars["String"];
    /** The organization that the emoji belongs to. */
    organization: Organization;
    /** The source of the emoji. */
    source: Scalars["String"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The emoji image URL. */
    url: Scalars["String"];
};
export declare type EmojiConnection = {
    __typename?: "EmojiConnection";
    edges: Array<EmojiEdge>;
    nodes: Array<Emoji>;
    pageInfo: PageInfo;
};
export declare type EmojiCreateInput = {
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The name of the custom emoji. */
    name: Scalars["String"];
    /** The URL for the emoji. */
    url: Scalars["String"];
};
export declare type EmojiEdge = {
    __typename?: "EmojiEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Emoji;
};
export declare type EmojiPayload = {
    __typename?: "EmojiPayload";
    /** The emoji that was created. */
    emoji: Emoji;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type EventCreateInput = {
    /** The category of the event to create. */
    category: Scalars["String"];
    /** Additional data of the event, encoded as JSON. */
    data?: Maybe<Scalars["JSON"]>;
    /** The subject of the event. */
    subject: Scalars["String"];
    /** The target identifier of the event. */
    targetId?: Maybe<Scalars["String"]>;
    /** The value of the event. */
    value?: Maybe<Scalars["Float"]>;
};
export declare type EventPayload = {
    __typename?: "EventPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** User favorites presented in the sidebar. */
export declare type Favorite = Node & {
    __typename?: "Favorite";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** Children of the favorite. Only applies to favorites of type folder. */
    children: FavoriteConnection;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The favorited custom view. */
    customView?: Maybe<CustomView>;
    /** The favorited cycle. */
    cycle?: Maybe<Cycle>;
    /** The favorited document. */
    document?: Maybe<Document>;
    /** The name of the folder. Only applies to favorites of type folder. */
    folderName?: Maybe<Scalars["String"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The favorited issue. */
    issue?: Maybe<Issue>;
    /** The favorited label. */
    label?: Maybe<IssueLabel>;
    /** The parent folder of the favorite. */
    parent?: Maybe<Favorite>;
    /** The favorited project. */
    project?: Maybe<Project>;
    /** The favorited team of the project. */
    projectTeam?: Maybe<Team>;
    /** The order of the item in the favorites list. */
    sortOrder: Scalars["Float"];
    /** The type of the favorite. */
    type: Scalars["String"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The owner of the favorite. */
    user: User;
};
/** User favorites presented in the sidebar. */
export declare type FavoriteChildrenArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type FavoriteConnection = {
    __typename?: "FavoriteConnection";
    edges: Array<FavoriteEdge>;
    nodes: Array<Favorite>;
    pageInfo: PageInfo;
};
export declare type FavoriteCreateInput = {
    /** The identifier of the custom view to favorite. */
    customViewId?: Maybe<Scalars["String"]>;
    /** The identifier of the cycle to favorite. */
    cycleId?: Maybe<Scalars["String"]>;
    /** The identifier of the document to favorite. */
    documentId?: Maybe<Scalars["String"]>;
    /** The name of the favorite folder. */
    folderName?: Maybe<Scalars["String"]>;
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The identifier of the issue to favorite. */
    issueId?: Maybe<Scalars["String"]>;
    /** The identifier of the label to favorite. */
    labelId?: Maybe<Scalars["String"]>;
    /** The parent folder of the favorite. */
    parentId?: Maybe<Scalars["String"]>;
    /** The identifier of the project to favorite. */
    projectId?: Maybe<Scalars["String"]>;
    /** The identifier of the project team to favorite. */
    projectTeamId?: Maybe<Scalars["String"]>;
    /** The position of the item in the favorites list. */
    sortOrder?: Maybe<Scalars["Float"]>;
};
export declare type FavoriteEdge = {
    __typename?: "FavoriteEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Favorite;
};
export declare type FavoritePayload = {
    __typename?: "FavoritePayload";
    /** The object that was added as a favorite. */
    favorite: Favorite;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type FavoriteUpdateInput = {
    /** The id of the folder to move the favorite under. */
    parentId?: Maybe<Scalars["String"]>;
    /** The position of the item in the favorites list. */
    sortOrder?: Maybe<Scalars["Float"]>;
};
export declare type FeedbackCreateInput = {
    /** How disappointed the user would be if he/she could no longer use Linear. */
    disappointmentRating: Scalars["Float"];
    /** The feedback the user sent. */
    feedback: Scalars["String"];
};
export declare type FeedbackPayload = {
    __typename?: "FeedbackPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** Object representing Figma preview information. */
export declare type FigmaEmbed = {
    __typename?: "FigmaEmbed";
    /** Date when the file was updated at the time of embedding. */
    lastModified: Scalars["DateTime"];
    /** Figma file name. */
    name: Scalars["String"];
    /** Node name. */
    nodeName?: Maybe<Scalars["String"]>;
    /** Figma screenshot URL. */
    url?: Maybe<Scalars["String"]>;
};
export declare type FigmaEmbedPayload = {
    __typename?: "FigmaEmbedPayload";
    /** Figma embed information. */
    figmaEmbed?: Maybe<FigmaEmbed>;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type FrontAttachmentPayload = {
    __typename?: "FrontAttachmentPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type GitHubCommitIntegrationPayload = {
    __typename?: "GitHubCommitIntegrationPayload";
    /** The integration that was created or updated. */
    integration?: Maybe<Integration>;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The webhook secret to provide to GitHub. */
    webhookSecret: Scalars["String"];
};
/** GitHub OAuth token, plus information about the organizations the user is a member of. */
export declare type GithubOAuthTokenPayload = {
    __typename?: "GithubOAuthTokenPayload";
    /** A list of the GitHub organizations the user is a member of with attached repositories. */
    organizations?: Maybe<Array<GithubOrg>>;
    /** The OAuth token if the operation to fetch it was successful. */
    token?: Maybe<Scalars["String"]>;
};
/** Relevant information for the GitHub organization. */
export declare type GithubOrg = {
    __typename?: "GithubOrg";
    /** GitHub organization id. */
    id: Scalars["String"];
    /** The login for the GitHub organization. */
    login: Scalars["String"];
    /** The name of the GitHub organization. */
    name: Scalars["String"];
    /** Repositories that the organization owns. */
    repositories: Array<GithubRepo>;
};
/** Relevant information for the GitHub repository. */
export declare type GithubRepo = {
    __typename?: "GithubRepo";
    /** The id of the GitHub repository. */
    id: Scalars["String"];
    /** The name of the GitHub repository. */
    name: Scalars["String"];
};
/** Google Sheets specific settings. */
export declare type GoogleSheetsSettings = {
    __typename?: "GoogleSheetsSettings";
    sheetId: Scalars["Float"];
    spreadsheetId: Scalars["String"];
    spreadsheetUrl: Scalars["String"];
    updatedIssuesAt: Scalars["DateTime"];
};
export declare type GoogleSheetsSettingsInput = {
    sheetId: Scalars["Float"];
    spreadsheetId: Scalars["String"];
    spreadsheetUrl: Scalars["String"];
    updatedIssuesAt: Scalars["DateTime"];
};
export declare type GoogleUserAccountAuthInput = {
    /** Code returned from Google's OAuth flow. */
    code: Scalars["String"];
    /** The URI to redirect the user to. */
    redirectUri?: Maybe<Scalars["String"]>;
    /** Signup code. */
    signupCode?: Maybe<Scalars["String"]>;
    /** The identifiers of the teams to auto-join. */
    teamIdsToJoin?: Maybe<Array<Scalars["String"]>>;
    /** The timezone of the user's browser. */
    timezone: Scalars["String"];
};
/** Comparator for identifiers. */
export declare type IdComparator = {
    /** Equals constraint. */
    eq?: Maybe<Scalars["ID"]>;
    /** In-array constraint. */
    in?: Maybe<Array<Scalars["ID"]>>;
    /** Not-equals constraint. */
    neq?: Maybe<Scalars["ID"]>;
    /** Not-in-array constraint. */
    nin?: Maybe<Array<Scalars["ID"]>>;
};
export declare type ImageUploadFromUrlPayload = {
    __typename?: "ImageUploadFromUrlPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The URL containing the image. */
    url?: Maybe<Scalars["String"]>;
};
/** An integration with an external service. */
export declare type Integration = Node & {
    __typename?: "Integration";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user that added the integration. */
    creator: User;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The organization that the integration is associated with. */
    organization: Organization;
    /** The integration's type. */
    service: Scalars["String"];
    /** The team that the integration is associated with. */
    team?: Maybe<Team>;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type IntegrationConnection = {
    __typename?: "IntegrationConnection";
    edges: Array<IntegrationEdge>;
    nodes: Array<Integration>;
    pageInfo: PageInfo;
};
export declare type IntegrationEdge = {
    __typename?: "IntegrationEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Integration;
};
export declare type IntegrationPayload = {
    __typename?: "IntegrationPayload";
    /** The integration that was created or updated. */
    integration?: Maybe<Integration>;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** An integration resource created by an external service. */
export declare type IntegrationResource = Node & {
    __typename?: "IntegrationResource";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** Detailed information about the external resource. */
    data: IntegrationResourceData;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The integration that the resource is associated with. */
    integration: Integration;
    /** The issue that the resource is associated with. */
    issue: Issue;
    /** Pull request information for GitHub pull requests and GitLab merge requests. */
    pullRequest: PullRequestPayload;
    /** The external service resource ID. */
    resourceId: Scalars["String"];
    /** The integration's type. */
    resourceType: Scalars["String"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type IntegrationResourceConnection = {
    __typename?: "IntegrationResourceConnection";
    edges: Array<IntegrationResourceEdge>;
    nodes: Array<IntegrationResource>;
    pageInfo: PageInfo;
};
/** Integration resource's payload */
export declare type IntegrationResourceData = {
    __typename?: "IntegrationResourceData";
    /** The payload for an IntegrationResource of type 'githubCommit' */
    githubCommit?: Maybe<CommitPayload>;
    /** The payload for an IntegrationResource of type 'githubPullRequest' */
    githubPullRequest?: Maybe<PullRequestPayload>;
    /** The payload for an IntegrationResource of type 'gitlabMergeRequest' */
    gitlabMergeRequest?: Maybe<PullRequestPayload>;
    /** The payload for an IntegrationResource of type 'sentryIssue' */
    sentryIssue?: Maybe<SentryIssuePayload>;
};
export declare type IntegrationResourceEdge = {
    __typename?: "IntegrationResourceEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: IntegrationResource;
};
/** The integration resource's settings */
export declare type IntegrationSettings = {
    __typename?: "IntegrationSettings";
    googleSheets?: Maybe<GoogleSheetsSettings>;
    intercom?: Maybe<IntercomSettings>;
    jira?: Maybe<JiraSettings>;
    sentry?: Maybe<SentrySettings>;
    slackPost?: Maybe<SlackPostSettings>;
    slackProjectPost?: Maybe<SlackPostSettings>;
    zendesk?: Maybe<ZendeskSettings>;
};
export declare type IntegrationSettingsInput = {
    googleSheets?: Maybe<GoogleSheetsSettingsInput>;
    intercom?: Maybe<IntercomSettingsInput>;
    jira?: Maybe<JiraSettingsInput>;
    sentry?: Maybe<SentrySettingsInput>;
    slackPost?: Maybe<SlackPostSettingsInput>;
    slackProjectPost?: Maybe<SlackPostSettingsInput>;
    zendesk?: Maybe<ZendeskSettingsInput>;
};
/** Intercom specific settings. */
export declare type IntercomSettings = {
    __typename?: "IntercomSettings";
    /** Whether an internal message should be added when someone comments on an issue. */
    sendNoteOnComment?: Maybe<Scalars["Boolean"]>;
    /** Whether an internal message should be added when a Linear issue changes status (for status types except completed or canceled). */
    sendNoteOnStatusChange?: Maybe<Scalars["Boolean"]>;
};
export declare type IntercomSettingsInput = {
    /** Whether an internal message should be added when someone comments on an issue. */
    sendNoteOnComment?: Maybe<Scalars["Boolean"]>;
    /** Whether an internal message should be added when a Linear issue changes status (for status types except completed or canceled). */
    sendNoteOnStatusChange?: Maybe<Scalars["Boolean"]>;
};
export declare type Invoice = {
    __typename?: "Invoice";
    /** The creation date of the invoice. */
    created: Scalars["DateTime"];
    /** The due date of the invoice. */
    dueDate?: Maybe<Scalars["TimelessDate"]>;
    /** The status of the invoice. */
    status: Scalars["String"];
    /** The invoice total, in cents. */
    total: Scalars["Float"];
    /** The URL at which the invoice can be viewed or paid. */
    url?: Maybe<Scalars["String"]>;
};
/** An issue. */
export declare type Issue = Node & {
    __typename?: "Issue";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The user to whom the issue is assigned to. */
    assignee?: Maybe<User>;
    /** Attachments associated with the issue. */
    attachments: AttachmentConnection;
    /** The time at which the issue was automatically archived by the auto pruning process. */
    autoArchivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the issue was automatically closed by the auto pruning process. */
    autoClosedAt?: Maybe<Scalars["DateTime"]>;
    /**
     * The order of the item in its column on the board.
     * @deprecated Will be removed in near future, please use `sortOrder` instead
     */
    boardOrder: Scalars["Float"];
    /** Suggested branch name for the issue. */
    branchName: Scalars["String"];
    /** The time at which the issue was moved into canceled state. */
    canceledAt?: Maybe<Scalars["DateTime"]>;
    /** Children of the issue. */
    children: IssueConnection;
    /** Comments associated with the issue. */
    comments: CommentConnection;
    /** The time at which the issue was moved into completed state. */
    completedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the issue. */
    creator?: Maybe<User>;
    /** Returns the number of Attachment resources which are created by customer support ticketing systems (e.g. Zendesk). */
    customerTicketCount: Scalars["Int"];
    /** The cycle that the issue is associated with. */
    cycle?: Maybe<Cycle>;
    /** The issue's description in markdown format. */
    description?: Maybe<Scalars["String"]>;
    /** The date at which the issue is due. */
    dueDate?: Maybe<Scalars["TimelessDate"]>;
    /** The estimate of the complexity of the issue.. */
    estimate?: Maybe<Scalars["Float"]>;
    /** History entries associated with the issue. */
    history: IssueHistoryConnection;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Issue's human readable identifier (e.g. ENG-123). */
    identifier: Scalars["String"];
    /** Integration resources for this issue. */
    integrationResources: IntegrationResourceConnection;
    /** Inverse relations associated with this issue. */
    inverseRelations: IssueRelationConnection;
    /** Labels associated with this issue. */
    labels: IssueLabelConnection;
    /** The issue's unique number. */
    number: Scalars["Float"];
    /** The parent of the issue. */
    parent?: Maybe<Issue>;
    /** Previous identifiers of the issue if it has been moved between teams. */
    previousIdentifiers: Array<Scalars["String"]>;
    /** The priority of the issue. */
    priority: Scalars["Float"];
    /** Label for the priority. */
    priorityLabel: Scalars["String"];
    /** The project that the issue is associated with. */
    project?: Maybe<Project>;
    /** Relations associated with this issue. */
    relations: IssueRelationConnection;
    /** The user who snoozed the issue. */
    snoozedBy?: Maybe<User>;
    /** The time until an issue will be snoozed in Triage view. */
    snoozedUntilAt?: Maybe<Scalars["DateTime"]>;
    /** The order of the item in relation to other items in the organization. */
    sortOrder: Scalars["Float"];
    /** The time at which the issue was moved into started state. */
    startedAt?: Maybe<Scalars["DateTime"]>;
    /** The workflow state that the issue is associated with. */
    state: WorkflowState;
    /** The order of the item in the sub-issue list. Only set if the issue has a parent. */
    subIssueSortOrder?: Maybe<Scalars["Float"]>;
    /** Users who are subscribed to the issue. */
    subscribers: UserConnection;
    /** The team that the issue is associated with. */
    team: Team;
    /** The issue's title. */
    title: Scalars["String"];
    /** A flag that indicates whether the issue is in the trash bin. */
    trashed?: Maybe<Scalars["Boolean"]>;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** Issue URL. */
    url: Scalars["String"];
};
/** An issue. */
export declare type IssueAttachmentsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<AttachmentFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An issue. */
export declare type IssueChildrenArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An issue. */
export declare type IssueCommentsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<CommentFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An issue. */
export declare type IssueHistoryArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An issue. */
export declare type IssueIntegrationResourcesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An issue. */
export declare type IssueInverseRelationsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An issue. */
export declare type IssueLabelsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueLabelFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An issue. */
export declare type IssueRelationsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An issue. */
export declare type IssueSubscribersArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<UserFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    includeDisabled?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type IssueBatchPayload = {
    __typename?: "IssueBatchPayload";
    /** The issues that were updated. */
    issues: Array<Issue>;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** [Alpha] Issue filtering options. */
export declare type IssueCollectionFilter = {
    /** Compound filters, all of which need to be matched by the issue. */
    and?: Maybe<Array<IssueFilter>>;
    /** Filters that the issues assignee must satisfy. */
    assignee?: Maybe<NullableUserFilter>;
    /** Filters that the issues attachments must satisfy. */
    attachments?: Maybe<AttachmentFilter>;
    /** Comparator for the issues auto archived at date. */
    autoArchivedAt?: Maybe<NullableDateComparator>;
    /** Comparator for the issues auto closed at date. */
    autoClosedAt?: Maybe<NullableDateComparator>;
    /** Comparator for the issues canceled at date. */
    canceledAt?: Maybe<NullableDateComparator>;
    /** Filters that the child issues must satisfy. */
    children?: Maybe<IssueCollectionFilter>;
    /** Filters that the issues comments must satisfy. */
    comments?: Maybe<CommentCollectionFilter>;
    /** Comparator for the issues completed at date. */
    completedAt?: Maybe<NullableDateComparator>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Filters that the issues creator must satisfy. */
    creator?: Maybe<UserFilter>;
    /** Filters that the issues cycle must satisfy. */
    cycle?: Maybe<NullableCycleFilter>;
    /** Comparator for the issues description. */
    description?: Maybe<NullableStringComparator>;
    /** Comparator for the issues due date. */
    dueDate?: Maybe<NullableTimelessDateComparator>;
    /** Comparator for the issues estimate. */
    estimate?: Maybe<NumberComparator>;
    /** Filters that needs to be matched by all issues. */
    every?: Maybe<IssueFilter>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Filters that issue labels must satisfy. */
    labels?: Maybe<IssueLabelCollectionFilter>;
    /** Comparator for the issues number. */
    number?: Maybe<NumberComparator>;
    /** Compound filters, one of which need to be matched by the issue. */
    or?: Maybe<Array<IssueFilter>>;
    /** Comparator for the issues priority. */
    priority?: Maybe<NullableNumberComparator>;
    /** Filters that the issues project must satisfy. */
    project?: Maybe<NullableProjectFilter>;
    /** Filters that the issues snoozer must satisfy. */
    snoozedBy?: Maybe<NullableUserFilter>;
    /** Comparator for the issues snoozed until date. */
    snoozedUntilAt?: Maybe<NullableDateComparator>;
    /** Filters that needs to be matched by some issues. */
    some?: Maybe<IssueFilter>;
    /** Comparator for the issues started at date. */
    startedAt?: Maybe<NullableDateComparator>;
    /** Filters that the issues state must satisfy. */
    state?: Maybe<WorkflowStateFilter>;
    /** Filters that the issues team must satisfy. */
    team?: Maybe<TeamFilter>;
    /** Comparator for the issues title. */
    title?: Maybe<StringComparator>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
export declare type IssueConnection = {
    __typename?: "IssueConnection";
    edges: Array<IssueEdge>;
    nodes: Array<Issue>;
    pageInfo: PageInfo;
};
export declare type IssueCreateInput = {
    /** The identifier of the user to assign the issue to. */
    assigneeId?: Maybe<Scalars["String"]>;
    /** The position of the issue in its column on the board view. */
    boardOrder?: Maybe<Scalars["Float"]>;
    /** The cycle associated with the issue. */
    cycleId?: Maybe<Scalars["String"]>;
    /** The issue description in markdown format. */
    description?: Maybe<Scalars["String"]>;
    /** The issue description as a Prosemirror document. */
    descriptionData?: Maybe<Scalars["JSON"]>;
    /** The date at which the issue is due. */
    dueDate?: Maybe<Scalars["TimelessDate"]>;
    /** The estimated complexity of the issue. */
    estimate?: Maybe<Scalars["Int"]>;
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The identifiers of the issue labels associated with this ticket. */
    labelIds?: Maybe<Array<Scalars["String"]>>;
    /** The identifier of the parent issue. */
    parentId?: Maybe<Scalars["String"]>;
    /** The priority of the issue. */
    priority?: Maybe<Scalars["Int"]>;
    /** The project associated with the issue. */
    projectId?: Maybe<Scalars["String"]>;
    /** The comment the issue is referencing. */
    referenceCommentId?: Maybe<Scalars["String"]>;
    /** The position of the issue related to other issues. */
    sortOrder?: Maybe<Scalars["Float"]>;
    /** The team state of the issue. */
    stateId?: Maybe<Scalars["String"]>;
    /** The position of the issue in parent's sub-issue list. */
    subIssueSortOrder?: Maybe<Scalars["Float"]>;
    /** The identifiers of the users subscribing to this ticket. */
    subscriberIds?: Maybe<Array<Scalars["String"]>>;
    /** The identifier or key of the team associated with the issue. */
    teamId: Scalars["String"];
    /** The title of the issue. */
    title: Scalars["String"];
};
export declare type IssueDescriptionHistory = {
    __typename?: "IssueDescriptionHistory";
    /** The ID of the author of the change. */
    actorId?: Maybe<Scalars["String"]>;
    /** The description data of the issue as a JSON serialized string. */
    descriptionData: Scalars["String"];
    /** The UUID of the change. */
    id: Scalars["String"];
    /** The type of the revision, whether it was the creation or update of the issue. */
    type: Scalars["String"];
    /** The date when the description was updated. */
    updatedAt: Scalars["DateTime"];
};
export declare type IssueDescriptionHistoryPayload = {
    __typename?: "IssueDescriptionHistoryPayload";
    /** The issue that was created or updated. */
    history?: Maybe<Array<IssueDescriptionHistory>>;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type IssueEdge = {
    __typename?: "IssueEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Issue;
};
/** [Alpha] Issue filtering options. */
export declare type IssueFilter = {
    /** Compound filters, all of which need to be matched by the issue. */
    and?: Maybe<Array<IssueFilter>>;
    /** Filters that the issues assignee must satisfy. */
    assignee?: Maybe<NullableUserFilter>;
    /** Filters that the issues attachments must satisfy. */
    attachments?: Maybe<AttachmentFilter>;
    /** Comparator for the issues auto archived at date. */
    autoArchivedAt?: Maybe<NullableDateComparator>;
    /** Comparator for the issues auto closed at date. */
    autoClosedAt?: Maybe<NullableDateComparator>;
    /** Comparator for the issues canceled at date. */
    canceledAt?: Maybe<NullableDateComparator>;
    /** Filters that the child issues must satisfy. */
    children?: Maybe<IssueCollectionFilter>;
    /** Filters that the issues comments must satisfy. */
    comments?: Maybe<CommentCollectionFilter>;
    /** Comparator for the issues completed at date. */
    completedAt?: Maybe<NullableDateComparator>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Filters that the issues creator must satisfy. */
    creator?: Maybe<UserFilter>;
    /** Filters that the issues cycle must satisfy. */
    cycle?: Maybe<NullableCycleFilter>;
    /** Comparator for the issues description. */
    description?: Maybe<NullableStringComparator>;
    /** Comparator for the issues due date. */
    dueDate?: Maybe<NullableTimelessDateComparator>;
    /** Comparator for the issues estimate. */
    estimate?: Maybe<NumberComparator>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Filters that issue labels must satisfy. */
    labels?: Maybe<IssueLabelCollectionFilter>;
    /** Comparator for the issues number. */
    number?: Maybe<NumberComparator>;
    /** Compound filters, one of which need to be matched by the issue. */
    or?: Maybe<Array<IssueFilter>>;
    /** Comparator for the issues priority. */
    priority?: Maybe<NullableNumberComparator>;
    /** Filters that the issues project must satisfy. */
    project?: Maybe<NullableProjectFilter>;
    /** Filters that the issues snoozer must satisfy. */
    snoozedBy?: Maybe<NullableUserFilter>;
    /** Comparator for the issues snoozed until date. */
    snoozedUntilAt?: Maybe<NullableDateComparator>;
    /** Comparator for the issues started at date. */
    startedAt?: Maybe<NullableDateComparator>;
    /** Filters that the issues state must satisfy. */
    state?: Maybe<WorkflowStateFilter>;
    /** Filters that the issues team must satisfy. */
    team?: Maybe<TeamFilter>;
    /** Comparator for the issues title. */
    title?: Maybe<StringComparator>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
/** A record of changes to an issue. */
export declare type IssueHistory = Node & {
    __typename?: "IssueHistory";
    /** The user who made these changes. If null, possibly means that the change made by an integration. */
    actor?: Maybe<User>;
    /** ID's of labels that were added. */
    addedLabelIds?: Maybe<Array<Scalars["String"]>>;
    /** Whether the issue was archived or un-archived. */
    archived?: Maybe<Scalars["Boolean"]>;
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    autoArchived?: Maybe<Scalars["Boolean"]>;
    autoClosed?: Maybe<Scalars["Boolean"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user from whom the issue was re-assigned from. */
    fromAssignee?: Maybe<User>;
    /** The previous cycle of the issue. */
    fromCycle?: Maybe<Cycle>;
    /** What the due date was changed from */
    fromDueDate?: Maybe<Scalars["TimelessDate"]>;
    /** What the estimate was changed from. */
    fromEstimate?: Maybe<Scalars["Float"]>;
    /** The previous parent of the issue. */
    fromParent?: Maybe<Issue>;
    /** What the priority was changed from. */
    fromPriority?: Maybe<Scalars["Float"]>;
    /** The previous project of the issue. */
    fromProject?: Maybe<Project>;
    /** The previous workflow state of the issue. */
    fromState?: Maybe<WorkflowState>;
    /** The team from which the issue was moved from. */
    fromTeam?: Maybe<Team>;
    /** What the title was changed from. */
    fromTitle?: Maybe<Scalars["String"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The issue that was changed. */
    issue: Issue;
    /** The import record. */
    issueImport?: Maybe<IssueImport>;
    /** Changed issue relationships. */
    relationChanges?: Maybe<Array<IssueRelationHistoryPayload>>;
    /** ID's of labels that were removed. */
    removedLabelIds?: Maybe<Array<Scalars["String"]>>;
    /** Information about the integration or application which created this history entry. */
    source?: Maybe<Scalars["JSONObject"]>;
    /** The user to whom the issue was assigned to. */
    toAssignee?: Maybe<User>;
    /** The new cycle of the issue. */
    toCycle?: Maybe<Cycle>;
    /** What the due date was changed to */
    toDueDate?: Maybe<Scalars["TimelessDate"]>;
    /** What the estimate was changed to. */
    toEstimate?: Maybe<Scalars["Float"]>;
    /** The new parent of the issue. */
    toParent?: Maybe<Issue>;
    /** What the priority was changed to. */
    toPriority?: Maybe<Scalars["Float"]>;
    /** The new project of the issue. */
    toProject?: Maybe<Project>;
    /** The new workflow state of the issue. */
    toState?: Maybe<WorkflowState>;
    /** The team to which the issue was moved to. */
    toTeam?: Maybe<Team>;
    /** What the title was changed to. */
    toTitle?: Maybe<Scalars["String"]>;
    /** Whether the issue was trashed or un-trashed. */
    trashed?: Maybe<Scalars["Boolean"]>;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** Whether the issue's description was updated. */
    updatedDescription?: Maybe<Scalars["Boolean"]>;
};
export declare type IssueHistoryConnection = {
    __typename?: "IssueHistoryConnection";
    edges: Array<IssueHistoryEdge>;
    nodes: Array<IssueHistory>;
    pageInfo: PageInfo;
};
export declare type IssueHistoryEdge = {
    __typename?: "IssueHistoryEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: IssueHistory;
};
/** An import job for data from an external service */
export declare type IssueImport = Node & {
    __typename?: "IssueImport";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The id for the user that started the job. */
    creatorId: Scalars["String"];
    /** User readable error message, if one has occurred during the import. */
    error?: Maybe<Scalars["String"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The data mapping configuration for the import job. */
    mapping?: Maybe<Scalars["JSONObject"]>;
    /** The service from which data will be imported. */
    service: Scalars["String"];
    /** The status for the import job. */
    status: Scalars["String"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type IssueImportDeletePayload = {
    __typename?: "IssueImportDeletePayload";
    /** The import job that was deleted. */
    issueImport?: Maybe<IssueImport>;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** Issue import mapping input */
export declare type IssueImportMappingInput = {
    /** The mapping configuration for epics */
    epics?: Maybe<Scalars["JSONObject"]>;
    /** The mapping configuration for users */
    users?: Maybe<Scalars["JSONObject"]>;
    /** The mapping configuration for workflow states */
    workflowStates?: Maybe<Scalars["JSONObject"]>;
};
export declare type IssueImportPayload = {
    __typename?: "IssueImportPayload";
    /** The import job that was created or updated. */
    issueImport?: Maybe<IssueImport>;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type IssueImportUpdateInput = {
    /** The mapping configuration for the import. */
    mapping: Scalars["JSONObject"];
};
/** Labels that can be associated with issues. */
export declare type IssueLabel = Node & {
    __typename?: "IssueLabel";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The label's color as a HEX string. */
    color: Scalars["String"];
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the label. */
    creator?: Maybe<User>;
    /** The label's description. */
    description?: Maybe<Scalars["String"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Issues associated with the label. */
    issues: IssueConnection;
    /** The label's name. */
    name: Scalars["String"];
    /** @deprecated Workspace labels are identified by their team being null. */
    organization?: Maybe<Organization>;
    /** The team that the label is associated with. If null, the label is associated with the global workspace.. */
    team?: Maybe<Team>;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
};
/** Labels that can be associated with issues. */
export declare type IssueLabelIssuesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** [Alpha] Issue label filtering options. */
export declare type IssueLabelCollectionFilter = {
    /** Compound filters, all of which need to be matched by the label. */
    and?: Maybe<Array<IssueLabelFilter>>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Filters that the issue labels creator must satisfy. */
    creator?: Maybe<NullableUserFilter>;
    /** Filters that needs to be matched by all issue labels. */
    every?: Maybe<IssueLabelFilter>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Comparator for the name. */
    name?: Maybe<StringComparator>;
    /** Compound filters, one of which need to be matched by the label. */
    or?: Maybe<Array<IssueLabelFilter>>;
    /** Filters that needs to be matched by some issue labels. */
    some?: Maybe<IssueLabelFilter>;
    /** Filters that the issue labels team must satisfy. */
    team?: Maybe<TeamFilter>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
export declare type IssueLabelConnection = {
    __typename?: "IssueLabelConnection";
    edges: Array<IssueLabelEdge>;
    nodes: Array<IssueLabel>;
    pageInfo: PageInfo;
};
export declare type IssueLabelCreateInput = {
    /** The color of the label. */
    color?: Maybe<Scalars["String"]>;
    /** The description of the label. */
    description?: Maybe<Scalars["String"]>;
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The name of the label. */
    name: Scalars["String"];
    /** The team associated with the label. If not given, the label will be associated with the entire workspace. */
    teamId?: Maybe<Scalars["String"]>;
};
export declare type IssueLabelEdge = {
    __typename?: "IssueLabelEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: IssueLabel;
};
/** [Alpha] Issue label filtering options. */
export declare type IssueLabelFilter = {
    /** Compound filters, all of which need to be matched by the label. */
    and?: Maybe<Array<IssueLabelFilter>>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Filters that the issue labels creator must satisfy. */
    creator?: Maybe<NullableUserFilter>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Comparator for the name. */
    name?: Maybe<StringComparator>;
    /** Compound filters, one of which need to be matched by the label. */
    or?: Maybe<Array<IssueLabelFilter>>;
    /** Filters that the issue labels team must satisfy. */
    team?: Maybe<TeamFilter>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
export declare type IssueLabelPayload = {
    __typename?: "IssueLabelPayload";
    /** The label that was created or updated. */
    issueLabel: IssueLabel;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type IssueLabelUpdateInput = {
    /** The color of the label. */
    color?: Maybe<Scalars["String"]>;
    /** The description of the label. */
    description?: Maybe<Scalars["String"]>;
    /** The name of the label. */
    name?: Maybe<Scalars["String"]>;
};
export declare type IssuePayload = {
    __typename?: "IssuePayload";
    /** The issue that was created or updated. */
    issue?: Maybe<Issue>;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type IssuePriorityValue = {
    __typename?: "IssuePriorityValue";
    /** Priority's label. */
    label: Scalars["String"];
    /** Priority's number value. */
    priority: Scalars["Int"];
};
/** A relation between two issues. */
export declare type IssueRelation = Node & {
    __typename?: "IssueRelation";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The issue whose relationship is being described. */
    issue: Issue;
    /** The related issue. */
    relatedIssue: Issue;
    /** The relationship of the issue with the related issue. */
    type: Scalars["String"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type IssueRelationConnection = {
    __typename?: "IssueRelationConnection";
    edges: Array<IssueRelationEdge>;
    nodes: Array<IssueRelation>;
    pageInfo: PageInfo;
};
export declare type IssueRelationCreateInput = {
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The identifier of the issue that is related to another issue. */
    issueId: Scalars["String"];
    /** The identifier of the related issue. */
    relatedIssueId: Scalars["String"];
    /** The type of relation of the issue to the related issue. */
    type: IssueRelationType;
};
export declare type IssueRelationEdge = {
    __typename?: "IssueRelationEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: IssueRelation;
};
/** Issue relation history's payload */
export declare type IssueRelationHistoryPayload = {
    __typename?: "IssueRelationHistoryPayload";
    /** The identifier of the related issue. */
    identifier: Scalars["String"];
    /** The type of the change. */
    type: Scalars["String"];
};
export declare type IssueRelationPayload = {
    __typename?: "IssueRelationPayload";
    /** The issue relation that was created or updated. */
    issueRelation: IssueRelation;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** The type of the issue relation. */
export declare enum IssueRelationType {
    Blocks = "blocks",
    Duplicate = "duplicate",
    Related = "related"
}
export declare type IssueRelationUpdateInput = {
    /** The identifier of the issue that is related to another issue. */
    issueId?: Maybe<Scalars["String"]>;
    /** The identifier of the related issue. */
    relatedIssueId?: Maybe<Scalars["String"]>;
    /** The type of relation of the issue to the related issue. */
    type?: Maybe<Scalars["String"]>;
};
export declare type IssueUpdateInput = {
    /** The identifier of the user to assign the issue to. */
    assigneeId?: Maybe<Scalars["String"]>;
    /** The position of the issue in its column on the board view. */
    boardOrder?: Maybe<Scalars["Float"]>;
    /** The cycle associated with the issue. */
    cycleId?: Maybe<Scalars["String"]>;
    /** The issue description in markdown format. */
    description?: Maybe<Scalars["String"]>;
    /** The issue description as a Prosemirror document. */
    descriptionData?: Maybe<Scalars["JSON"]>;
    /** [DEPRECATED] Document version for backwards compatibility. */
    documentVersion?: Maybe<Scalars["Int"]>;
    /** The date at which the issue is due. */
    dueDate?: Maybe<Scalars["TimelessDate"]>;
    /** The estimated complexity of the issue. */
    estimate?: Maybe<Scalars["Int"]>;
    /** The identifiers of the issue labels associated with this ticket. */
    labelIds?: Maybe<Array<Scalars["String"]>>;
    /** The identifier of the parent issue. */
    parentId?: Maybe<Scalars["String"]>;
    /** The priority of the issue. */
    priority?: Maybe<Scalars["Int"]>;
    /** The project associated with the issue. */
    projectId?: Maybe<Scalars["String"]>;
    /** The identifier of the user who snoozed the issue. */
    snoozedById?: Maybe<Scalars["String"]>;
    /** The time until an issue will be snoozed in Triage view. */
    snoozedUntilAt?: Maybe<Scalars["DateTime"]>;
    /** The position of the issue related to other issues. */
    sortOrder?: Maybe<Scalars["Float"]>;
    /** The team state of the issue. */
    stateId?: Maybe<Scalars["String"]>;
    /** The position of the issue in parent's sub-issue list. */
    subIssueSortOrder?: Maybe<Scalars["Float"]>;
    /** The identifiers of the users subscribing to this ticket. */
    subscriberIds?: Maybe<Array<Scalars["String"]>>;
    /** The identifier or key of the team associated with the issue. */
    teamId?: Maybe<Scalars["String"]>;
    /** The issue title. */
    title?: Maybe<Scalars["String"]>;
    /** Wether the issue has been trashed. */
    trashed?: Maybe<Scalars["Boolean"]>;
};
export declare type JiraConfigurationInput = {
    /** The Jira personal access token. */
    accessToken: Scalars["String"];
    /** The Jira user's email address. */
    email: Scalars["String"];
    /** The Jira installation hostname. */
    hostname: Scalars["String"];
    /** The Jira project keys to scope the integration to. */
    project?: Maybe<Scalars["String"]>;
};
/** Tuple for mapping Jira projects to Linear teams. */
export declare type JiraLinearMapping = {
    __typename?: "JiraLinearMapping";
    /** The Jira id for this project. */
    jiraProjectId: Scalars["String"];
    /** The Linear team id to map to the given project. */
    linearTeamId: Scalars["String"];
};
export declare type JiraLinearMappingInput = {
    /** The Jira id for this project. */
    jiraProjectId: Scalars["String"];
    /** The Linear team id to map to the given project. */
    linearTeamId: Scalars["String"];
};
/** Metadata about a Jira project. */
export declare type JiraProjectData = {
    __typename?: "JiraProjectData";
    /** The Jira id for this project. */
    id: Scalars["String"];
    /** The Jira key for this project, such as ENG. */
    key: Scalars["String"];
    /** The Jira name for this project, such as Engineering. */
    name: Scalars["String"];
};
export declare type JiraProjectDataInput = {
    /** The Jira id for this project. */
    id: Scalars["String"];
    /** The Jira key for this project, such as ENG. */
    key: Scalars["String"];
    /** The Jira name for this project, such as Engineering. */
    name: Scalars["String"];
};
/** Jira specific settings. */
export declare type JiraSettings = {
    __typename?: "JiraSettings";
    /** The mapping of Jira project id => Linear team id. */
    projectMapping?: Maybe<Array<JiraLinearMapping>>;
    /** The Jira projects for the organization. */
    projects: Array<JiraProjectData>;
};
export declare type JiraSettingsInput = {
    /** The mapping of Jira project id => Linear team id. */
    projectMapping?: Maybe<Array<JiraLinearMappingInput>>;
    /** The Jira projects for the organization. */
    projects: Array<JiraProjectDataInput>;
};
export declare type JoinOrganizationInput = {
    /** The identifier of the organization. */
    organizationId: Scalars["String"];
};
/** A milestone that contains projects. */
export declare type Milestone = Node & {
    __typename?: "Milestone";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The name of the milestone. */
    name: Scalars["String"];
    /** The organization that the milestone belongs to. */
    organization: Organization;
    /** Projects associated with the milestone. */
    projects: ProjectConnection;
    /** The sort order for the milestone. */
    sortOrder: Scalars["Float"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
};
/** A milestone that contains projects. */
export declare type MilestoneProjectsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<ProjectFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type MilestoneConnection = {
    __typename?: "MilestoneConnection";
    edges: Array<MilestoneEdge>;
    nodes: Array<Milestone>;
    pageInfo: PageInfo;
};
export declare type MilestoneCreateInput = {
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The name of the milestone. */
    name: Scalars["String"];
    /** The sort order of the milestone. */
    sortOrder?: Maybe<Scalars["Float"]>;
};
export declare type MilestoneEdge = {
    __typename?: "MilestoneEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Milestone;
};
/** [Alpha] Milestone filtering options. */
export declare type MilestoneFilter = {
    /** Compound filters, all of which need to be matched by the milestone. */
    and?: Maybe<Array<MilestoneFilter>>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Comparator for the milestone name. */
    name?: Maybe<StringComparator>;
    /** Compound filters, one of which need to be matched by the milestone. */
    or?: Maybe<Array<MilestoneFilter>>;
    /** Filters that the milestones projects must satisfy. */
    projects?: Maybe<ProjectCollectionFilter>;
    /** Comparator for the milestone sort order. */
    sortOrder?: Maybe<NumberComparator>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
export declare type MilestonePayload = {
    __typename?: "MilestonePayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** The milesteone that was created or updated. */
    milestone?: Maybe<Milestone>;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type MilestoneUpdateInput = {
    /** The name of the milestone. */
    name?: Maybe<Scalars["String"]>;
    /** The sort order of the milestone. */
    sortOrder?: Maybe<Scalars["Float"]>;
};
export declare type Mutation = {
    __typename?: "Mutation";
    /** [Internal] Creates a new API key. */
    apiKeyCreate: ApiKeyPayload;
    /** [Internal] Deletes an API key. */
    apiKeyDelete: ArchivePayload;
    /**
     * [DEPRECATED] Archives an issue attachment.
     * @deprecated This mutation is deprecated, please use `attachmentDelete` instead
     */
    attachmentArchive: ArchivePayload;
    /** [Alpha] Creates a new attachment, or updates existing if the same `url` and `issueId` is used. */
    attachmentCreate: AttachmentPayload;
    /** [Alpha] Deletes an issue attachment. */
    attachmentDelete: ArchivePayload;
    /** Link an existing Front conversation to an issue. */
    attachmentLinkFront: FrontAttachmentPayload;
    /** Link an existing Intercom conversation to an issue. */
    attachmentLinkIntercom: AttachmentPayload;
    /** Link an existing Jira issue to an issue. */
    attachmentLinkJiraIssue: AttachmentPayload;
    /** Link any url to an issue. */
    attachmentLinkURL: AttachmentPayload;
    /** Link an existing Zendesk ticket to an issue. */
    attachmentLinkZendesk: AttachmentPayload;
    /** [Alpha] Updates an existing issue attachment. */
    attachmentUpdate: AttachmentPayload;
    /** Updates the billing email address for the customer. */
    billingEmailUpdate: BillingEmailPayload;
    /** Update collaborative document with client steps. */
    collaborativeDocumentUpdate: CollaborationDocumentUpdatePayload;
    /** Creates a new comment. */
    commentCreate: CommentPayload;
    /** Deletes a comment. */
    commentDelete: ArchivePayload;
    /** Updates a comment. */
    commentUpdate: CommentPayload;
    /** Saves user message. */
    contactCreate: ContactPayload;
    /** Create CSV export report for the organization. */
    createCsvExportReport: CreateCsvExportReportPayload;
    /** Creates an organization from onboarding. */
    createOrganizationFromOnboarding: CreateOrJoinOrganizationResponse;
    /** Creates a new custom view. */
    customViewCreate: CustomViewPayload;
    /** Deletes a custom view. */
    customViewDelete: ArchivePayload;
    /** Updates a custom view. */
    customViewUpdate: CustomViewPayload;
    /** Archives a cycle. */
    cycleArchive: ArchivePayload;
    /** Creates a new cycle. */
    cycleCreate: CyclePayload;
    /** Updates a cycle. */
    cycleUpdate: CyclePayload;
    /** [Internal] Create the OAuth test applications in development. */
    debugCreateOAuthApps: DebugPayload;
    /** [Internal] Create the SAML test organization in development. */
    debugCreateSAMLOrg: DebugPayload;
    /** [Internal] Create test subscription in development. */
    debugCreateSubscription: DebugPayload;
    /** Always fails with internal error. Used to debug logging. */
    debugFailWithInternalError: DebugPayload;
    /** [Internal] Always logs an error to Sentry as warning. Used to debug logging. */
    debugFailWithWarning: DebugPayload;
    /** Creates a new document. */
    documentCreate: DocumentPayload;
    /** Deletes a document. */
    documentDelete: ArchivePayload;
    /** Updates a document. */
    documentUpdate: DocumentPayload;
    /** Subscribes the email to the newsletter. */
    emailSubscribe: EmailSubscribePayload;
    /** Authenticates a user account via email and authentication token. */
    emailTokenUserAccountAuth: AuthResolverResponse;
    /** Unsubscribes the user from one type of emails. */
    emailUnsubscribe: EmailUnsubscribePayload;
    /** Finds or creates a new user account by email and sends an email with token. */
    emailUserAccountAuthChallenge: EmailUserAccountAuthChallengeResponse;
    /** Creates a custom emoji. */
    emojiCreate: EmojiPayload;
    /** Deletes an emoji. */
    emojiDelete: ArchivePayload;
    /** [Deprecated] Creates a new event. */
    eventCreate: EventPayload;
    /** Creates a new favorite (project, cycle etc). */
    favoriteCreate: FavoritePayload;
    /** Deletes a favorite reference. */
    favoriteDelete: ArchivePayload;
    /** Updates a favorite. */
    favoriteUpdate: FavoritePayload;
    /** Saves user feedback. */
    feedbackCreate: FeedbackPayload;
    /** XHR request payload to upload an images, video and other attachments directly to Linear's cloud storage. */
    fileUpload: UploadPayload;
    /** Authenticate user account through Google OAuth. This is the 2nd step of OAuth flow. */
    googleUserAccountAuth: AuthResolverResponse;
    /** Upload an image from an URL to Linear. */
    imageUploadFromUrl: ImageUploadFromUrlPayload;
    /** Deletes an integration. */
    integrationDelete: ArchivePayload;
    /** Integrates the organization with Figma. */
    integrationFigma: IntegrationPayload;
    /** Integrates the organization with Front. */
    integrationFront: IntegrationPayload;
    /** Generates a webhook for the GitHub commit integration. */
    integrationGithubCommitCreate: GitHubCommitIntegrationPayload;
    /** Connects the organization with the GitHub App. */
    integrationGithubConnect: IntegrationPayload;
    /** Connects the organization with a GitLab Access Token. */
    integrationGitlabConnect: IntegrationPayload;
    /** Integrates the organization with Google Sheets. */
    integrationGoogleSheets: IntegrationPayload;
    /** Integrates the organization with Intercom. */
    integrationIntercom: IntegrationPayload;
    /** Disconnects the organization from Intercom. */
    integrationIntercomDelete: IntegrationPayload;
    /**
     * [DEPRECATED] Updates settings on the Intercom integration.
     * @deprecated This mutation is deprecated, please use `integrationSettingsUpdate` instead
     */
    integrationIntercomSettingsUpdate: IntegrationPayload;
    /** Enables Loom integration for the organization. */
    integrationLoom: IntegrationPayload;
    /** Archives an integration resource. */
    integrationResourceArchive: ArchivePayload;
    /** Integrates the organization with Sentry. */
    integrationSentryConnect: IntegrationPayload;
    /** [INTERNAL] Updates the integration. */
    integrationSettingsUpdate: IntegrationPayload;
    /** Integrates the organization with Slack. */
    integrationSlack: IntegrationPayload;
    /** Imports custom emojis from your Slack workspace. */
    integrationSlackImportEmojis: IntegrationPayload;
    /** Integrates your personal notifications with Slack. */
    integrationSlackPersonal: IntegrationPayload;
    /** Slack webhook integration. */
    integrationSlackPost: IntegrationPayload;
    /** Slack integration for project notifications. */
    integrationSlackProjectPost: IntegrationPayload;
    /** Integrates the organization with Zendesk. */
    integrationZendesk: IntegrationPayload;
    /** Archives an issue. */
    issueArchive: ArchivePayload;
    /** Updates multiple issues at once. */
    issueBatchUpdate: IssueBatchPayload;
    /** Creates a new issue. */
    issueCreate: IssuePayload;
    /** Deletes (trashes) an issue. */
    issueDelete: ArchivePayload;
    /** Kicks off an Asana import job. */
    issueImportCreateAsana: IssueImportPayload;
    /** Kicks off a Clubhouse import job. */
    issueImportCreateClubhouse: IssueImportPayload;
    /** Kicks off a GitHub import job. */
    issueImportCreateGithub: IssueImportPayload;
    /** Kicks off a Jira import job. */
    issueImportCreateJira: IssueImportPayload;
    /** Deletes an import job. */
    issueImportDelete: IssueImportDeletePayload;
    /** Kicks off import processing. */
    issueImportProcess: IssueImportPayload;
    /** Updates the mapping for the issue import. */
    issueImportUpdate: IssueImportPayload;
    /** Archives an issue label. */
    issueLabelArchive: ArchivePayload;
    /** Creates a new label. */
    issueLabelCreate: IssueLabelPayload;
    /** Updates an label. */
    issueLabelUpdate: IssueLabelPayload;
    /** Creates a new issue relation. */
    issueRelationCreate: IssueRelationPayload;
    /** Deletes an issue relation. */
    issueRelationDelete: ArchivePayload;
    /** Updates an issue relation. */
    issueRelationUpdate: IssueRelationPayload;
    /** Unarchives an issue. */
    issueUnarchive: ArchivePayload;
    /** Updates an issue. */
    issueUpdate: IssuePayload;
    /** [INTERNAL] Connects the organization with a Jira Personal Access Token. */
    jiraIntegrationConnect: IntegrationPayload;
    /** Join an organization from onboarding. */
    joinOrganizationFromOnboarding: CreateOrJoinOrganizationResponse;
    /** Leave an organization. */
    leaveOrganization: CreateOrJoinOrganizationResponse;
    /** Creates a new milestone. */
    milestoneCreate: MilestonePayload;
    /** Deletes a milestone. */
    milestoneDelete: ArchivePayload;
    /** Updates a milestone. */
    milestoneUpdate: MilestonePayload;
    /** Archives a notification. */
    notificationArchive: ArchivePayload;
    /** Creates a notification. */
    notificationCreate: NotificationPayload;
    /** Creates a new notification subscription for a team or a project. */
    notificationSubscriptionCreate: NotificationSubscriptionPayload;
    /** Deletes a notification subscription reference. */
    notificationSubscriptionDelete: ArchivePayload;
    /** Unarchives a notification. */
    notificationUnarchive: ArchivePayload;
    /** Updates a notification. */
    notificationUpdate: NotificationPayload;
    /** [Internal] Authenticates an auth string by the user. */
    oauthAuthStringAuthorize: OauthAuthStringAuthorizePayload;
    /** [Internal] Creates a temporary authentication code that can be exchanged for an OAuth token. */
    oauthAuthStringChallenge: OauthAuthStringChallengePayload;
    /** [Internal] Returns an access token once the auth string has been authenticated. */
    oauthAuthStringCheck: OauthAuthStringCheckPayload;
    /** Archives an OAuth client. */
    oauthClientArchive: ArchivePayload;
    /** Creates a new OAuth client. */
    oauthClientCreate: OauthClientPayload;
    /** Updates an OAuth client. */
    oauthClientRotateSecret: RotateSecretPayload;
    /** Updates an OAuth client. */
    oauthClientUpdate: OauthClientPayload;
    /** Revokes an OAuth token. */
    oauthTokenRevoke: OauthTokenRevokePayload;
    /** Cancels the deletion of an organization. Administrator privileges required. */
    organizationCancelDelete: OrganizationCancelDeletePayload;
    /** Delete's an organization. Administrator privileges required. */
    organizationDelete: OrganizationDeletePayload;
    /** Get an organization's delete confirmation token. Administrator privileges required. */
    organizationDeleteChallenge: OrganizationDeletePayload;
    /** Adds a domain to be allowed for an organization. */
    organizationDomainCreate: OrganizationDomainPayload;
    /** Deletes a domain. */
    organizationDomainDelete: ArchivePayload;
    /** Verifies a domain to be added to an organization. */
    organizationDomainVerify: OrganizationDomainPayload;
    /** Creates a new organization invite. */
    organizationInviteCreate: OrganizationInvitePayload;
    /** Deletes an organization invite. */
    organizationInviteDelete: ArchivePayload;
    /** Updates the user's organization. */
    organizationUpdate: OrganizationPayload;
    /** Archives a project. */
    projectArchive: ArchivePayload;
    /** Creates a new project. */
    projectCreate: ProjectPayload;
    /** Creates a new project link. */
    projectLinkCreate: ProjectLinkPayload;
    /** Deletes a project link. */
    projectLinkDelete: ArchivePayload;
    /** Updates a project link. */
    projectLinkUpdate: ProjectLinkPayload;
    /** Unarchives a project. */
    projectUnarchive: ArchivePayload;
    /** Updates a project. */
    projectUpdate: ProjectPayload;
    /** Creates a push subscription. */
    pushSubscriptionCreate: PushSubscriptionPayload;
    /** Deletes a push subscription. */
    pushSubscriptionDelete: PushSubscriptionPayload;
    /** Creates a new reaction. */
    reactionCreate: ReactionPayload;
    /** Deletes a reaction. */
    reactionDelete: ArchivePayload;
    /** Manually update Google Sheets data. */
    refreshGoogleSheetsData: IntegrationPayload;
    /** Re-send an organization invite. */
    resendOrganizationInvite: ArchivePayload;
    /** Authenticates a user account via email and authentication token for SAML. */
    samlTokenUserAccountAuth: AuthResolverResponse;
    /** [Internal] Archives a subscription. */
    subscriptionArchive: ArchivePayload;
    /** [Internal] Creates a subscription session. Used internally to integrate with Stripe. */
    subscriptionSessionCreate: SubscriptionSessionPayload;
    /** [Internal] Updates a subscription. */
    subscriptionUpdate: SubscriptionPayload;
    /** [Internal] Creates a subscription update session. Used internally to integrate with Stripe. */
    subscriptionUpdateSessionCreate: SubscriptionSessionPayload;
    /** [Internal] Upgrades a subscription plan. */
    subscriptionUpgrade: SubscriptionPayload;
    /** Creates a new team. The user who creates the team will automatically be added as a member to the newly created team. */
    teamCreate: TeamPayload;
    /** Deletes a team. */
    teamDelete: ArchivePayload;
    /** Deletes a previously used team key. */
    teamKeyDelete: ArchivePayload;
    /** Creates a new team membership. */
    teamMembershipCreate: TeamMembershipPayload;
    /** Deletes a team membership. */
    teamMembershipDelete: ArchivePayload;
    /** Updates a team membership. */
    teamMembershipUpdate: TeamMembershipPayload;
    /** Updates a team. */
    teamUpdate: TeamPayload;
    /** Creates a new template. */
    templateCreate: TemplatePayload;
    /** Deletes a template. */
    templateDelete: ArchivePayload;
    /** Updates an existing template. */
    templateUpdate: TemplatePayload;
    /** Makes user a regular user. Can only be called by an admin. */
    userDemoteAdmin: UserAdminPayload;
    /** Updates a user's settings flag. */
    userFlagUpdate: UserSettingsFlagPayload;
    /** Makes user an admin. Can only be called by an admin. */
    userPromoteAdmin: UserAdminPayload;
    /** [Deprecated] Updates a user's settings flag. */
    userSettingsFlagIncrement: UserSettingsFlagPayload;
    /** Resets user's setting flags. */
    userSettingsFlagsReset: UserSettingsFlagsResetPayload;
    /** Updates the user's settings. */
    userSettingsUpdate: UserSettingsPayload;
    /** Subscribes user to changelog newsletter. */
    userSubscribeToNewsletter: UserSubscribeToNewsletterPayload;
    /** Suspends a user. Can only be called by an admin. */
    userSuspend: UserAdminPayload;
    /** Un-suspends a user. Can only be called by an admin. */
    userUnsuspend: UserAdminPayload;
    /** Updates a user. Only available to organization admins and the user themselves. */
    userUpdate: UserPayload;
    /** Creates a new ViewPreferences object. */
    viewPreferencesCreate: ViewPreferencesPayload;
    /** Deletes a ViewPreferences. */
    viewPreferencesDelete: ArchivePayload;
    /** Updates an existing ViewPreferences object. */
    viewPreferencesUpdate: ViewPreferencesPayload;
    /** Creates a new webhook. */
    webhookCreate: WebhookPayload;
    /** Deletes a Webhook. */
    webhookDelete: ArchivePayload;
    /** Updates an existing Webhook. */
    webhookUpdate: WebhookPayload;
    /** Archives a state. Only states with issues that have all been archived can be archived. */
    workflowStateArchive: ArchivePayload;
    /** Creates a new state, adding it to the workflow of a team. */
    workflowStateCreate: WorkflowStatePayload;
    /** Updates a state. */
    workflowStateUpdate: WorkflowStatePayload;
};
export declare type MutationApiKeyCreateArgs = {
    input: ApiKeyCreateInput;
};
export declare type MutationApiKeyDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationAttachmentArchiveArgs = {
    id: Scalars["String"];
};
export declare type MutationAttachmentCreateArgs = {
    input: AttachmentCreateInput;
};
export declare type MutationAttachmentDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationAttachmentLinkFrontArgs = {
    conversationId: Scalars["String"];
    issueId: Scalars["String"];
};
export declare type MutationAttachmentLinkIntercomArgs = {
    conversationId: Scalars["String"];
    issueId: Scalars["String"];
};
export declare type MutationAttachmentLinkJiraIssueArgs = {
    issueId: Scalars["String"];
    jiraIssueId: Scalars["String"];
};
export declare type MutationAttachmentLinkUrlArgs = {
    issueId: Scalars["String"];
    title?: Maybe<Scalars["String"]>;
    url: Scalars["String"];
};
export declare type MutationAttachmentLinkZendeskArgs = {
    issueId: Scalars["String"];
    ticketId: Scalars["String"];
};
export declare type MutationAttachmentUpdateArgs = {
    id: Scalars["String"];
    input: AttachmentUpdateInput;
};
export declare type MutationBillingEmailUpdateArgs = {
    input: BillingEmailUpdateInput;
};
export declare type MutationCollaborativeDocumentUpdateArgs = {
    input: CollaborationDocumentUpdateInput;
};
export declare type MutationCommentCreateArgs = {
    input: CommentCreateInput;
};
export declare type MutationCommentDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationCommentUpdateArgs = {
    id: Scalars["String"];
    input: CommentUpdateInput;
};
export declare type MutationContactCreateArgs = {
    input: ContactCreateInput;
};
export declare type MutationCreateCsvExportReportArgs = {
    includePrivateTeamIds?: Maybe<Array<Scalars["String"]>>;
};
export declare type MutationCreateOrganizationFromOnboardingArgs = {
    input: CreateOrganizationInput;
    survey?: Maybe<OnboardingCustomerSurvey>;
};
export declare type MutationCustomViewCreateArgs = {
    input: CustomViewCreateInput;
};
export declare type MutationCustomViewDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationCustomViewUpdateArgs = {
    id: Scalars["String"];
    input: CustomViewUpdateInput;
};
export declare type MutationCycleArchiveArgs = {
    id: Scalars["String"];
};
export declare type MutationCycleCreateArgs = {
    input: CycleCreateInput;
};
export declare type MutationCycleUpdateArgs = {
    id: Scalars["String"];
    input: CycleUpdateInput;
};
export declare type MutationDebugCreateSubscriptionArgs = {
    subscriptionType: Scalars["String"];
};
export declare type MutationDocumentCreateArgs = {
    input: DocumentCreateInput;
};
export declare type MutationDocumentDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationDocumentUpdateArgs = {
    id: Scalars["String"];
    input: DocumentUpdateInput;
};
export declare type MutationEmailSubscribeArgs = {
    input: EmailSubscribeInput;
};
export declare type MutationEmailTokenUserAccountAuthArgs = {
    input: TokenUserAccountAuthInput;
};
export declare type MutationEmailUnsubscribeArgs = {
    input: EmailUnsubscribeInput;
};
export declare type MutationEmailUserAccountAuthChallengeArgs = {
    input: EmailUserAccountAuthChallengeInput;
};
export declare type MutationEmojiCreateArgs = {
    input: EmojiCreateInput;
};
export declare type MutationEmojiDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationEventCreateArgs = {
    input: EventCreateInput;
};
export declare type MutationFavoriteCreateArgs = {
    input: FavoriteCreateInput;
};
export declare type MutationFavoriteDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationFavoriteUpdateArgs = {
    id: Scalars["String"];
    input: FavoriteUpdateInput;
};
export declare type MutationFeedbackCreateArgs = {
    input: FeedbackCreateInput;
};
export declare type MutationFileUploadArgs = {
    contentType: Scalars["String"];
    filename: Scalars["String"];
    metaData?: Maybe<Scalars["JSON"]>;
    size: Scalars["Int"];
};
export declare type MutationGoogleUserAccountAuthArgs = {
    input: GoogleUserAccountAuthInput;
};
export declare type MutationImageUploadFromUrlArgs = {
    url: Scalars["String"];
};
export declare type MutationIntegrationDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationIntegrationFigmaArgs = {
    code: Scalars["String"];
    redirectUri: Scalars["String"];
};
export declare type MutationIntegrationFrontArgs = {
    code: Scalars["String"];
    redirectUri: Scalars["String"];
};
export declare type MutationIntegrationGithubConnectArgs = {
    installationId: Scalars["String"];
};
export declare type MutationIntegrationGitlabConnectArgs = {
    accessToken: Scalars["String"];
    gitlabUrl: Scalars["String"];
};
export declare type MutationIntegrationGoogleSheetsArgs = {
    code: Scalars["String"];
};
export declare type MutationIntegrationIntercomArgs = {
    code: Scalars["String"];
    redirectUri: Scalars["String"];
};
export declare type MutationIntegrationIntercomSettingsUpdateArgs = {
    input: IntercomSettingsInput;
};
export declare type MutationIntegrationResourceArchiveArgs = {
    id: Scalars["String"];
};
export declare type MutationIntegrationSentryConnectArgs = {
    code: Scalars["String"];
    installationId: Scalars["String"];
    organizationSlug: Scalars["String"];
};
export declare type MutationIntegrationSettingsUpdateArgs = {
    id: Scalars["String"];
    input: IntegrationSettingsInput;
};
export declare type MutationIntegrationSlackArgs = {
    code: Scalars["String"];
    redirectUri: Scalars["String"];
    shouldUseV2Auth?: Maybe<Scalars["Boolean"]>;
};
export declare type MutationIntegrationSlackImportEmojisArgs = {
    code: Scalars["String"];
    redirectUri: Scalars["String"];
};
export declare type MutationIntegrationSlackPersonalArgs = {
    code: Scalars["String"];
    redirectUri: Scalars["String"];
};
export declare type MutationIntegrationSlackPostArgs = {
    code: Scalars["String"];
    redirectUri: Scalars["String"];
    shouldUseV2Auth?: Maybe<Scalars["Boolean"]>;
    teamId: Scalars["String"];
};
export declare type MutationIntegrationSlackProjectPostArgs = {
    code: Scalars["String"];
    projectId: Scalars["String"];
    redirectUri: Scalars["String"];
};
export declare type MutationIntegrationZendeskArgs = {
    code: Scalars["String"];
    redirectUri: Scalars["String"];
    scope: Scalars["String"];
    subdomain: Scalars["String"];
};
export declare type MutationIssueArchiveArgs = {
    id: Scalars["String"];
    trash?: Maybe<Scalars["Boolean"]>;
};
export declare type MutationIssueBatchUpdateArgs = {
    ids: Array<Scalars["UUID"]>;
    input: IssueUpdateInput;
};
export declare type MutationIssueCreateArgs = {
    input: IssueCreateInput;
};
export declare type MutationIssueDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationIssueImportCreateAsanaArgs = {
    asanaTeamName: Scalars["String"];
    asanaToken: Scalars["String"];
    id?: Maybe<Scalars["String"]>;
    includeClosedIssues?: Maybe<Scalars["Boolean"]>;
    instantProcess?: Maybe<Scalars["Boolean"]>;
    teamId: Scalars["String"];
};
export declare type MutationIssueImportCreateClubhouseArgs = {
    clubhouseTeamName: Scalars["String"];
    clubhouseToken: Scalars["String"];
    id?: Maybe<Scalars["String"]>;
    includeClosedIssues?: Maybe<Scalars["Boolean"]>;
    instantProcess?: Maybe<Scalars["Boolean"]>;
    teamId: Scalars["String"];
};
export declare type MutationIssueImportCreateGithubArgs = {
    githubRepoName: Scalars["String"];
    githubRepoOwner: Scalars["String"];
    githubShouldImportOrgProjects?: Maybe<Scalars["Boolean"]>;
    githubToken: Scalars["String"];
    id?: Maybe<Scalars["String"]>;
    includeClosedIssues?: Maybe<Scalars["Boolean"]>;
    instantProcess?: Maybe<Scalars["Boolean"]>;
    teamId: Scalars["String"];
};
export declare type MutationIssueImportCreateJiraArgs = {
    id?: Maybe<Scalars["String"]>;
    includeClosedIssues?: Maybe<Scalars["Boolean"]>;
    instantProcess?: Maybe<Scalars["Boolean"]>;
    jiraEmail: Scalars["String"];
    jiraHostname: Scalars["String"];
    jiraProject: Scalars["String"];
    jiraToken: Scalars["String"];
    teamId: Scalars["String"];
};
export declare type MutationIssueImportDeleteArgs = {
    issueImportId: Scalars["String"];
};
export declare type MutationIssueImportProcessArgs = {
    issueImportId: Scalars["String"];
    mapping: Scalars["JSONObject"];
};
export declare type MutationIssueImportUpdateArgs = {
    id: Scalars["String"];
    input: IssueImportUpdateInput;
};
export declare type MutationIssueLabelArchiveArgs = {
    id: Scalars["String"];
};
export declare type MutationIssueLabelCreateArgs = {
    input: IssueLabelCreateInput;
    replaceTeamLabels?: Maybe<Scalars["Boolean"]>;
};
export declare type MutationIssueLabelUpdateArgs = {
    id: Scalars["String"];
    input: IssueLabelUpdateInput;
};
export declare type MutationIssueRelationCreateArgs = {
    input: IssueRelationCreateInput;
};
export declare type MutationIssueRelationDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationIssueRelationUpdateArgs = {
    id: Scalars["String"];
    input: IssueRelationUpdateInput;
};
export declare type MutationIssueUnarchiveArgs = {
    id: Scalars["String"];
};
export declare type MutationIssueUpdateArgs = {
    id: Scalars["String"];
    input: IssueUpdateInput;
};
export declare type MutationJiraIntegrationConnectArgs = {
    input: JiraConfigurationInput;
};
export declare type MutationJoinOrganizationFromOnboardingArgs = {
    input: JoinOrganizationInput;
};
export declare type MutationLeaveOrganizationArgs = {
    organizationId: Scalars["String"];
};
export declare type MutationMilestoneCreateArgs = {
    input: MilestoneCreateInput;
};
export declare type MutationMilestoneDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationMilestoneUpdateArgs = {
    id: Scalars["String"];
    input: MilestoneUpdateInput;
};
export declare type MutationNotificationArchiveArgs = {
    id: Scalars["String"];
};
export declare type MutationNotificationCreateArgs = {
    id: Scalars["String"];
    input: NotificationUpdateInput;
};
export declare type MutationNotificationSubscriptionCreateArgs = {
    input: NotificationSubscriptionCreateInput;
};
export declare type MutationNotificationSubscriptionDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationNotificationUnarchiveArgs = {
    id: Scalars["String"];
};
export declare type MutationNotificationUpdateArgs = {
    id: Scalars["String"];
    input: NotificationUpdateInput;
};
export declare type MutationOauthAuthStringAuthorizeArgs = {
    appId: Scalars["String"];
    authString: Scalars["String"];
};
export declare type MutationOauthAuthStringChallengeArgs = {
    appId: Scalars["String"];
    scope: Array<Scalars["String"]>;
};
export declare type MutationOauthAuthStringCheckArgs = {
    appId: Scalars["String"];
    authString: Scalars["String"];
};
export declare type MutationOauthClientArchiveArgs = {
    id: Scalars["String"];
};
export declare type MutationOauthClientCreateArgs = {
    input: OauthClientCreateInput;
};
export declare type MutationOauthClientRotateSecretArgs = {
    id: Scalars["String"];
};
export declare type MutationOauthClientUpdateArgs = {
    id: Scalars["String"];
    input: OauthClientUpdateInput;
};
export declare type MutationOauthTokenRevokeArgs = {
    appId: Scalars["String"];
    scope: Array<Scalars["String"]>;
};
export declare type MutationOrganizationDeleteArgs = {
    input: DeleteOrganizationInput;
};
export declare type MutationOrganizationDomainCreateArgs = {
    input: OrganizationDomainCreateInput;
};
export declare type MutationOrganizationDomainDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationOrganizationDomainVerifyArgs = {
    input: OrganizationDomainVerificationInput;
};
export declare type MutationOrganizationInviteCreateArgs = {
    input: OrganizationInviteCreateInput;
};
export declare type MutationOrganizationInviteDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationOrganizationUpdateArgs = {
    input: UpdateOrganizationInput;
};
export declare type MutationProjectArchiveArgs = {
    id: Scalars["String"];
};
export declare type MutationProjectCreateArgs = {
    input: ProjectCreateInput;
};
export declare type MutationProjectLinkCreateArgs = {
    input: ProjectLinkCreateInput;
};
export declare type MutationProjectLinkDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationProjectLinkUpdateArgs = {
    id: Scalars["String"];
    input: ProjectLinkUpdateInput;
};
export declare type MutationProjectUnarchiveArgs = {
    id: Scalars["String"];
};
export declare type MutationProjectUpdateArgs = {
    id: Scalars["String"];
    input: ProjectUpdateInput;
};
export declare type MutationPushSubscriptionCreateArgs = {
    input: PushSubscriptionCreateInput;
};
export declare type MutationPushSubscriptionDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationReactionCreateArgs = {
    input: ReactionCreateInput;
};
export declare type MutationReactionDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationRefreshGoogleSheetsDataArgs = {
    id: Scalars["String"];
};
export declare type MutationResendOrganizationInviteArgs = {
    id: Scalars["String"];
};
export declare type MutationSamlTokenUserAccountAuthArgs = {
    input: TokenUserAccountAuthInput;
};
export declare type MutationSubscriptionArchiveArgs = {
    id: Scalars["String"];
};
export declare type MutationSubscriptionSessionCreateArgs = {
    coupon?: Maybe<Scalars["String"]>;
    plan: Scalars["String"];
};
export declare type MutationSubscriptionUpdateArgs = {
    id: Scalars["String"];
    input: SubscriptionUpdateInput;
};
export declare type MutationSubscriptionUpgradeArgs = {
    id: Scalars["String"];
    type: Scalars["String"];
};
export declare type MutationTeamCreateArgs = {
    copySettingsFromTeamId?: Maybe<Scalars["String"]>;
    input: TeamCreateInput;
};
export declare type MutationTeamDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationTeamKeyDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationTeamMembershipCreateArgs = {
    input: TeamMembershipCreateInput;
};
export declare type MutationTeamMembershipDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationTeamMembershipUpdateArgs = {
    id: Scalars["String"];
    input: TeamMembershipUpdateInput;
};
export declare type MutationTeamUpdateArgs = {
    id: Scalars["String"];
    input: TeamUpdateInput;
};
export declare type MutationTemplateCreateArgs = {
    input: TemplateCreateInput;
};
export declare type MutationTemplateDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationTemplateUpdateArgs = {
    id: Scalars["String"];
    input: TemplateUpdateInput;
};
export declare type MutationUserDemoteAdminArgs = {
    id: Scalars["String"];
};
export declare type MutationUserFlagUpdateArgs = {
    flag: UserFlagType;
    operation: UserFlagUpdateOperation;
};
export declare type MutationUserPromoteAdminArgs = {
    id: Scalars["String"];
};
export declare type MutationUserSettingsFlagIncrementArgs = {
    flag: Scalars["String"];
};
export declare type MutationUserSettingsUpdateArgs = {
    id: Scalars["String"];
    input: UserSettingsUpdateInput;
};
export declare type MutationUserSuspendArgs = {
    id: Scalars["String"];
};
export declare type MutationUserUnsuspendArgs = {
    id: Scalars["String"];
};
export declare type MutationUserUpdateArgs = {
    id: Scalars["String"];
    input: UpdateUserInput;
};
export declare type MutationViewPreferencesCreateArgs = {
    input: ViewPreferencesCreateInput;
};
export declare type MutationViewPreferencesDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationViewPreferencesUpdateArgs = {
    id: Scalars["String"];
    input: ViewPreferencesUpdateInput;
};
export declare type MutationWebhookCreateArgs = {
    input: WebhookCreateInput;
};
export declare type MutationWebhookDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationWebhookUpdateArgs = {
    id: Scalars["String"];
    input: WebhookUpdateInput;
};
export declare type MutationWorkflowStateArchiveArgs = {
    id: Scalars["String"];
};
export declare type MutationWorkflowStateCreateArgs = {
    input: WorkflowStateCreateInput;
};
export declare type MutationWorkflowStateUpdateArgs = {
    id: Scalars["String"];
    input: WorkflowStateUpdateInput;
};
/** Comparator for strings. */
export declare type NestedStringComparator = {
    /** Contains constraint. Matches any values that contain the given string. */
    contains?: Maybe<Scalars["String"]>;
    /** Contains case insensitive constraint. Matches any values that contain the given string case insensitive. */
    containsIgnoreCase?: Maybe<Scalars["String"]>;
    /** Ends with constraint. Matches any values that end with the given string. */
    endsWith?: Maybe<Scalars["String"]>;
    /** Equals constraint. */
    eq?: Maybe<Scalars["String"]>;
    /** Equals case insensitive. Matches any values that matches the given string case insensitive. */
    eqIgnoreCase?: Maybe<Scalars["String"]>;
    /** In-array constraint. */
    in?: Maybe<Array<Scalars["String"]>>;
    /** Not-equals constraint. */
    neq?: Maybe<Scalars["String"]>;
    /** Not-equals case insensitive. Matches any values that don't match the given string case insensitive. */
    neqIgnoreCase?: Maybe<Scalars["String"]>;
    /** Not-in-array constraint. */
    nin?: Maybe<Array<Scalars["String"]>>;
    /** Doesn't contain constraint. Matches any values that don't contain the given string. */
    notContains?: Maybe<Scalars["String"]>;
    /** Doesn't contain case insensitive constraint. Matches any values that don't contain the given string case insensitive. */
    notContainsIgnoreCase?: Maybe<Scalars["String"]>;
    /** Doesn't end with constraint. Matches any values that don't end with the given string. */
    notEndsWith?: Maybe<Scalars["String"]>;
    /** Doesn't start with constraint. Matches any values that don't start with the given string. */
    notStartsWith?: Maybe<Scalars["String"]>;
    /** Starts with constraint. Matches any values that start with the given string. */
    startsWith?: Maybe<Scalars["String"]>;
};
export declare type Node = {
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
};
/** A notification sent to a user. */
export declare type Notification = Node & {
    __typename?: "Notification";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The comment which the notification is associated with. */
    comment?: Maybe<Comment>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /**
     * The time at when an email reminder for this notification was sent to the user. Null, if no email
     *     reminder has been sent.
     */
    emailedAt?: Maybe<Scalars["DateTime"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The issue that the notification is associated with. */
    issue: Issue;
    /** Name of the reaction emoji associated with the notification. */
    reactionEmoji?: Maybe<Scalars["String"]>;
    /** The time at when the user marked the notification as read. Null, if the the user hasn't read the notification */
    readAt?: Maybe<Scalars["DateTime"]>;
    /** The time until a notification will be snoozed. After that it will appear in the inbox again. */
    snoozedUntilAt?: Maybe<Scalars["DateTime"]>;
    /** The team which the notification is associated with. */
    team: Team;
    /** Notification type */
    type: Scalars["String"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The recipient of the notification. */
    user: User;
};
export declare type NotificationConnection = {
    __typename?: "NotificationConnection";
    edges: Array<NotificationEdge>;
    nodes: Array<Notification>;
    pageInfo: PageInfo;
};
export declare type NotificationEdge = {
    __typename?: "NotificationEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Notification;
};
export declare type NotificationPayload = {
    __typename?: "NotificationPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** The notification that was created or updated. */
    notification: Notification;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** Notification subscriptions for models. */
export declare type NotificationSubscription = Node & {
    __typename?: "NotificationSubscription";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Subscribed project. */
    project?: Maybe<Project>;
    /** Subscribed team. */
    team?: Maybe<Team>;
    /** The type of the subscription. */
    type: Scalars["String"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The user associated with notification subscriptions. */
    user: User;
};
export declare type NotificationSubscriptionConnection = {
    __typename?: "NotificationSubscriptionConnection";
    edges: Array<NotificationSubscriptionEdge>;
    nodes: Array<NotificationSubscription>;
    pageInfo: PageInfo;
};
export declare type NotificationSubscriptionCreateInput = {
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The identifier of the project to subscribe to. */
    projectId?: Maybe<Scalars["String"]>;
    /** The identifier of the team to subscribe to. */
    teamId?: Maybe<Scalars["String"]>;
};
export declare type NotificationSubscriptionEdge = {
    __typename?: "NotificationSubscriptionEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: NotificationSubscription;
};
export declare type NotificationSubscriptionPayload = {
    __typename?: "NotificationSubscriptionPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** The notification subscription that was created or updated. */
    notificationSubscription: NotificationSubscription;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type NotificationUpdateInput = {
    /** The time when notification was marked as read. */
    readAt?: Maybe<Scalars["DateTime"]>;
    /** The time until a notification will be snoozed. After that it will appear in the inbox again. */
    snoozedUntilAt?: Maybe<Scalars["DateTime"]>;
};
/** [Alpha] Cycle filtering options. */
export declare type NullableCycleFilter = {
    /** Compound filters, all of which need to be matched by the cycle. */
    and?: Maybe<Array<CycleFilter>>;
    /** Comparator for the cycle completed at date. */
    completedAt?: Maybe<DateComparator>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Comparator for the cycle ends at date. */
    endsAt?: Maybe<DateComparator>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Filters that the cycles issues must satisfy. */
    issues?: Maybe<IssueCollectionFilter>;
    /** Comparator for the cycle name. */
    name?: Maybe<StringComparator>;
    /** Filter based on the existence of the relation. */
    null?: Maybe<Scalars["Boolean"]>;
    /** Comparator for the cycle number. */
    number?: Maybe<NumberComparator>;
    /** Compound filters, one of which need to be matched by the cycle. */
    or?: Maybe<Array<CycleFilter>>;
    /** Comparator for the cycle start date. */
    startsAt?: Maybe<DateComparator>;
    /** Filters that the cycles team must satisfy. */
    team?: Maybe<TeamFilter>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
/** Comparator for optional dates. */
export declare type NullableDateComparator = {
    /** Equals constraint. */
    eq?: Maybe<Scalars["DateTime"]>;
    /** Greater-than constraint. Matches any values that are greater than the given value. */
    gt?: Maybe<Scalars["DateTime"]>;
    /** Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value. */
    gte?: Maybe<Scalars["DateTime"]>;
    /** In-array constraint. */
    in?: Maybe<Array<Scalars["DateTime"]>>;
    /** Less-than constraint. Matches any values that are less than the given value. */
    lt?: Maybe<Scalars["DateTime"]>;
    /** Less-than-or-equal constraint. Matches any values that are less than or equal to the given value. */
    lte?: Maybe<Scalars["DateTime"]>;
    /** Not-equals constraint. */
    neq?: Maybe<Scalars["DateTime"]>;
    /** Not-in-array constraint. */
    nin?: Maybe<Array<Scalars["DateTime"]>>;
    /** Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values. */
    null?: Maybe<Scalars["Boolean"]>;
};
/** [Alpha] User filtering options. */
export declare type NullableMilestoneFilter = {
    /** Compound filters, all of which need to be matched by the milestone. */
    and?: Maybe<Array<MilestoneFilter>>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Comparator for the milestone name. */
    name?: Maybe<StringComparator>;
    /** Filter based on the existence of the relation. */
    null?: Maybe<Scalars["Boolean"]>;
    /** Compound filters, one of which need to be matched by the milestone. */
    or?: Maybe<Array<MilestoneFilter>>;
    /** Filters that the milestones projects must satisfy. */
    projects?: Maybe<ProjectCollectionFilter>;
    /** Comparator for the milestone sort order. */
    sortOrder?: Maybe<NumberComparator>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
/** Comparator for optional numbers. */
export declare type NullableNumberComparator = {
    /** Equals constraint. */
    eq?: Maybe<Scalars["Float"]>;
    /** Greater-than constraint. Matches any values that are greater than the given value. */
    gt?: Maybe<Scalars["Float"]>;
    /** Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value. */
    gte?: Maybe<Scalars["Float"]>;
    /** In-array constraint. */
    in?: Maybe<Array<Scalars["Float"]>>;
    /** Less-than constraint. Matches any values that are less than the given value. */
    lt?: Maybe<Scalars["Float"]>;
    /** Less-than-or-equal constraint. Matches any values that are less than or equal to the given value. */
    lte?: Maybe<Scalars["Float"]>;
    /** Not-equals constraint. */
    neq?: Maybe<Scalars["Float"]>;
    /** Not-in-array constraint. */
    nin?: Maybe<Array<Scalars["Float"]>>;
    /** Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values. */
    null?: Maybe<Scalars["Boolean"]>;
};
/** [Alpha] Project filtering options. */
export declare type NullableProjectFilter = {
    /** Compound filters, all of which need to be matched by the project. */
    and?: Maybe<Array<ProjectFilter>>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Filters that the projects creator must satisfy. */
    creator?: Maybe<UserFilter>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Filters that the projects issues must satisfy. */
    issues?: Maybe<IssueCollectionFilter>;
    /** Filters that the projects lead must satisfy. */
    lead?: Maybe<NullableUserFilter>;
    /** Filters that the projects members must satisfy. */
    members?: Maybe<UserFilter>;
    /** Filters that the projects milestones must satisfy. */
    milestone?: Maybe<NullableMilestoneFilter>;
    /** Comparator for the project name. */
    name?: Maybe<StringComparator>;
    /** Filter based on the existence of the relation. */
    null?: Maybe<Scalars["Boolean"]>;
    /** Compound filters, one of which need to be matched by the project. */
    or?: Maybe<Array<ProjectFilter>>;
    /** Comparator for the project start date. */
    startDate?: Maybe<NullableDateComparator>;
    /** Comparator for the project state. */
    state?: Maybe<StringComparator>;
    /** Comparator for the project target date. */
    targetDate?: Maybe<NullableDateComparator>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
/** Comparator for optional strings. */
export declare type NullableStringComparator = {
    /** Contains constraint. Matches any values that contain the given string. */
    contains?: Maybe<Scalars["String"]>;
    /** Contains case insensitive constraint. Matches any values that contain the given string case insensitive. */
    containsIgnoreCase?: Maybe<Scalars["String"]>;
    /** Ends with constraint. Matches any values that end with the given string. */
    endsWith?: Maybe<Scalars["String"]>;
    /** Equals constraint. */
    eq?: Maybe<Scalars["String"]>;
    /** Equals case insensitive. Matches any values that matches the given string case insensitive. */
    eqIgnoreCase?: Maybe<Scalars["String"]>;
    /** In-array constraint. */
    in?: Maybe<Array<Scalars["String"]>>;
    /** Not-equals constraint. */
    neq?: Maybe<Scalars["String"]>;
    /** Not-equals case insensitive. Matches any values that don't match the given string case insensitive. */
    neqIgnoreCase?: Maybe<Scalars["String"]>;
    /** Not-in-array constraint. */
    nin?: Maybe<Array<Scalars["String"]>>;
    /** Doesn't contain constraint. Matches any values that don't contain the given string. */
    notContains?: Maybe<Scalars["String"]>;
    /** Doesn't contain case insensitive constraint. Matches any values that don't contain the given string case insensitive. */
    notContainsIgnoreCase?: Maybe<Scalars["String"]>;
    /** Doesn't end with constraint. Matches any values that don't end with the given string. */
    notEndsWith?: Maybe<Scalars["String"]>;
    /** Doesn't start with constraint. Matches any values that don't start with the given string. */
    notStartsWith?: Maybe<Scalars["String"]>;
    /** Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values. */
    null?: Maybe<Scalars["Boolean"]>;
    /** Starts with constraint. Matches any values that start with the given string. */
    startsWith?: Maybe<Scalars["String"]>;
};
export declare type NullableTimelessDateComparator = {
    /** Equals constraint. */
    eq?: Maybe<Scalars["TimelessDate"]>;
    /** Greater-than constraint. Matches any values that are greater than the given value. */
    gt?: Maybe<Scalars["TimelessDate"]>;
    /** Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value. */
    gte?: Maybe<Scalars["TimelessDate"]>;
    /** In-array constraint. */
    in?: Maybe<Array<Scalars["TimelessDate"]>>;
    /** Less-than constraint. Matches any values that are less than the given value. */
    lt?: Maybe<Scalars["TimelessDate"]>;
    /** Less-than-or-equal constraint. Matches any values that are less than or equal to the given value. */
    lte?: Maybe<Scalars["TimelessDate"]>;
    /** Not-equals constraint. */
    neq?: Maybe<Scalars["TimelessDate"]>;
    /** Not-in-array constraint. */
    nin?: Maybe<Array<Scalars["TimelessDate"]>>;
    /** Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values. */
    null?: Maybe<Scalars["Boolean"]>;
};
/** [Alpha] User filtering options. */
export declare type NullableUserFilter = {
    /** Compound filters, all of which need to be matched by the user. */
    and?: Maybe<Array<UserFilter>>;
    /** Filters that the users assigned issues must satisfy. */
    assignedIssues?: Maybe<IssueCollectionFilter>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Comparator for the users display name. */
    displayName?: Maybe<StringComparator>;
    /** Comparator for the users email. */
    email?: Maybe<StringComparator>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Filter based on the currently authenticated user. Set to true to filter for the authenticated user, false for any other user. */
    isMe?: Maybe<BooleanComparator>;
    /** Comparator for the users name. */
    name?: Maybe<StringComparator>;
    /** Filter based on the existence of the relation. */
    null?: Maybe<Scalars["Boolean"]>;
    /** Compound filters, one of which need to be matched by the user. */
    or?: Maybe<Array<UserFilter>>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
/** Comparator for numbers. */
export declare type NumberComparator = {
    /** Equals constraint. */
    eq?: Maybe<Scalars["Float"]>;
    /** Greater-than constraint. Matches any values that are greater than the given value. */
    gt?: Maybe<Scalars["Float"]>;
    /** Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value. */
    gte?: Maybe<Scalars["Float"]>;
    /** In-array constraint. */
    in?: Maybe<Array<Scalars["Float"]>>;
    /** Less-than constraint. Matches any values that are less than the given value. */
    lt?: Maybe<Scalars["Float"]>;
    /** Less-than-or-equal constraint. Matches any values that are less than or equal to the given value. */
    lte?: Maybe<Scalars["Float"]>;
    /** Not-equals constraint. */
    neq?: Maybe<Scalars["Float"]>;
    /** Not-in-array constraint. */
    nin?: Maybe<Array<Scalars["Float"]>>;
};
export declare type OauthAuthStringAuthorizePayload = {
    __typename?: "OauthAuthStringAuthorizePayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type OauthAuthStringChallengePayload = {
    __typename?: "OauthAuthStringChallengePayload";
    /** The created authentication string. */
    authString: Scalars["String"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type OauthAuthStringCheckPayload = {
    __typename?: "OauthAuthStringCheckPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** Access token for use. */
    token?: Maybe<Scalars["String"]>;
};
/** OAuth2 client application */
export declare type OauthClient = Node & {
    __typename?: "OauthClient";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** OAuth application's client ID. */
    clientId: Scalars["String"];
    /** OAuth application's client secret. */
    clientSecret: Scalars["String"];
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** Information about the application. */
    description: Scalars["String"];
    /** Name of the developer. */
    developer: Scalars["String"];
    /** Url of the developer. */
    developerUrl: Scalars["String"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Image of the application. */
    imageUrl: Scalars["String"];
    /** OAuth application's client name. */
    name: Scalars["String"];
    /** Whether the OAuth application is publicly visible, or only visible to the creating workspace. */
    publicEnabled: Scalars["Boolean"];
    /** List of allowed redirect URIs for the application. */
    redirectUris: Array<Scalars["String"]>;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The resource types to request when creating new webhooks. */
    webhookResourceTypes: Array<Scalars["String"]>;
    /** Webhook URL */
    webhookUrl?: Maybe<Scalars["String"]>;
};
export declare type OauthClientCreateInput = {
    /** User facing description of the application. */
    description?: Maybe<Scalars["String"]>;
    /** Name of the developer of the application. */
    developer: Scalars["String"];
    /** Url of the developer (homepage or docs). */
    developerUrl: Scalars["String"];
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** URL for the app icon. */
    imageUrl?: Maybe<Scalars["String"]>;
    /** The application's name. */
    name: Scalars["String"];
    /** Whether the OAuth application should be publicly visible, or only visible to the creating workspace. */
    publicEnabled?: Maybe<Scalars["Boolean"]>;
    /** List of allowed redirect URIs for the application. */
    redirectUris: Array<Scalars["String"]>;
    /** List of resources the webhooks should subscribe to. */
    webhookResourceTypes: Array<Scalars["String"]>;
    /** The URL that will be called on data changes. */
    webhookUrl?: Maybe<Scalars["String"]>;
};
export declare type OauthClientPayload = {
    __typename?: "OauthClientPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** The OAuth client application that was created or updated. */
    oauthClient: OauthClient;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type OauthClientUpdateInput = {
    /** User facing description of the application. */
    description?: Maybe<Scalars["String"]>;
    /** Name of the developer of the application. */
    developer?: Maybe<Scalars["String"]>;
    /** URL of the developer (homepage or docs). */
    developerUrl?: Maybe<Scalars["String"]>;
    /** URL for the app icon. */
    imageUrl?: Maybe<Scalars["String"]>;
    /** The application's name. */
    name?: Maybe<Scalars["String"]>;
    /** Whether the OAuth application should be publicly visible, or only visible to the creating workspace. */
    publicEnabled?: Maybe<Scalars["Boolean"]>;
    /** List of allowed redirect URIs for the application. */
    redirectUris?: Maybe<Array<Scalars["String"]>>;
    /** List of resources the webhooks should subscribe to. */
    webhookResourceTypes?: Maybe<Array<Scalars["String"]>>;
    /** The URL that will be called on data changes. */
    webhookUrl?: Maybe<Scalars["String"]>;
};
export declare type OauthTokenRevokePayload = {
    __typename?: "OauthTokenRevokePayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type OnboardingCustomerSurvey = {
    companyRole?: Maybe<Scalars["String"]>;
    companySize?: Maybe<Scalars["String"]>;
};
/** An organization. Organizations are root-level objects that contain user accounts and teams. */
export declare type Organization = Node & {
    __typename?: "Organization";
    /** Allowed authentication providers, empty array means all are allowed */
    allowedAuthServices: Array<Scalars["String"]>;
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** Number of issues in the organization. */
    createdIssueCount: Scalars["Int"];
    /** The time at which deletion of the organization was requested. */
    deletionRequestedAt?: Maybe<Scalars["DateTime"]>;
    /** How git branches are formatted. If null, default formatting will be used. */
    gitBranchFormat?: Maybe<Scalars["String"]>;
    /** Whether the Git integration linkback messages should be sent to private repositories. */
    gitLinkbackMessagesEnabled: Scalars["Boolean"];
    /** Whether the Git integration linkback messages should be sent to public repositories. */
    gitPublicLinkbackMessagesEnabled: Scalars["Boolean"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Integrations associated with the organization. */
    integrations: IntegrationConnection;
    /** Labels associated with the organization. */
    labels: IssueLabelConnection;
    /** The organization's logo URL. */
    logoUrl?: Maybe<Scalars["String"]>;
    /** Milestones associated with the organization. */
    milestones: MilestoneConnection;
    /** The organization's name. */
    name: Scalars["String"];
    /** Rolling 30-day total upload volume for the organization, in megabytes. */
    periodUploadVolume: Scalars["Float"];
    /** Whether the organization is using a roadmap. */
    roadmapEnabled: Scalars["Boolean"];
    /** Whether SAML authentication is enabled for organization. */
    samlEnabled: Scalars["Boolean"];
    /** The organization's subscription to a paid plan. */
    subscription?: Maybe<Subscription>;
    /** Teams associated with the organization. */
    teams: TeamConnection;
    /** Templates associated with the organization. */
    templates: TemplateConnection;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The organization's unique URL key. */
    urlKey: Scalars["String"];
    /** Number of active users in the organization. */
    userCount: Scalars["Int"];
    /** Users associated with the organization. */
    users: UserConnection;
};
/** An organization. Organizations are root-level objects that contain user accounts and teams. */
export declare type OrganizationIntegrationsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organization. Organizations are root-level objects that contain user accounts and teams. */
export declare type OrganizationLabelsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueLabelFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organization. Organizations are root-level objects that contain user accounts and teams. */
export declare type OrganizationMilestonesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<MilestoneFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organization. Organizations are root-level objects that contain user accounts and teams. */
export declare type OrganizationTeamsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<TeamFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organization. Organizations are root-level objects that contain user accounts and teams. */
export declare type OrganizationTemplatesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organization. Organizations are root-level objects that contain user accounts and teams. */
export declare type OrganizationUsersArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    includeDisabled?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type OrganizationCancelDeletePayload = {
    __typename?: "OrganizationCancelDeletePayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type OrganizationDeletePayload = {
    __typename?: "OrganizationDeletePayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** Defines the use of a domain by an organization. */
export declare type OrganizationDomain = Node & {
    __typename?: "OrganizationDomain";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who added the domain. */
    creator?: Maybe<User>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Domain name */
    name: Scalars["String"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** E-mail used to verify this domain */
    verificationEmail?: Maybe<Scalars["String"]>;
    /** Is this domain verified */
    verified: Scalars["Boolean"];
};
export declare type OrganizationDomainCreateInput = {
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The domain name to add. */
    name: Scalars["String"];
    /** The email address to which to send the verification code. */
    verificationEmail: Scalars["String"];
};
export declare type OrganizationDomainPayload = {
    __typename?: "OrganizationDomainPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** The organization domain that was created or updated. */
    organizationDomain: OrganizationDomain;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type OrganizationDomainSimplePayload = {
    __typename?: "OrganizationDomainSimplePayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type OrganizationDomainVerificationInput = {
    /** The identifier of the domain being verified. */
    organizationDomainId: Scalars["String"];
    /** The verification code sent via email. */
    verificationCode: Scalars["String"];
};
export declare type OrganizationExistsPayload = {
    __typename?: "OrganizationExistsPayload";
    /** Whether the organization exists. */
    exists: Scalars["Boolean"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** An invitation to the organization that has been sent via email. */
export declare type OrganizationInvite = Node & {
    __typename?: "OrganizationInvite";
    /** The time at which the invite was accepted. Null, if the invite hasn't been accepted */
    acceptedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The invitees email address. */
    email: Scalars["String"];
    /** The time at which the invite will be expiring. Null, if the invite shouldn't expire */
    expiresAt?: Maybe<Scalars["DateTime"]>;
    /** The invite was sent to external address. */
    external: Scalars["Boolean"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The user who has accepted the invite. Null, if the invite hasn't been accepted. */
    invitee?: Maybe<User>;
    /** The user who created the invitation. */
    inviter: User;
    /** The organization that the invite is associated with. */
    organization: Organization;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type OrganizationInviteConnection = {
    __typename?: "OrganizationInviteConnection";
    edges: Array<OrganizationInviteEdge>;
    nodes: Array<OrganizationInvite>;
    pageInfo: PageInfo;
};
export declare type OrganizationInviteCreateInput = {
    /** The email of the invitee. */
    email: Scalars["String"];
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The message to send to the invitee. */
    message?: Maybe<Scalars["String"]>;
    /** The teams that the user has been invited to. */
    teamIds?: Maybe<Array<Scalars["String"]>>;
};
export declare type OrganizationInviteDetailsPayload = {
    __typename?: "OrganizationInviteDetailsPayload";
    /** Whether the invite has already been accepted. */
    accepted: Scalars["Boolean"];
    /** When the invite was created. */
    createdAt: Scalars["DateTime"];
    /** The email of the invitee */
    email: Scalars["String"];
    /** Whether the invite has expired. */
    expired: Scalars["Boolean"];
    /** The name of the inviter */
    inviter: Scalars["String"];
    /** ID of the workspace the invite is for. */
    organizationId: Scalars["String"];
    /** URL of the workspace logo the invite is for. */
    organizationLogoUrl?: Maybe<Scalars["String"]>;
    /** Name of the workspace the invite is for. */
    organizationName: Scalars["String"];
};
export declare type OrganizationInviteEdge = {
    __typename?: "OrganizationInviteEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: OrganizationInvite;
};
export declare type OrganizationInvitePayload = {
    __typename?: "OrganizationInvitePayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** The organization invite that was created or updated. */
    organizationInvite: OrganizationInvite;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type OrganizationPayload = {
    __typename?: "OrganizationPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** The organization that was created or updated. */
    organization?: Maybe<Organization>;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type PageInfo = {
    __typename?: "PageInfo";
    /** Cursor representing the last result in the paginated results. */
    endCursor?: Maybe<Scalars["String"]>;
    /** Indicates if there are more results when paginating forward. */
    hasNextPage: Scalars["Boolean"];
    /** Indicates if there are more results when paginating backward. */
    hasPreviousPage: Scalars["Boolean"];
    /** Cursor representing the first result in the paginated results. */
    startCursor?: Maybe<Scalars["String"]>;
};
/** By which field should the pagination order by */
export declare enum PaginationOrderBy {
    CreatedAt = "createdAt",
    UpdatedAt = "updatedAt"
}
/** A project. */
export declare type Project = Node & {
    __typename?: "Project";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the project was automatically archived by the auto pruning process. */
    autoArchivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the project was moved into canceled state. */
    canceledAt?: Maybe<Scalars["DateTime"]>;
    /** The project's color. */
    color: Scalars["String"];
    /** The time at which the project was moved into completed state. */
    completedAt?: Maybe<Scalars["DateTime"]>;
    /** The number of completed issues in the project after each week. */
    completedIssueCountHistory: Array<Scalars["Float"]>;
    /** The number of completed estimation points after each week. */
    completedScopeHistory: Array<Scalars["Float"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the project. */
    creator: User;
    /** The project's description. */
    description: Scalars["String"];
    /** Documents associated with the project. */
    documents: DocumentConnection;
    /** The icon of the project. */
    icon?: Maybe<Scalars["String"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The total number of issues in the project after each week. */
    issueCountHistory: Array<Scalars["Float"]>;
    /** Issues associated with the project. */
    issues: IssueConnection;
    /** The project lead. */
    lead?: Maybe<User>;
    /** Links associated with the project. */
    links: ProjectLinkConnection;
    /** Users that are members of the project. */
    members: UserConnection;
    /** The milestone that this project is associated with. */
    milestone?: Maybe<Milestone>;
    /** The project's name. */
    name: Scalars["String"];
    /** The overall progress of the project. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points. */
    progress: Scalars["Float"];
    /** The total number of estimation points after each week. */
    scopeHistory: Array<Scalars["Float"]>;
    /** Whether to send new issue comment notifications to Slack. */
    slackIssueComments: Scalars["Boolean"];
    /** Whether to send new issue status updates to Slack. */
    slackIssueStatuses: Scalars["Boolean"];
    /** Whether to send new issue notifications to Slack. */
    slackNewIssue: Scalars["Boolean"];
    /** The project's unique URL slug. */
    slugId: Scalars["String"];
    /** The sort order for the project within its milestone. */
    sortOrder: Scalars["Float"];
    /** [Internal] The estimated start date of the project. */
    startDate?: Maybe<Scalars["TimelessDate"]>;
    /** The time at which the project was moved into started state. */
    startedAt?: Maybe<Scalars["DateTime"]>;
    /** The type of the state. */
    state: Scalars["String"];
    /** The estimated completion date of the project. */
    targetDate?: Maybe<Scalars["TimelessDate"]>;
    /** Teams associated with this project. */
    teams: TeamConnection;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** Project URL. */
    url: Scalars["String"];
};
/** A project. */
export declare type ProjectDocumentsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A project. */
export declare type ProjectIssuesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A project. */
export declare type ProjectLinksArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A project. */
export declare type ProjectMembersArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<UserFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    includeDisabled?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A project. */
export declare type ProjectTeamsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<TeamFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** [Alpha] Project filtering options. */
export declare type ProjectCollectionFilter = {
    /** Compound filters, all of which need to be matched by the project. */
    and?: Maybe<Array<ProjectFilter>>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Filters that the projects creator must satisfy. */
    creator?: Maybe<UserFilter>;
    /** Filters that needs to be matched by all projects. */
    every?: Maybe<ProjectFilter>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Filters that the projects issues must satisfy. */
    issues?: Maybe<IssueCollectionFilter>;
    /** Filters that the projects lead must satisfy. */
    lead?: Maybe<NullableUserFilter>;
    /** Filters that the projects members must satisfy. */
    members?: Maybe<UserFilter>;
    /** Filters that the projects milestones must satisfy. */
    milestone?: Maybe<NullableMilestoneFilter>;
    /** Comparator for the project name. */
    name?: Maybe<StringComparator>;
    /** Compound filters, one of which need to be matched by the project. */
    or?: Maybe<Array<ProjectFilter>>;
    /** Filters that needs to be matched by some projects. */
    some?: Maybe<ProjectFilter>;
    /** Comparator for the project start date. */
    startDate?: Maybe<NullableDateComparator>;
    /** Comparator for the project state. */
    state?: Maybe<StringComparator>;
    /** Comparator for the project target date. */
    targetDate?: Maybe<NullableDateComparator>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
export declare type ProjectConnection = {
    __typename?: "ProjectConnection";
    edges: Array<ProjectEdge>;
    nodes: Array<Project>;
    pageInfo: PageInfo;
};
export declare type ProjectCreateInput = {
    /** The color of the project. */
    color?: Maybe<Scalars["String"]>;
    /** The description for the project. */
    description?: Maybe<Scalars["String"]>;
    /** The icon of the project. */
    icon?: Maybe<Scalars["String"]>;
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The identifier of the project lead. */
    leadId?: Maybe<Scalars["String"]>;
    /** The identifiers of the members of this project. */
    memberIds?: Maybe<Array<Scalars["String"]>>;
    /** The identifier of the milestone to associate the project with. */
    milestoneId?: Maybe<Scalars["String"]>;
    /** The name of the project. */
    name: Scalars["String"];
    /** The sort order for the project within its milestone. */
    sortOrder?: Maybe<Scalars["Float"]>;
    /** [Internal] The planned start date of the project. */
    startDate?: Maybe<Scalars["TimelessDate"]>;
    /** The state of the project. */
    state?: Maybe<Scalars["String"]>;
    /** The planned target date of the project. */
    targetDate?: Maybe<Scalars["TimelessDate"]>;
    /** The identifiers of the teams this project is associated with. */
    teamIds: Array<Scalars["String"]>;
};
export declare type ProjectEdge = {
    __typename?: "ProjectEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Project;
};
/** [Alpha] Project filtering options. */
export declare type ProjectFilter = {
    /** Compound filters, all of which need to be matched by the project. */
    and?: Maybe<Array<ProjectFilter>>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Filters that the projects creator must satisfy. */
    creator?: Maybe<UserFilter>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Filters that the projects issues must satisfy. */
    issues?: Maybe<IssueCollectionFilter>;
    /** Filters that the projects lead must satisfy. */
    lead?: Maybe<NullableUserFilter>;
    /** Filters that the projects members must satisfy. */
    members?: Maybe<UserFilter>;
    /** Filters that the projects milestones must satisfy. */
    milestone?: Maybe<NullableMilestoneFilter>;
    /** Comparator for the project name. */
    name?: Maybe<StringComparator>;
    /** Compound filters, one of which need to be matched by the project. */
    or?: Maybe<Array<ProjectFilter>>;
    /** Comparator for the project start date. */
    startDate?: Maybe<NullableDateComparator>;
    /** Comparator for the project state. */
    state?: Maybe<StringComparator>;
    /** Comparator for the project target date. */
    targetDate?: Maybe<NullableDateComparator>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
/** An external link for a project. */
export declare type ProjectLink = Node & {
    __typename?: "ProjectLink";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the link. */
    creator: User;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The link's label. */
    label: Scalars["String"];
    /** The project that the link is associated with. */
    project: Project;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The link's URL. */
    url: Scalars["String"];
};
export declare type ProjectLinkConnection = {
    __typename?: "ProjectLinkConnection";
    edges: Array<ProjectLinkEdge>;
    nodes: Array<ProjectLink>;
    pageInfo: PageInfo;
};
export declare type ProjectLinkCreateInput = {
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The label for the link. */
    label: Scalars["String"];
    /** Related project for the link. */
    projectId: Scalars["String"];
    /** The URL of the link. */
    url: Scalars["String"];
};
export declare type ProjectLinkEdge = {
    __typename?: "ProjectLinkEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: ProjectLink;
};
export declare type ProjectLinkPayload = {
    __typename?: "ProjectLinkPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** The project that was created or updated. */
    projectLink: ProjectLink;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type ProjectLinkUpdateInput = {
    /** The label for the link. */
    label?: Maybe<Scalars["String"]>;
    /** The URL of the link. */
    url?: Maybe<Scalars["String"]>;
};
export declare type ProjectPayload = {
    __typename?: "ProjectPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** The project that was created or updated. */
    project?: Maybe<Project>;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type ProjectUpdateInput = {
    /** The date when the project was canceled. */
    canceledAt?: Maybe<Scalars["DateTime"]>;
    /** The color of the project. */
    color?: Maybe<Scalars["String"]>;
    /** The date when the project was completed. */
    completedAt?: Maybe<Scalars["DateTime"]>;
    /** The description for the project. */
    description?: Maybe<Scalars["String"]>;
    /** The icon of the project. */
    icon?: Maybe<Scalars["String"]>;
    /** The identifier of the project lead. */
    leadId?: Maybe<Scalars["String"]>;
    /** The identifiers of the members of this project. */
    memberIds?: Maybe<Array<Scalars["String"]>>;
    /** The identifier of the milestone to associate the project with. */
    milestoneId?: Maybe<Scalars["String"]>;
    /** The name of the project. */
    name?: Maybe<Scalars["String"]>;
    /** Whether to send new issue comment notifications to Slack. */
    slackIssueComments?: Maybe<Scalars["Boolean"]>;
    /** Whether to send issue status update notifications to Slack. */
    slackIssueStatuses?: Maybe<Scalars["Boolean"]>;
    /** Whether to send new issue notifications to Slack. */
    slackNewIssue?: Maybe<Scalars["Boolean"]>;
    /** The sort order for the project within its milestone. */
    sortOrder?: Maybe<Scalars["Float"]>;
    /** [Internal] The planned start date of the project. */
    startDate?: Maybe<Scalars["TimelessDate"]>;
    /** The state of the project. */
    state?: Maybe<Scalars["String"]>;
    /** The planned target date of the project. */
    targetDate?: Maybe<Scalars["TimelessDate"]>;
    /** The identifiers of the teams this project is associated with. */
    teamIds?: Maybe<Array<Scalars["String"]>>;
};
/** Pull request data */
export declare type PullRequestPayload = {
    __typename?: "PullRequestPayload";
    branch: Scalars["String"];
    closedAt: Scalars["String"];
    createdAt: Scalars["String"];
    draft: Scalars["Boolean"];
    id: Scalars["String"];
    mergedAt: Scalars["String"];
    number: Scalars["Float"];
    repoLogin: Scalars["String"];
    repoName: Scalars["String"];
    status: Scalars["String"];
    title: Scalars["String"];
    updatedAt: Scalars["String"];
    url: Scalars["String"];
    userId: Scalars["String"];
    userLogin: Scalars["String"];
};
/** A user's web browser push notification subscription. */
export declare type PushSubscription = Node & {
    __typename?: "PushSubscription";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type PushSubscriptionConnection = {
    __typename?: "PushSubscriptionConnection";
    edges: Array<PushSubscriptionEdge>;
    nodes: Array<PushSubscription>;
    pageInfo: PageInfo;
};
export declare type PushSubscriptionCreateInput = {
    /** The data of the subscription in stringified JSON format. */
    data: Scalars["String"];
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The user identifier of the subscription. */
    userId: Scalars["String"];
};
export declare type PushSubscriptionEdge = {
    __typename?: "PushSubscriptionEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: PushSubscription;
};
export declare type PushSubscriptionPayload = {
    __typename?: "PushSubscriptionPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type PushSubscriptionTestPayload = {
    __typename?: "PushSubscriptionTestPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type Query = {
    __typename?: "Query";
    /** All teams you the user can administrate. Administrable teams are teams whose settings the user can change, but to whose issues the user doesn't necessarily have access to. */
    administrableTeams: TeamConnection;
    /** [Internal] All API keys for the user. */
    apiKeys: ApiKeyConnection;
    /** Get information for an application and whether a user has approved it for the given scopes. */
    applicationWithAuthorization: UserAuthorizedApplication;
    /** [Internal] Fetches an archived model. */
    archivedModelSync: ArchiveResponse;
    /** [Internal] Fetches archived models. */
    archivedModelsSync: ArchiveResponse;
    /**
     * [Alpha] One specific issue attachment.
     * [Deprecated] 'url' can no longer be used as the 'id' parameter. Use 'attachmentsForUrl' instead
     */
    attachment: Attachment;
    /**
     * [Alpha] Query an issue by its associated attachment, and its id.
     * @deprecated Will be removed in near future, please use `attachmentsForURL` to get attachments and their issues instead.
     */
    attachmentIssue: Issue;
    /**
     * [Alpha] All issue attachments.
     *
     * To get attachments for a given URL, use `attachmentsForURL` query.
     */
    attachments: AttachmentConnection;
    /** [Alpha] Returns issue attachments for a given `url`. */
    attachmentsForURL: AttachmentConnection;
    /** All audit log entries. */
    auditEntries: AuditEntryConnection;
    /** List of audit entry types. */
    auditEntryTypes: Array<AuditEntryType>;
    /** Get all authorized applications for a user */
    authorizedApplications: Array<AuthorizedApplication>;
    /** Fetch users belonging to this user account. */
    availableUsers: AuthResolverResponse;
    /** Billing details for the customer. */
    billingDetails: BillingDetailsPayload;
    /** Join collaborative document and get missing steps. */
    collaborativeDocumentJoin: CollaborationDocumentUpdatePayload;
    /** A specific comment. */
    comment: Comment;
    /** All comments. */
    comments: CommentConnection;
    /** One specific custom view. */
    customView: CustomView;
    /** Custom views for the user. */
    customViews: CustomViewConnection;
    /** One specific cycle. */
    cycle: Cycle;
    /** All cycles. */
    cycles: CycleConnection;
    /** [Internal] Fetches the dependencies of a model. */
    dependentModelSync: DependencyResponse;
    /** One specific document. */
    document: Document;
    /** All documents for the project. */
    documents: DocumentConnection;
    /** A specific emoji. */
    emoji: Emoji;
    /** All custom emojis. */
    emojis: EmojiConnection;
    /** One specific favorite. */
    favorite: Favorite;
    /** The user's favorites. */
    favorites: FavoriteConnection;
    /** Fetch Figma screenshot and other information with file and node identifiers. */
    figmaEmbedInfo: FigmaEmbedPayload;
    /** One specific integration. */
    integration: Integration;
    /** One specific integration resource. (e.g. linked GitHub pull requests for an issue) */
    integrationResource: IntegrationResource;
    /** All integrations resources (e.g. linked GitHub pull requests for issues). */
    integrationResources: IntegrationResourceConnection;
    /** All integrations. */
    integrations: IntegrationConnection;
    /** One specific issue. */
    issue: Issue;
    /** [Internal] The history of issue descriptions. */
    issueDescriptionHistory: IssueDescriptionHistoryPayload;
    /** Fetches the GitHub token, completing the OAuth flow. */
    issueImportFinishGithubOAuth: GithubOAuthTokenPayload;
    /** One specific label. */
    issueLabel: IssueLabel;
    /** All issue labels. */
    issueLabels: IssueLabelConnection;
    /** Issue priority values and corresponding labels. */
    issuePriorityValues: Array<IssuePriorityValue>;
    /** One specific issue relation. */
    issueRelation: IssueRelation;
    /** All issue relationships. */
    issueRelations: IssueRelationConnection;
    /** [ALPHA] Search issues. This query is experimental and is subject to change without notice. */
    issueSearch: IssueConnection;
    /** All issues. */
    issues: IssueConnection;
    /** One specific milestone. */
    milestone: Milestone;
    /** All milestones. */
    milestones: MilestoneConnection;
    /** One specific notification. */
    notification: Notification;
    /** One specific notification subscription. */
    notificationSubscription: NotificationSubscription;
    /** The user's notification subscriptions. */
    notificationSubscriptions: NotificationSubscriptionConnection;
    /** All notifications. */
    notifications: NotificationConnection;
    /** The user's organization. */
    organization: Organization;
    /** Does the organization exist. */
    organizationExists: OrganizationExistsPayload;
    /** One specific organization invite. */
    organizationInvite: OrganizationInvite;
    /** One specific organization invite. */
    organizationInviteDetails: OrganizationInviteDetailsPayload;
    /** All invites for the organization. */
    organizationInvites: OrganizationInviteConnection;
    /** One specific project. */
    project: Project;
    /** One specific project link. */
    projectLink: ProjectLink;
    /** All links for the project. */
    projectLinks: ProjectLinkConnection;
    /** All projects. */
    projects: ProjectConnection;
    /** Sends a test push message. */
    pushSubscriptionTest: PushSubscriptionTestPayload;
    /** A specific reaction. */
    reaction: Reaction;
    /** All comment emoji reactions. */
    reactions: ReactionConnection;
    /** Fetch SSO login URL for the email provided. */
    ssoUrlFromEmail: SsoUrlFromEmailResponse;
    /** The organization's subscription. */
    subscription?: Maybe<Subscription>;
    /** [Internal] Syncs a batch of models. */
    syncBatch: SyncBatchResponse;
    /** [Internal] Fetch data to catch up the client to the state of the world. */
    syncBootstrap: SyncResponse;
    /** [Internal] Fetches delta sync packets. */
    syncDelta: SyncDeltaResponse;
    /** One specific team. */
    team: Team;
    /** One specific team membership. */
    teamMembership: TeamMembership;
    /** All team memberships. */
    teamMemberships: TeamMembershipConnection;
    /** All teams whose issues can be accessed by the user. This might be different from `administrableTeams`, which also includes teams whose settings can be changed by the user. */
    teams: TeamConnection;
    /** A specific template. */
    template: Template;
    /** All templates from all users. */
    templates: Array<Template>;
    /** One specific user. */
    user: User;
    /** The user's settings. */
    userSettings: UserSettings;
    /** All users for the organization. */
    users: UserConnection;
    /** The currently authenticated user. */
    viewer: User;
    /** A specific webhook. */
    webhook: Webhook;
    /** All webhooks. */
    webhooks: WebhookConnection;
    /** One specific state. */
    workflowState: WorkflowState;
    /** All issue workflow states. */
    workflowStates: WorkflowStateConnection;
};
export declare type QueryAdministrableTeamsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<TeamFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryApiKeysArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryApplicationWithAuthorizationArgs = {
    clientId: Scalars["String"];
    redirectUri?: Maybe<Scalars["String"]>;
    scope: Array<Scalars["String"]>;
};
export declare type QueryArchivedModelSyncArgs = {
    identifier: Scalars["String"];
    modelClass: Scalars["String"];
};
export declare type QueryArchivedModelsSyncArgs = {
    before?: Maybe<Scalars["DateTime"]>;
    last?: Maybe<Scalars["Int"]>;
    modelClass: Scalars["String"];
    teamId: Scalars["String"];
    trashOption?: Maybe<TrashOptionType>;
};
export declare type QueryAttachmentArgs = {
    id: Scalars["String"];
};
export declare type QueryAttachmentIssueArgs = {
    id: Scalars["String"];
};
export declare type QueryAttachmentsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<AttachmentFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryAttachmentsForUrlArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
    url: Scalars["String"];
};
export declare type QueryAuditEntriesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<AuditEntryFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryCollaborativeDocumentJoinArgs = {
    clientId: Scalars["String"];
    issueId: Scalars["String"];
    version: Scalars["Int"];
};
export declare type QueryCommentArgs = {
    id: Scalars["String"];
};
export declare type QueryCommentsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<CommentFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryCustomViewArgs = {
    id: Scalars["String"];
};
export declare type QueryCustomViewsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryCycleArgs = {
    id: Scalars["String"];
};
export declare type QueryCyclesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<CycleFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryDependentModelSyncArgs = {
    identifier: Scalars["String"];
    modelClass: Scalars["String"];
};
export declare type QueryDocumentArgs = {
    id: Scalars["String"];
};
export declare type QueryDocumentsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryEmojiArgs = {
    id: Scalars["String"];
};
export declare type QueryEmojisArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryFavoriteArgs = {
    id: Scalars["String"];
};
export declare type QueryFavoritesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryFigmaEmbedInfoArgs = {
    fileId: Scalars["String"];
    nodeId?: Maybe<Scalars["String"]>;
};
export declare type QueryIntegrationArgs = {
    id: Scalars["String"];
};
export declare type QueryIntegrationResourceArgs = {
    id: Scalars["String"];
};
export declare type QueryIntegrationResourcesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryIntegrationsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryIssueArgs = {
    id: Scalars["String"];
};
export declare type QueryIssueDescriptionHistoryArgs = {
    id: Scalars["String"];
};
export declare type QueryIssueImportFinishGithubOAuthArgs = {
    code: Scalars["String"];
};
export declare type QueryIssueLabelArgs = {
    id: Scalars["String"];
};
export declare type QueryIssueLabelsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueLabelFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryIssueRelationArgs = {
    id: Scalars["String"];
};
export declare type QueryIssueRelationsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryIssueSearchArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
    query: Scalars["String"];
};
export declare type QueryIssuesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryMilestoneArgs = {
    id: Scalars["String"];
};
export declare type QueryMilestonesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<MilestoneFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryNotificationArgs = {
    id: Scalars["String"];
};
export declare type QueryNotificationSubscriptionArgs = {
    id: Scalars["String"];
};
export declare type QueryNotificationSubscriptionsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryNotificationsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryOrganizationExistsArgs = {
    urlKey: Scalars["String"];
};
export declare type QueryOrganizationInviteArgs = {
    id: Scalars["String"];
};
export declare type QueryOrganizationInviteDetailsArgs = {
    id: Scalars["String"];
};
export declare type QueryOrganizationInvitesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryProjectArgs = {
    id: Scalars["String"];
};
export declare type QueryProjectLinkArgs = {
    id: Scalars["String"];
};
export declare type QueryProjectLinksArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryProjectsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<ProjectFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryReactionArgs = {
    id: Scalars["String"];
};
export declare type QueryReactionsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QuerySsoUrlFromEmailArgs = {
    email: Scalars["String"];
    isDesktop?: Maybe<Scalars["Boolean"]>;
};
export declare type QuerySyncBatchArgs = {
    requests: Array<BatchRequest>;
};
export declare type QuerySyncBootstrapArgs = {
    newVersion?: Maybe<Scalars["Boolean"]>;
    onlyModels?: Maybe<Array<Scalars["String"]>>;
    syncGroups?: Maybe<Array<Scalars["String"]>>;
};
export declare type QuerySyncDeltaArgs = {
    lastSyncId: Scalars["Int"];
    offset?: Maybe<Scalars["Int"]>;
    toSyncId: Scalars["Int"];
};
export declare type QueryTeamArgs = {
    id: Scalars["String"];
};
export declare type QueryTeamMembershipArgs = {
    id: Scalars["String"];
};
export declare type QueryTeamMembershipsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryTeamsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<TeamFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryTemplateArgs = {
    id: Scalars["String"];
};
export declare type QueryUserArgs = {
    id: Scalars["String"];
};
export declare type QueryUsersArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<UserFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    includeDisabled?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryWebhookArgs = {
    id: Scalars["String"];
};
export declare type QueryWebhooksArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryWorkflowStateArgs = {
    id: Scalars["String"];
};
export declare type QueryWorkflowStatesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<WorkflowStateFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A reaction associated with a comment. */
export declare type Reaction = Node & {
    __typename?: "Reaction";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The comment that the reaction is associated with. */
    comment: Comment;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** Name of the reaction's emoji. */
    emoji: Scalars["String"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The user who reacted. */
    user: User;
};
export declare type ReactionConnection = {
    __typename?: "ReactionConnection";
    edges: Array<ReactionEdge>;
    nodes: Array<Reaction>;
    pageInfo: PageInfo;
};
export declare type ReactionCreateInput = {
    /** The comment to associate the reaction with. */
    commentId: Scalars["String"];
    /** The emoji the user reacted with. */
    emoji?: Maybe<Scalars["String"]>;
    /** The identifier. If none is provided, the backend will generate one */
    id?: Maybe<Scalars["String"]>;
};
export declare type ReactionEdge = {
    __typename?: "ReactionEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Reaction;
};
export declare type ReactionPayload = {
    __typename?: "ReactionPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    reaction: Reaction;
    success: Scalars["Boolean"];
};
export declare type RotateSecretPayload = {
    __typename?: "RotateSecretPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** The integration resource's settings */
export declare type SamlConfiguration = {
    __typename?: "SamlConfiguration";
    /** List of allowed email domains for SAML authentication. */
    allowedDomains?: Maybe<Array<Scalars["String"]>>;
    /** The issuer's custom entity ID. */
    issuerEntityId?: Maybe<Scalars["String"]>;
    /** Binding method for authentication call. Can be either `post` (default) or `redirect`. */
    ssoBinding?: Maybe<Scalars["String"]>;
    /** Sign in endpoint URL for the identity provider. */
    ssoEndpoint?: Maybe<Scalars["String"]>;
    /** The algorithm of the Signing Certificate. Can be one of `sha1`, `sha256` (default), or `sha512`. */
    ssoSignAlgo?: Maybe<Scalars["String"]>;
    /** X.509 Signing Certificate in string form. */
    ssoSigningCert?: Maybe<Scalars["String"]>;
};
export declare type SamlConfigurationInput = {
    /** List of allowed email domains for SAML authentication. */
    allowedDomains?: Maybe<Array<Scalars["String"]>>;
    /** The issuer's custom entity ID. */
    issuerEntityId?: Maybe<Scalars["String"]>;
    /** Binding method for authentication call. Can be either `post` (default) or `redirect`. */
    ssoBinding?: Maybe<Scalars["String"]>;
    /** Sign in endpoint URL for the identity provider. */
    ssoEndpoint?: Maybe<Scalars["String"]>;
    /** The algorithm of the Signing Certificate. Can be one of `sha1`, `sha256` (default), or `sha512`. */
    ssoSignAlgo?: Maybe<Scalars["String"]>;
    /** X.509 Signing Certificate in string form. */
    ssoSigningCert?: Maybe<Scalars["String"]>;
};
/** Sentry issue data */
export declare type SentryIssuePayload = {
    __typename?: "SentryIssuePayload";
    /** The Sentry identifier of the actor who created the issue. */
    actorId: Scalars["Float"];
    /** The name of the Sentry actor who created this issue. */
    actorName: Scalars["String"];
    /** The type of the actor who created the issue. */
    actorType: Scalars["String"];
    /** The date this issue was first seen. */
    firstSeen: Scalars["String"];
    /** The name of the first release version this issue appeared on, if available. */
    firstVersion?: Maybe<Scalars["String"]>;
    /** The Sentry identifier for the issue. */
    issueId: Scalars["String"];
    /** The title of the issue. */
    issueTitle: Scalars["String"];
    /** The Sentry identifier of the project this issue belongs to. */
    projectId: Scalars["Float"];
    /** The slug of the project this issue belongs to. */
    projectSlug: Scalars["String"];
    /** The shortId of the issue. */
    shortId: Scalars["String"];
    /** The description of the issue. */
    webUrl: Scalars["String"];
};
/** Sentry specific settings. */
export declare type SentrySettings = {
    __typename?: "SentrySettings";
    /** The slug of the Sentry organization being connected. */
    organizationSlug: Scalars["String"];
};
export declare type SentrySettingsInput = {
    /** The slug of the Sentry organization being connected. */
    organizationSlug: Scalars["String"];
};
/** Slack notification specific settings. */
export declare type SlackPostSettings = {
    __typename?: "SlackPostSettings";
    channel: Scalars["String"];
    channelId: Scalars["String"];
    configurationUrl: Scalars["String"];
};
export declare type SlackPostSettingsInput = {
    channel: Scalars["String"];
    channelId: Scalars["String"];
    configurationUrl: Scalars["String"];
};
export declare type SsoUrlFromEmailResponse = {
    __typename?: "SsoUrlFromEmailResponse";
    /** SAML SSO sign-in URL. */
    samlSsoUrl: Scalars["String"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type StepsResponse = {
    __typename?: "StepsResponse";
    /** List of client IDs for the document steps. */
    clientIds: Array<Scalars["String"]>;
    /** New document steps from the client. */
    steps?: Maybe<Array<Scalars["JSON"]>>;
    /** Client's document version. */
    version: Scalars["Int"];
};
/** Comparator for strings. */
export declare type StringComparator = {
    /** Contains constraint. Matches any values that contain the given string. */
    contains?: Maybe<Scalars["String"]>;
    /** Contains case insensitive constraint. Matches any values that contain the given string case insensitive. */
    containsIgnoreCase?: Maybe<Scalars["String"]>;
    /** Ends with constraint. Matches any values that end with the given string. */
    endsWith?: Maybe<Scalars["String"]>;
    /** Equals constraint. */
    eq?: Maybe<Scalars["String"]>;
    /** Equals case insensitive. Matches any values that matches the given string case insensitive. */
    eqIgnoreCase?: Maybe<Scalars["String"]>;
    /** In-array constraint. */
    in?: Maybe<Array<Scalars["String"]>>;
    /** Not-equals constraint. */
    neq?: Maybe<Scalars["String"]>;
    /** Not-equals case insensitive. Matches any values that don't match the given string case insensitive. */
    neqIgnoreCase?: Maybe<Scalars["String"]>;
    /** Not-in-array constraint. */
    nin?: Maybe<Array<Scalars["String"]>>;
    /** Doesn't contain constraint. Matches any values that don't contain the given string. */
    notContains?: Maybe<Scalars["String"]>;
    /** Doesn't contain case insensitive constraint. Matches any values that don't contain the given string case insensitive. */
    notContainsIgnoreCase?: Maybe<Scalars["String"]>;
    /** Doesn't end with constraint. Matches any values that don't end with the given string. */
    notEndsWith?: Maybe<Scalars["String"]>;
    /** Doesn't start with constraint. Matches any values that don't start with the given string. */
    notStartsWith?: Maybe<Scalars["String"]>;
    /** Starts with constraint. Matches any values that start with the given string. */
    startsWith?: Maybe<Scalars["String"]>;
};
/** The subscription of an organization. */
export declare type Subscription = Node & {
    __typename?: "Subscription";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The date the subscription was canceled, if any. */
    canceledAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The creator of the subscription. */
    creator?: Maybe<User>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The date the subscription will be billed next. */
    nextBillingAt?: Maybe<Scalars["DateTime"]>;
    /** The organization that the subscription is associated with. */
    organization: Organization;
    /** The subscription type of a pending change. Null if no change pending. */
    pendingChangeType?: Maybe<Scalars["String"]>;
    /** The number of seats in the subscription. */
    seats: Scalars["Float"];
    /** The subscription type. */
    type: Scalars["String"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type SubscriptionPayload = {
    __typename?: "SubscriptionPayload";
    /** The date the subscription was set to cancel at the end of the billing period, if any. */
    canceledAt?: Maybe<Scalars["DateTime"]>;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** The subscription entity being mutated. */
    subscription: Subscription;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type SubscriptionSessionPayload = {
    __typename?: "SubscriptionSessionPayload";
    /** The subscription session that was created or updated. */
    session?: Maybe<Scalars["String"]>;
};
export declare type SubscriptionUpdateInput = {
    /** The date the subscription was set to cancel, if any. */
    canceledAt?: Maybe<Scalars["DateTime"]>;
    /** The subscription type of a pending change. Null if no change pending. */
    pendingChangeType?: Maybe<Scalars["String"]>;
};
/** Contains the requested relations. */
export declare type SyncBatchResponse = {
    __typename?: "SyncBatchResponse";
    /** A JSON serialized collection of relations model object. */
    models: Scalars["String"];
};
/** Contains a delta sync. */
export declare type SyncDeltaResponse = {
    __typename?: "SyncDeltaResponse";
    /** Whether the client should try loading more. */
    loadMore: Scalars["Boolean"];
    /** Whether loading the delta was successful. In case it wasn't, the client is instructed to do a full bootstrap. */
    success: Scalars["Boolean"];
    /** A JSON serialized collection of delta packets. */
    updates?: Maybe<Scalars["String"]>;
};
/**
 * Contains either the full serialized state of the application or delta packets that the requester can
 *   apply to the local data set in order to be up-to-date.
 */
export declare type SyncResponse = {
    __typename?: "SyncResponse";
    /** The version of the remote database. Incremented by 1 for each migration run on the database. */
    databaseVersion: Scalars["Float"];
    /**
     * JSON serialized delta changes that the client can apply to its local state
     *     in order to catch up with the state of the world.
     */
    delta?: Maybe<Scalars["String"]>;
    /** The last sync id covered by the response. */
    lastSyncId: Scalars["Float"];
    /**
     * The full state of the organization as a serialized JSON object.
     *     Mutually exclusive with the delta property
     */
    state?: Maybe<Scalars["String"]>;
    /** The sync groups that the user is subscribed to. */
    subscribedSyncGroups: Array<Scalars["String"]>;
};
export declare type SynchronizedPayload = {
    __typename?: "SynchronizedPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
};
/** An organizational unit that contains issues. */
export declare type Team = Node & {
    __typename?: "Team";
    /** Team's currently active cycle. */
    activeCycle?: Maybe<Cycle>;
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** Period after which automatically closed and completed issues are automatically archived in months. */
    autoArchivePeriod: Scalars["Float"];
    /** Period after which issues are automatically closed in months. Null/undefined means disabled. */
    autoClosePeriod?: Maybe<Scalars["Float"]>;
    /** The canceled workflow state which auto closed issues will be set to. Defaults to the first canceled state. */
    autoCloseStateId?: Maybe<Scalars["String"]>;
    /** The team's color. */
    color?: Maybe<Scalars["String"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** Calendar feed URL (iCal) for cycles. */
    cycleCalenderUrl: Scalars["String"];
    /** The cooldown time after each cycle in weeks. */
    cycleCooldownTime: Scalars["Float"];
    /** The duration of a cycle in weeks. */
    cycleDuration: Scalars["Float"];
    /** Auto assign completed issues to current cycle. */
    cycleIssueAutoAssignCompleted: Scalars["Boolean"];
    /** Auto assign started issues to current cycle. */
    cycleIssueAutoAssignStarted: Scalars["Boolean"];
    /** Only allow issues issues with cycles in Active Issues. */
    cycleLockToActive: Scalars["Boolean"];
    /** The day of the week that a new cycle starts. */
    cycleStartDay: Scalars["Float"];
    /** Cycles associated with the team. */
    cycles: CycleConnection;
    /** Whether the team uses cycles. */
    cyclesEnabled: Scalars["Boolean"];
    /** What to use as an default estimate for unestimated issues. */
    defaultIssueEstimate: Scalars["Float"];
    /** The default workflow state into which issues are set when they are opened by team members. */
    defaultIssueState?: Maybe<WorkflowState>;
    /** The default template to use for new issues created by members of the team. */
    defaultTemplateForMembers?: Maybe<Template>;
    /**
     * The id of the default template to use for new issues created by members of the team.
     * @deprecated Use defaultTemplateForMembers instead
     */
    defaultTemplateForMembersId?: Maybe<Scalars["String"]>;
    /** The default template to use for new issues created by non-members of the team. */
    defaultTemplateForNonMembers?: Maybe<Template>;
    /**
     * The id of the default template to use for new issues created by non-members of the team.
     * @deprecated Use defaultTemplateForNonMembers instead
     */
    defaultTemplateForNonMembersId?: Maybe<Scalars["String"]>;
    /** The team's description. */
    description?: Maybe<Scalars["String"]>;
    /** The workflow state into which issues are moved when a PR has been opened as draft. */
    draftWorkflowState?: Maybe<WorkflowState>;
    /** Whether to group recent issue history entries. */
    groupIssueHistory: Scalars["Boolean"];
    /** The icon of the team. */
    icon?: Maybe<Scalars["String"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Unique hash for the team to be used in invite URLs. */
    inviteHash: Scalars["String"];
    /** Whether to allow zeros in issues estimates. */
    issueEstimationAllowZero: Scalars["Boolean"];
    /** Whether to add additional points to the estimate scale. */
    issueEstimationExtended: Scalars["Boolean"];
    /** The issue estimation type to use. */
    issueEstimationType: Scalars["String"];
    /** Whether issues without priority should be sorted first. */
    issueOrderingNoPriorityFirst: Scalars["Boolean"];
    /** Issues associated with the team. */
    issues: IssueConnection;
    /** The team's unique key. The key is used in URLs. */
    key: Scalars["String"];
    /** Labels associated with the team. */
    labels: IssueLabelConnection;
    /** The workflow state into which issues are moved when they are marked as a duplicate of another issue. Defaults to the first canceled state. */
    markedAsDuplicateWorkflowState?: Maybe<WorkflowState>;
    /** Users who are members of this team. */
    members: UserConnection;
    /** Memberships associated with the team. For easier access of the same data, use `members` query. */
    memberships: TeamMembershipConnection;
    /** The workflow state into which issues are moved when a PR has been merged. */
    mergeWorkflowState?: Maybe<WorkflowState>;
    /** The team's name. */
    name: Scalars["String"];
    /** The organization that the team is associated with. */
    organization: Organization;
    /** Whether the team is private or not. */
    private: Scalars["Boolean"];
    /** Projects associated with the team. */
    projects: ProjectConnection;
    /** The workflow state into which issues are moved when a review has been requested for the PR. */
    reviewWorkflowState?: Maybe<WorkflowState>;
    /** Whether to send new issue comment notifications to Slack. */
    slackIssueComments: Scalars["Boolean"];
    /** Whether to send new issue status updates to Slack. */
    slackIssueStatuses: Scalars["Boolean"];
    /** Whether to send new issue notifications to Slack. */
    slackNewIssue: Scalars["Boolean"];
    /** The workflow state into which issues are moved when a PR has been opened. */
    startWorkflowState?: Maybe<WorkflowState>;
    /** The states that define the workflow associated with the team. */
    states: WorkflowStateConnection;
    /** Templates associated with the team. */
    templates: TemplateConnection;
    /** The timezone of the team. Defaults to "America/Los_Angeles" */
    timezone: Scalars["String"];
    /** Whether triage mode is enabled for the team or not. */
    triageEnabled: Scalars["Boolean"];
    /** The workflow state into which issues are set when they are opened by non-team members or integrations if triage is enabled. */
    triageIssueState?: Maybe<WorkflowState>;
    /** How many upcoming cycles to create. */
    upcomingCycleCount: Scalars["Float"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** Webhooks associated with the team. */
    webhooks: WebhookConnection;
};
/** An organizational unit that contains issues. */
export declare type TeamCyclesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<CycleFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organizational unit that contains issues. */
export declare type TeamIssuesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organizational unit that contains issues. */
export declare type TeamLabelsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueLabelFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organizational unit that contains issues. */
export declare type TeamMembersArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<UserFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    includeDisabled?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organizational unit that contains issues. */
export declare type TeamMembershipsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organizational unit that contains issues. */
export declare type TeamProjectsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<ProjectFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organizational unit that contains issues. */
export declare type TeamStatesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<WorkflowStateFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organizational unit that contains issues. */
export declare type TeamTemplatesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organizational unit that contains issues. */
export declare type TeamWebhooksArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type TeamConnection = {
    __typename?: "TeamConnection";
    edges: Array<TeamEdge>;
    nodes: Array<Team>;
    pageInfo: PageInfo;
};
export declare type TeamCreateInput = {
    /** Period after which closed and completed issues are automatically archived, in months. 0 means disabled. */
    autoArchivePeriod?: Maybe<Scalars["Float"]>;
    /** Period after which issues are automatically closed, in months. */
    autoClosePeriod?: Maybe<Scalars["Float"]>;
    /** The canceled workflow state which auto closed issues will be set to. */
    autoCloseStateId?: Maybe<Scalars["String"]>;
    /** The color of the team. */
    color?: Maybe<Scalars["String"]>;
    /** The cooldown time after each cycle in weeks. */
    cycleCooldownTime?: Maybe<Scalars["Int"]>;
    /** The duration of each cycle in weeks. */
    cycleDuration?: Maybe<Scalars["Int"]>;
    /** Auto assign completed issues to current active cycle setting. */
    cycleIssueAutoAssignCompleted?: Maybe<Scalars["Boolean"]>;
    /** Auto assign started issues to current active cycle setting. */
    cycleIssueAutoAssignStarted?: Maybe<Scalars["Boolean"]>;
    /** Only allow issues issues with cycles in Active Issues. */
    cycleLockToActive?: Maybe<Scalars["Boolean"]>;
    /** The day of the week that a new cycle starts. */
    cycleStartDay?: Maybe<Scalars["Float"]>;
    /** Whether the team uses cycles. */
    cyclesEnabled?: Maybe<Scalars["Boolean"]>;
    /** What to use as an default estimate for unestimated issues. */
    defaultIssueEstimate?: Maybe<Scalars["Float"]>;
    /** The identifier of the default template for members of this team. */
    defaultTemplateForMembersId?: Maybe<Scalars["String"]>;
    /** The identifier of the default template for non-members of this team. */
    defaultTemplateForNonMembersId?: Maybe<Scalars["String"]>;
    /** The description of the team. */
    description?: Maybe<Scalars["String"]>;
    /** Whether to group recent issue history entries. */
    groupIssueHistory?: Maybe<Scalars["Boolean"]>;
    /** The icon of the team. */
    icon?: Maybe<Scalars["String"]>;
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** Whether to allow zeros in issues estimates. */
    issueEstimationAllowZero?: Maybe<Scalars["Boolean"]>;
    /** Whether to add additional points to the estimate scale. */
    issueEstimationExtended?: Maybe<Scalars["Boolean"]>;
    /** The issue estimation type to use. */
    issueEstimationType?: Maybe<Scalars["String"]>;
    /** Whether issues without priority should be sorted first. */
    issueOrderingNoPriorityFirst?: Maybe<Scalars["Boolean"]>;
    /** The key of the team. If not given, the key will be generated based on the name of the team. */
    key?: Maybe<Scalars["String"]>;
    /** The workflow state into which issues are moved when they are marked as a duplicate of another issue. */
    markedAsDuplicateWorkflowStateId?: Maybe<Scalars["String"]>;
    /** The name of the team. */
    name: Scalars["String"];
    /** The organization associated with the team. */
    organizationId?: Maybe<Scalars["String"]>;
    /** Internal. Whether the team is private or not. */
    private?: Maybe<Scalars["Boolean"]>;
    /** The timezone of the team. */
    timezone?: Maybe<Scalars["String"]>;
    /** Whether triage mode is enabled for the team. */
    triageEnabled?: Maybe<Scalars["Boolean"]>;
    /** How many upcoming cycles to create. */
    upcomingCycleCount?: Maybe<Scalars["Float"]>;
};
export declare type TeamEdge = {
    __typename?: "TeamEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Team;
};
/** [Alpha] Project filtering options. */
export declare type TeamFilter = {
    /** Compound filters, all of which need to be matched by the team. */
    and?: Maybe<Array<TeamFilter>>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Comparator for the team description. */
    description?: Maybe<NullableStringComparator>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Filters that the teams issues must satisfy. */
    issues?: Maybe<IssueCollectionFilter>;
    /** Comparator for the team key. */
    key?: Maybe<StringComparator>;
    /** Comparator for the team name. */
    name?: Maybe<StringComparator>;
    /** Compound filters, one of which need to be matched by the team. */
    or?: Maybe<Array<TeamFilter>>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
/** Defines the membership of a user to a team. */
export declare type TeamMembership = Node & {
    __typename?: "TeamMembership";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Whether the user is the owner of the team */
    owner?: Maybe<Scalars["Boolean"]>;
    /** The team that the membership is associated with. */
    team: Team;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The user that the membership is associated with. */
    user: User;
};
export declare type TeamMembershipConnection = {
    __typename?: "TeamMembershipConnection";
    edges: Array<TeamMembershipEdge>;
    nodes: Array<TeamMembership>;
    pageInfo: PageInfo;
};
export declare type TeamMembershipCreateInput = {
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** Internal. Whether the user is the owner of the team. */
    owner?: Maybe<Scalars["Boolean"]>;
    /** The identifier of the team associated with the membership. */
    teamId: Scalars["String"];
    /** The identifier of the user associated with the membership. */
    userId: Scalars["String"];
};
export declare type TeamMembershipEdge = {
    __typename?: "TeamMembershipEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: TeamMembership;
};
export declare type TeamMembershipPayload = {
    __typename?: "TeamMembershipPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The team membership that was created or updated. */
    teamMembership?: Maybe<TeamMembership>;
};
export declare type TeamMembershipUpdateInput = {
    /** Internal. Whether the user is the owner of the team. */
    owner: Scalars["Boolean"];
};
export declare type TeamPayload = {
    __typename?: "TeamPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The team that was created or updated. */
    team?: Maybe<Team>;
};
export declare type TeamUpdateInput = {
    /** Period after which closed and completed issues are automatically archived, in months. */
    autoArchivePeriod?: Maybe<Scalars["Float"]>;
    /** Period after which issues are automatically closed, in months. */
    autoClosePeriod?: Maybe<Scalars["Float"]>;
    /** The canceled workflow state which auto closed issues will be set to. */
    autoCloseStateId?: Maybe<Scalars["String"]>;
    /** The color of the team. */
    color?: Maybe<Scalars["String"]>;
    /** The cooldown time after each cycle in weeks. */
    cycleCooldownTime?: Maybe<Scalars["Int"]>;
    /** The duration of each cycle in weeks. */
    cycleDuration?: Maybe<Scalars["Int"]>;
    /** Whether the first cycle should start in the current or the next week. */
    cycleEnabledStartWeek?: Maybe<Scalars["String"]>;
    /** Auto assign completed issues to current active cycle setting. */
    cycleIssueAutoAssignCompleted?: Maybe<Scalars["Boolean"]>;
    /** Auto assign started issues to current active cycle setting. */
    cycleIssueAutoAssignStarted?: Maybe<Scalars["Boolean"]>;
    /** Only allow issues with cycles in Active Issues. */
    cycleLockToActive?: Maybe<Scalars["Boolean"]>;
    /** The day of the week that a new cycle starts. */
    cycleStartDay?: Maybe<Scalars["Float"]>;
    /** Whether the team uses cycles. */
    cyclesEnabled?: Maybe<Scalars["Boolean"]>;
    /** What to use as an default estimate for unestimated issues. */
    defaultIssueEstimate?: Maybe<Scalars["Float"]>;
    /** Default status for newly created issues. */
    defaultIssueStateId?: Maybe<Scalars["String"]>;
    /** The identifier of the default template for members of this team. */
    defaultTemplateForMembersId?: Maybe<Scalars["String"]>;
    /** The identifier of the default template for non-members of this team. */
    defaultTemplateForNonMembersId?: Maybe<Scalars["String"]>;
    /** The description of the team. */
    description?: Maybe<Scalars["String"]>;
    /** The workflow state into which issues are moved when a draft PR has been opened. */
    draftWorkflowStateId?: Maybe<Scalars["String"]>;
    /** Whether to group recent issue history entries. */
    groupIssueHistory?: Maybe<Scalars["Boolean"]>;
    /** The icon of the team. */
    icon?: Maybe<Scalars["String"]>;
    /** Whether to allow zeros in issues estimates. */
    issueEstimationAllowZero?: Maybe<Scalars["Boolean"]>;
    /** Whether to add additional points to the estimate scale. */
    issueEstimationExtended?: Maybe<Scalars["Boolean"]>;
    /** The issue estimation type to use. */
    issueEstimationType?: Maybe<Scalars["String"]>;
    /** Whether issues without priority should be sorted first. */
    issueOrderingNoPriorityFirst?: Maybe<Scalars["Boolean"]>;
    /** The key of the team. */
    key?: Maybe<Scalars["String"]>;
    /** The workflow state into which issues are moved when they are marked as a duplicate of another issue. */
    markedAsDuplicateWorkflowStateId?: Maybe<Scalars["String"]>;
    /** The workflow state into which issues are moved when a PR has been merged. */
    mergeWorkflowStateId?: Maybe<Scalars["String"]>;
    /** The name of the team. */
    name?: Maybe<Scalars["String"]>;
    /** Whether the team is private or not. */
    private?: Maybe<Scalars["Boolean"]>;
    /** The workflow state into which issues are moved when a review has been requested for the PR. */
    reviewWorkflowStateId?: Maybe<Scalars["String"]>;
    /** Whether to send new issue comment notifications to Slack. */
    slackIssueComments?: Maybe<Scalars["Boolean"]>;
    /** Whether to send issue status update notifications to Slack. */
    slackIssueStatuses?: Maybe<Scalars["Boolean"]>;
    /** Whether to send new issue notifications to Slack. */
    slackNewIssue?: Maybe<Scalars["Boolean"]>;
    /** The workflow state into which issues are moved when a PR has been opened. */
    startWorkflowStateId?: Maybe<Scalars["String"]>;
    /** The timezone of the team. */
    timezone?: Maybe<Scalars["String"]>;
    /** Whether triage mode is enabled for the team. */
    triageEnabled?: Maybe<Scalars["Boolean"]>;
    /** How many upcoming cycles to create. */
    upcomingCycleCount?: Maybe<Scalars["Float"]>;
};
/** A template object used for creating entities faster. */
export declare type Template = Node & {
    __typename?: "Template";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the template. */
    creator?: Maybe<User>;
    /** Template description. */
    description?: Maybe<Scalars["String"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The name of the template. */
    name: Scalars["String"];
    /** The organization that the template is associated with. If null, the template is associated with a particular team. */
    organization?: Maybe<Organization>;
    /** The team that the template is associated with. If null, the template is global to the workspace. */
    team?: Maybe<Team>;
    /** Template data. */
    templateData: Scalars["JSON"];
    /** The entity type this template is for. */
    type: Scalars["String"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type TemplateConnection = {
    __typename?: "TemplateConnection";
    edges: Array<TemplateEdge>;
    nodes: Array<Template>;
    pageInfo: PageInfo;
};
export declare type TemplateCreateInput = {
    /** The template description. */
    description?: Maybe<Scalars["String"]>;
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The template name. */
    name: Scalars["String"];
    /** The identifier or key of the team associated with the template. If not given, the template will be shared across all teams. */
    teamId?: Maybe<Scalars["String"]>;
    /** The template data as JSON encoded attributes of the type of entity, such as an issue. */
    templateData: Scalars["JSON"];
    /** The template type, e.g. 'issue'. */
    type: Scalars["String"];
};
export declare type TemplateEdge = {
    __typename?: "TemplateEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Template;
};
export declare type TemplatePayload = {
    __typename?: "TemplatePayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The template that was created or updated. */
    template: Template;
};
export declare type TemplateUpdateInput = {
    /** The template description. */
    description?: Maybe<Scalars["String"]>;
    /** The template name. */
    name?: Maybe<Scalars["String"]>;
    /** The identifier or key of the team associated with the template. If set to null, the template will be shared across all teams. */
    teamId?: Maybe<Scalars["String"]>;
    /** The template data as JSON encoded attributes of the type of entity, such as an issue. */
    templateData?: Maybe<Scalars["JSON"]>;
};
/** Comparator for timeless dates. */
export declare type TimelessDateComparator = {
    /** Equals constraint. */
    eq?: Maybe<Scalars["TimelessDate"]>;
    /** Greater-than constraint. Matches any values that are greater than the given value. */
    gt?: Maybe<Scalars["TimelessDate"]>;
    /** Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value. */
    gte?: Maybe<Scalars["TimelessDate"]>;
    /** In-array constraint. */
    in?: Maybe<Array<Scalars["TimelessDate"]>>;
    /** Less-than constraint. Matches any values that are less than the given value. */
    lt?: Maybe<Scalars["TimelessDate"]>;
    /** Less-than-or-equal constraint. Matches any values that are less than or equal to the given value. */
    lte?: Maybe<Scalars["TimelessDate"]>;
    /** Not-equals constraint. */
    neq?: Maybe<Scalars["TimelessDate"]>;
    /** Not-in-array constraint. */
    nin?: Maybe<Array<Scalars["TimelessDate"]>>;
};
export declare type TokenUserAccountAuthInput = {
    /** The email which to login via the magic login code. */
    email: Scalars["String"];
    /** The identifiers of the teams to auto-join. */
    teamIdsToJoin?: Maybe<Array<Scalars["String"]>>;
    /** The timezone of the user's browser. */
    timezone: Scalars["String"];
    /** The magic login code. */
    token: Scalars["String"];
};
/** How trashed models should be loaded. */
export declare enum TrashOptionType {
    ExcludeTrash = "excludeTrash",
    IncludeTrash = "includeTrash",
    TrashOnly = "trashOnly"
}
export declare type UpdateOrganizationInput = {
    /** List of services that are allowed to be used for login. */
    allowedAuthServices?: Maybe<Array<Scalars["String"]>>;
    /** How git branches are formatted. If null, default formatting will be used. */
    gitBranchFormat?: Maybe<Scalars["String"]>;
    /** Whether the Git integration linkback messages should be sent for private repositories. */
    gitLinkbackMessagesEnabled?: Maybe<Scalars["Boolean"]>;
    /** Whether the Git integration linkback messages should be sent for public repositories. */
    gitPublicLinkbackMessagesEnabled?: Maybe<Scalars["Boolean"]>;
    /** Linear Preview feature flags */
    linearPreviewFlags?: Maybe<Scalars["JSONObject"]>;
    /** The logo of the organization. */
    logoUrl?: Maybe<Scalars["String"]>;
    /** The name of the organization. */
    name?: Maybe<Scalars["String"]>;
    /** Whether the organization is using project milestones. */
    reducedPersonalInformation?: Maybe<Scalars["Boolean"]>;
    /** Whether the organization is using project milestones. */
    roadmapEnabled?: Maybe<Scalars["Boolean"]>;
    /** The URL key of the organization. */
    urlKey?: Maybe<Scalars["String"]>;
};
export declare type UpdateUserInput = {
    /** Whether the user account is active. */
    active?: Maybe<Scalars["Boolean"]>;
    /** Whether the user account has admin privileges. */
    admin?: Maybe<Scalars["Boolean"]>;
    /** The avatar image URL of the user. */
    avatarUrl?: Maybe<Scalars["String"]>;
    /** The user description or a short bio. */
    description?: Maybe<Scalars["String"]>;
    /** Reason for deactivation. */
    disableReason?: Maybe<Scalars["String"]>;
    /** The display name of the user. */
    displayName?: Maybe<Scalars["String"]>;
    /** The name of the user. */
    name?: Maybe<Scalars["String"]>;
    /** The emoji part of the user status. */
    statusEmoji?: Maybe<Scalars["String"]>;
    /** The label part of the user status. */
    statusLabel?: Maybe<Scalars["String"]>;
    /** When the user status should be cleared. */
    statusUntilAt?: Maybe<Scalars["DateTime"]>;
    /** The local timezone of the user. */
    timezone?: Maybe<Scalars["String"]>;
};
/** Object representing Google Cloud upload policy, plus additional data. */
export declare type UploadFile = {
    __typename?: "UploadFile";
    /** The asset URL for the uploaded file. (assigned automatically) */
    assetUrl: Scalars["String"];
    /** The content type. */
    contentType: Scalars["String"];
    /** The filename. */
    filename: Scalars["String"];
    headers: Array<UploadFileHeader>;
    metaData?: Maybe<Scalars["JSON"]>;
    /** The size of the uploaded file. */
    size: Scalars["Int"];
    /** The signed URL the for the uploaded file. (assigned automatically) */
    uploadUrl: Scalars["String"];
};
export declare type UploadFileHeader = {
    __typename?: "UploadFileHeader";
    /** Upload file header key. */
    key: Scalars["String"];
    /** Upload file header value. */
    value: Scalars["String"];
};
export declare type UploadPayload = {
    __typename?: "UploadPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** Object describing the file to be uploaded. */
    uploadFile?: Maybe<UploadFile>;
};
/** A user that has access to the the resources of an organization. */
export declare type User = Node & {
    __typename?: "User";
    /** Whether the user account is active or disabled (suspended). */
    active: Scalars["Boolean"];
    /** Whether the user is an organization administrator. */
    admin: Scalars["Boolean"];
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** Issues assigned to the user. */
    assignedIssues: IssueConnection;
    /** An URL to the user's avatar image. */
    avatarUrl?: Maybe<Scalars["String"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** Number of issues created. */
    createdIssueCount: Scalars["Int"];
    /** Issues created by the user. */
    createdIssues: IssueConnection;
    /** A short description of the user, either its title or bio. */
    description?: Maybe<Scalars["String"]>;
    /** Reason why is the account disabled. */
    disableReason?: Maybe<Scalars["String"]>;
    /** The user's display (nick) name. Unique within each organization. */
    displayName: Scalars["String"];
    /** The user's email address. */
    email: Scalars["String"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Unique hash for the user to be used in invite URLs. */
    inviteHash: Scalars["String"];
    /** Whether the user is the currently authenticated user. */
    isMe: Scalars["Boolean"];
    /** The last time the user was seen online. If null, the user is currently online. */
    lastSeen?: Maybe<Scalars["DateTime"]>;
    /** The user's full name. */
    name: Scalars["String"];
    /** Organization the user belongs to. */
    organization: Organization;
    /** The emoji to represent the user current status. */
    statusEmoji?: Maybe<Scalars["String"]>;
    /** The label of the user current status. */
    statusLabel?: Maybe<Scalars["String"]>;
    /** A date at which the user current status should be cleared. */
    statusUntilAt?: Maybe<Scalars["DateTime"]>;
    /** Memberships associated with the user. For easier access of the same data, use `teams` query. */
    teamMemberships: TeamMembershipConnection;
    /** Teams the user is part of. */
    teams: TeamConnection;
    /** The local timezone of the user. */
    timezone?: Maybe<Scalars["String"]>;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** User's profile URL. */
    url: Scalars["String"];
};
/** A user that has access to the the resources of an organization. */
export declare type UserAssignedIssuesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A user that has access to the the resources of an organization. */
export declare type UserCreatedIssuesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A user that has access to the the resources of an organization. */
export declare type UserTeamMembershipsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A user that has access to the the resources of an organization. */
export declare type UserTeamsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<TeamFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A user account. */
export declare type UserAccount = {
    __typename?: "UserAccount";
    /** The time at which the model was archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the model was created. */
    createdAt: Scalars["DateTime"];
    /** The user's email address. */
    email: Scalars["String"];
    /** The models identifier. */
    id: Scalars["ID"];
    /** The user's name. */
    name?: Maybe<Scalars["String"]>;
    /** The authentication service used to create the account. */
    service: Scalars["String"];
    /** The time at which the model was updated. */
    updatedAt: Scalars["DateTime"];
    /** Users belonging to the account. */
    users: Array<User>;
};
export declare type UserAdminPayload = {
    __typename?: "UserAdminPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** Public information of the OAuth application, plus whether the application has been authorized for the given scopes. */
export declare type UserAuthorizedApplication = {
    __typename?: "UserAuthorizedApplication";
    /** OAuth application's client ID. */
    clientId: Scalars["String"];
    /** Whether the application was created by Linear. */
    createdByLinear: Scalars["Boolean"];
    /** Information about the application. */
    description?: Maybe<Scalars["String"]>;
    /** Name of the developer. */
    developer: Scalars["String"];
    /** Url of the developer (homepage or docs). */
    developerUrl: Scalars["String"];
    /** Image of the application. */
    imageUrl?: Maybe<Scalars["String"]>;
    /** Whether the user has authorized the application for the given scopes. */
    isAuthorized: Scalars["Boolean"];
    /** Application name. */
    name: Scalars["String"];
    /** Whether or not webhooks are enabled for the application. */
    webhooksEnabled: Scalars["Boolean"];
};
export declare type UserConnection = {
    __typename?: "UserConnection";
    edges: Array<UserEdge>;
    nodes: Array<User>;
    pageInfo: PageInfo;
};
export declare type UserEdge = {
    __typename?: "UserEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: User;
};
/** [Alpha] User filtering options. */
export declare type UserFilter = {
    /** Compound filters, all of which need to be matched by the user. */
    and?: Maybe<Array<UserFilter>>;
    /** Filters that the users assigned issues must satisfy. */
    assignedIssues?: Maybe<IssueCollectionFilter>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Comparator for the users display name. */
    displayName?: Maybe<StringComparator>;
    /** Comparator for the users email. */
    email?: Maybe<StringComparator>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Filter based on the currently authenticated user. Set to true to filter for the authenticated user, false for any other user. */
    isMe?: Maybe<BooleanComparator>;
    /** Comparator for the users name. */
    name?: Maybe<StringComparator>;
    /** Compound filters, one of which need to be matched by the user. */
    or?: Maybe<Array<UserFilter>>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
/** The types of flags that the user can have. */
export declare enum UserFlagType {
    AnalyticsWelcomeDismissed = "analyticsWelcomeDismissed",
    CanPlaySnake = "canPlaySnake",
    CanPlayTetris = "canPlayTetris",
    CompletedOnboarding = "completedOnboarding",
    CycleWelcomeDismissed = "cycleWelcomeDismissed",
    DesktopDownloadToastDismissed = "desktopDownloadToastDismissed",
    DesktopInstalled = "desktopInstalled",
    DueDateShortcutMigration = "dueDateShortcutMigration",
    EmptyActiveIssuesDismissed = "emptyActiveIssuesDismissed",
    EmptyBacklogDismissed = "emptyBacklogDismissed",
    EmptyCustomViewsDismissed = "emptyCustomViewsDismissed",
    EmptyMyIssuesDismissed = "emptyMyIssuesDismissed",
    FigmaPromptDismissed = "figmaPromptDismissed",
    ImportBannerDismissed = "importBannerDismissed",
    IssueMovePromptCompleted = "issueMovePromptCompleted",
    ListSelectionTip = "listSelectionTip",
    MigrateThemePreference = "migrateThemePreference",
    ProjectWelcomeDismissed = "projectWelcomeDismissed",
    SlackCommentReactionTipShown = "slackCommentReactionTipShown",
    TriageWelcomeDismissed = "triageWelcomeDismissed"
}
/** Operations that can be applied to UserFlagType */
export declare enum UserFlagUpdateOperation {
    Clear = "clear",
    Decr = "decr",
    Incr = "incr",
    Lock = "lock"
}
export declare type UserPayload = {
    __typename?: "UserPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The user that was created or updated. */
    user?: Maybe<User>;
};
/** The settings of a user as a JSON object. */
export declare type UserSettings = Node & {
    __typename?: "UserSettings";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The notification channel settings the user has selected. */
    notificationPreferences: Scalars["JSONObject"];
    /** The email types the user has unsubscribed from. */
    unsubscribedFrom: Array<Scalars["String"]>;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The user associated with these settings. */
    user: User;
};
export declare type UserSettingsFlagPayload = {
    __typename?: "UserSettingsFlagPayload";
    /** The flag key which was updated. */
    flag: Scalars["String"];
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The flag value after update. */
    value: Scalars["Int"];
};
export declare type UserSettingsFlagsResetPayload = {
    __typename?: "UserSettingsFlagsResetPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type UserSettingsPayload = {
    __typename?: "UserSettingsPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The user's settings. */
    userSettings: UserSettings;
};
export declare type UserSettingsUpdateInput = {
    /** The user's notification preferences. */
    notificationPreferences?: Maybe<Scalars["JSONObject"]>;
    /** The user's settings. */
    settings?: Maybe<Scalars["String"]>;
    /** The types of emails the user has unsubscribed from. */
    unsubscribedFrom?: Maybe<Array<Scalars["String"]>>;
};
export declare type UserSubscribeToNewsletterPayload = {
    __typename?: "UserSubscribeToNewsletterPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** View preferences. */
export declare type ViewPreferences = Node & {
    __typename?: "ViewPreferences";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The view preference type. */
    type: Scalars["String"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The view type. */
    viewType: Scalars["String"];
};
export declare type ViewPreferencesCreateInput = {
    /** The custom view these view preferences are associated with. */
    customViewId?: Maybe<Scalars["String"]>;
    /** The cycle these view preferences are associated with. */
    cycleId?: Maybe<Scalars["String"]>;
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The label these view preferences are associated with. */
    labelId?: Maybe<Scalars["String"]>;
    /** View preferences object. */
    preferences: Scalars["JSONObject"];
    /** The project these view preferences are associated with. */
    projectId?: Maybe<Scalars["String"]>;
    /** The team these view preferences are associated with. */
    teamId?: Maybe<Scalars["String"]>;
    /** The type of view preferences (either user or organization level preferences). */
    type: ViewPreferencesType;
    /** The user profile these view preferences are associated with. */
    userId?: Maybe<Scalars["String"]>;
    /** The view type of the view preferences are associated with. */
    viewType: ViewType;
};
export declare type ViewPreferencesPayload = {
    __typename?: "ViewPreferencesPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The view preferences entity being mutated. */
    viewPreferences: ViewPreferences;
};
/** The type of view preferences (either user or organization level preferences). */
export declare enum ViewPreferencesType {
    Organization = "organization",
    User = "user"
}
export declare type ViewPreferencesUpdateInput = {
    /** View preferences. */
    preferences: Scalars["JSONObject"];
};
/** The client view this custom view is targeting. */
export declare enum ViewType {
    ActiveIssues = "activeIssues",
    AllIssues = "allIssues",
    Backlog = "backlog",
    Board = "board",
    CompletedCycle = "completedCycle",
    CustomView = "customView",
    Cycle = "cycle",
    Inbox = "inbox",
    Label = "label",
    MyIssues = "myIssues",
    Project = "project",
    Projects = "projects",
    Roadmap = "roadmap",
    Triage = "triage",
    UserProfile = "userProfile"
}
/** A webhook used to send HTTP notifications over data updates */
export declare type Webhook = Node & {
    __typename?: "Webhook";
    /** Whether the Webhook is enabled for all public teams, including teams created after the webhook was created. */
    allPublicTeams: Scalars["Boolean"];
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the webhook. */
    creator?: Maybe<User>;
    /** Whether the Webhook is enabled. */
    enabled: Scalars["Boolean"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Webhook label */
    label: Scalars["String"];
    /** The resource types this webhook is subscribed to. */
    resourceTypes: Array<Scalars["String"]>;
    /** Secret token for verifying the origin on the recipient side. */
    secret?: Maybe<Scalars["String"]>;
    /** The team that the webhook is associated with. */
    team: Team;
    /**
     * The ids of teams that the webhook is associated with.
     * @deprecated This field will no longer be used, and will return an empty array.
     */
    teamIds: Array<Scalars["String"]>;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** Webhook URL */
    url?: Maybe<Scalars["String"]>;
};
export declare type WebhookConnection = {
    __typename?: "WebhookConnection";
    edges: Array<WebhookEdge>;
    nodes: Array<Webhook>;
    pageInfo: PageInfo;
};
export declare type WebhookCreateInput = {
    /** Whether this webhook is enabled for all public teams. */
    allPublicTeams?: Maybe<Scalars["Boolean"]>;
    /** Whether this webhook is enabled. */
    enabled?: Maybe<Scalars["Boolean"]>;
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** Label for the webhook. */
    label?: Maybe<Scalars["String"]>;
    /** List of resources the webhook should subscribe to. */
    resourceTypes: Array<Scalars["String"]>;
    /** An optional secret token used to sign the webhook payload. */
    secret?: Maybe<Scalars["String"]>;
    /** The identifier or key of the team associated with the Webhook. */
    teamId?: Maybe<Scalars["String"]>;
    /** The URL that will be called on data changes. */
    url: Scalars["String"];
};
export declare type WebhookEdge = {
    __typename?: "WebhookEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Webhook;
};
export declare type WebhookPayload = {
    __typename?: "WebhookPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The webhook entity being mutated. */
    webhook: Webhook;
};
export declare type WebhookUpdateInput = {
    /** Whether this webhook is enabled. */
    enabled?: Maybe<Scalars["Boolean"]>;
    /** Label for the webhook. */
    label?: Maybe<Scalars["String"]>;
    /** List of resources the webhook should subscribe to. */
    resourceTypes?: Maybe<Array<Scalars["String"]>>;
    /** An optional secret token used to sign the Webhook payload. */
    secret?: Maybe<Scalars["String"]>;
    /** The URL that will be called on data changes. */
    url?: Maybe<Scalars["String"]>;
};
/** A state in a team workflow. */
export declare type WorkflowState = Node & {
    __typename?: "WorkflowState";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The state's UI color as a HEX string. */
    color: Scalars["String"];
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** Description of the state. */
    description?: Maybe<Scalars["String"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Issues belonging in this state. */
    issues: IssueConnection;
    /** The state's name. */
    name: Scalars["String"];
    /** The position of the state in the team flow. */
    position: Scalars["Float"];
    /** The team to which this state belongs to. */
    team: Team;
    /** The type of the state. */
    type: Scalars["String"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
};
/** A state in a team workflow. */
export declare type WorkflowStateIssuesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type WorkflowStateConnection = {
    __typename?: "WorkflowStateConnection";
    edges: Array<WorkflowStateEdge>;
    nodes: Array<WorkflowState>;
    pageInfo: PageInfo;
};
export declare type WorkflowStateCreateInput = {
    /** The color of the state. */
    color: Scalars["String"];
    /** The description of the state. */
    description?: Maybe<Scalars["String"]>;
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The name of the state. */
    name: Scalars["String"];
    /** The position of the state. */
    position?: Maybe<Scalars["Float"]>;
    /** The team associated with the state. */
    teamId: Scalars["String"];
    /** The workflow type. */
    type: Scalars["String"];
};
export declare type WorkflowStateEdge = {
    __typename?: "WorkflowStateEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: WorkflowState;
};
/** [Alpha] Workflow state filtering options. */
export declare type WorkflowStateFilter = {
    /** Compound filters, all of which need to be matched by the workflow state. */
    and?: Maybe<Array<WorkflowStateFilter>>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Comparator for the workflow state description. */
    description?: Maybe<StringComparator>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Filters that the workflow states issues must satisfy. */
    issues?: Maybe<IssueCollectionFilter>;
    /** Comparator for the workflow state name. */
    name?: Maybe<StringComparator>;
    /** Compound filters, one of which need to be matched by the workflow state. */
    or?: Maybe<Array<WorkflowStateFilter>>;
    /** Comparator for the workflow state position. */
    position?: Maybe<NumberComparator>;
    /** Filters that the workflow states team must satisfy. */
    team?: Maybe<TeamFilter>;
    /** Comparator for the workflow state type. */
    type?: Maybe<StringComparator>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
export declare type WorkflowStatePayload = {
    __typename?: "WorkflowStatePayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The state that was created or updated. */
    workflowState: WorkflowState;
};
export declare type WorkflowStateUpdateInput = {
    /** The color of the state. */
    color?: Maybe<Scalars["String"]>;
    /** The description of the state. */
    description?: Maybe<Scalars["String"]>;
    /** The name of the state. */
    name?: Maybe<Scalars["String"]>;
    /** The position of the state. */
    position?: Maybe<Scalars["Float"]>;
};
/** Zendesk specific settings. */
export declare type ZendeskSettings = {
    __typename?: "ZendeskSettings";
    /** The ID of the Linear bot user. */
    botUserId: Scalars["String"];
    /** The subdomain of the Zendesk organization being connected. */
    subdomain: Scalars["String"];
    /** The URL of the connected Zendesk organization. */
    url: Scalars["String"];
};
export declare type ZendeskSettingsInput = {
    /** The ID of the Linear bot user. */
    botUserId: Scalars["String"];
    /** The subdomain of the Zendesk organization being connected. */
    subdomain: Scalars["String"];
    /** The URL of the connected Zendesk organization. */
    url: Scalars["String"];
};
export declare type CommentFragment = {
    __typename?: "Comment";
} & Pick<Comment, "url" | "body" | "updatedAt" | "archivedAt" | "createdAt" | "editedAt" | "id"> & {
    issue: {
        __typename?: "Issue";
    } & Pick<Issue, "id">;
    user: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type EmojiFragment = {
    __typename?: "Emoji";
} & Pick<Emoji, "url" | "name" | "updatedAt" | "source" | "archivedAt" | "createdAt" | "id"> & {
    creator: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type CustomViewFragment = {
    __typename?: "CustomView";
} & Pick<CustomView, "color" | "description" | "filters" | "icon" | "updatedAt" | "name" | "archivedAt" | "createdAt" | "id" | "shared" | "filterData"> & {
    team?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
    creator: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type DocumentFragment = {
    __typename?: "Document";
} & Pick<Document, "color" | "contentData" | "content" | "title" | "slugId" | "icon" | "updatedAt" | "archivedAt" | "createdAt" | "id"> & {
    project: {
        __typename?: "Project";
    } & Pick<Project, "id">;
    creator: {
        __typename?: "User";
    } & Pick<User, "id">;
    updatedBy: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type MilestoneFragment = {
    __typename?: "Milestone";
} & Pick<Milestone, "updatedAt" | "name" | "sortOrder" | "archivedAt" | "createdAt" | "id">;
export declare type NotificationFragment = {
    __typename?: "Notification";
} & Pick<Notification, "reactionEmoji" | "type" | "updatedAt" | "emailedAt" | "readAt" | "archivedAt" | "createdAt" | "snoozedUntilAt" | "id"> & {
    comment?: Maybe<{
        __typename?: "Comment";
    } & Pick<Comment, "id">>;
    issue: {
        __typename?: "Issue";
    } & Pick<Issue, "id">;
    user: {
        __typename?: "User";
    } & Pick<User, "id">;
    team: {
        __typename?: "Team";
    } & Pick<Team, "id">;
};
export declare type ProjectFragment = {
    __typename?: "Project";
} & Pick<Project, "url" | "targetDate" | "icon" | "updatedAt" | "completedScopeHistory" | "completedIssueCountHistory" | "progress" | "color" | "description" | "name" | "slugId" | "sortOrder" | "archivedAt" | "createdAt" | "autoArchivedAt" | "canceledAt" | "completedAt" | "startedAt" | "scopeHistory" | "issueCountHistory" | "state" | "id" | "slackIssueComments" | "slackNewIssue" | "slackIssueStatuses"> & {
    milestone?: Maybe<{
        __typename?: "Milestone";
    } & Pick<Milestone, "id">>;
    lead?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
    creator: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type ReactionFragment = {
    __typename?: "Reaction";
} & Pick<Reaction, "emoji" | "updatedAt" | "archivedAt" | "createdAt" | "id"> & {
    comment: {
        __typename?: "Comment";
    } & Pick<Comment, "id">;
    user: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type IssueHistoryFragment = {
    __typename?: "IssueHistory";
} & Pick<IssueHistory, "addedLabelIds" | "removedLabelIds" | "source" | "updatedAt" | "archivedAt" | "createdAt" | "id" | "fromDueDate" | "toDueDate" | "fromEstimate" | "toEstimate" | "fromPriority" | "toPriority" | "fromTitle" | "toTitle" | "archived" | "trashed" | "updatedDescription" | "autoArchived" | "autoClosed"> & {
    relationChanges?: Maybe<Array<{
        __typename?: "IssueRelationHistoryPayload";
    } & IssueRelationHistoryPayloadFragment>>;
    issueImport?: Maybe<{
        __typename?: "IssueImport";
    } & IssueImportFragment>;
    issue: {
        __typename?: "Issue";
    } & Pick<Issue, "id">;
    toCycle?: Maybe<{
        __typename?: "Cycle";
    } & Pick<Cycle, "id">>;
    toParent?: Maybe<{
        __typename?: "Issue";
    } & Pick<Issue, "id">>;
    toProject?: Maybe<{
        __typename?: "Project";
    } & Pick<Project, "id">>;
    toState?: Maybe<{
        __typename?: "WorkflowState";
    } & Pick<WorkflowState, "id">>;
    fromCycle?: Maybe<{
        __typename?: "Cycle";
    } & Pick<Cycle, "id">>;
    fromParent?: Maybe<{
        __typename?: "Issue";
    } & Pick<Issue, "id">>;
    fromProject?: Maybe<{
        __typename?: "Project";
    } & Pick<Project, "id">>;
    fromState?: Maybe<{
        __typename?: "WorkflowState";
    } & Pick<WorkflowState, "id">>;
    fromTeam?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
    toTeam?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
    fromAssignee?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
    toAssignee?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
    actor?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
export declare type IssueRelationFragment = {
    __typename?: "IssueRelation";
} & Pick<IssueRelation, "updatedAt" | "type" | "archivedAt" | "createdAt" | "id"> & {
    issue: {
        __typename?: "Issue";
    } & Pick<Issue, "id">;
    relatedIssue: {
        __typename?: "Issue";
    } & Pick<Issue, "id">;
};
export declare type CycleFragment = {
    __typename?: "Cycle";
} & Pick<Cycle, "completedAt" | "name" | "endsAt" | "updatedAt" | "completedScopeHistory" | "completedIssueCountHistory" | "number" | "progress" | "startsAt" | "autoArchivedAt" | "archivedAt" | "createdAt" | "scopeHistory" | "issueCountHistory" | "id"> & {
    team: {
        __typename?: "Team";
    } & Pick<Team, "id">;
};
export declare type WorkflowStateFragment = {
    __typename?: "WorkflowState";
} & Pick<WorkflowState, "description" | "updatedAt" | "position" | "color" | "name" | "archivedAt" | "createdAt" | "type" | "id"> & {
    team: {
        __typename?: "Team";
    } & Pick<Team, "id">;
};
export declare type TemplateFragment = {
    __typename?: "Template";
} & Pick<Template, "templateData" | "description" | "type" | "updatedAt" | "name" | "archivedAt" | "createdAt" | "id"> & {
    team?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
    creator?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
export declare type UserAccountFragment = {
    __typename?: "UserAccount";
} & Pick<UserAccount, "service" | "id" | "archivedAt" | "createdAt" | "updatedAt" | "email" | "name"> & {
    users: Array<{
        __typename?: "User";
    } & UserFragment>;
};
export declare type UserFragment = {
    __typename?: "User";
} & Pick<User, "statusUntilAt" | "description" | "avatarUrl" | "createdIssueCount" | "disableReason" | "statusEmoji" | "statusLabel" | "updatedAt" | "lastSeen" | "timezone" | "archivedAt" | "createdAt" | "id" | "displayName" | "email" | "name" | "inviteHash" | "url" | "active" | "admin" | "isMe">;
export declare type PushSubscriptionFragment = {
    __typename?: "PushSubscription";
} & Pick<PushSubscription, "updatedAt" | "archivedAt" | "createdAt" | "id">;
export declare type DocumentVersionFragment = {
    __typename?: "DocumentVersion";
} & Pick<DocumentVersion, "content" | "title" | "updatedAt" | "archivedAt" | "createdAt" | "id" | "revision"> & {
    project: {
        __typename?: "Project";
    } & Pick<Project, "id">;
    creator: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type WebhookFragment = {
    __typename?: "Webhook";
} & Pick<Webhook, "secret" | "teamIds" | "updatedAt" | "resourceTypes" | "archivedAt" | "createdAt" | "id" | "url" | "label" | "allPublicTeams" | "enabled"> & {
    team: {
        __typename?: "Team";
    } & Pick<Team, "id">;
    creator?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
export declare type ApiKeyFragment = {
    __typename?: "ApiKey";
} & Pick<ApiKey, "label" | "updatedAt" | "archivedAt" | "createdAt" | "id">;
export declare type ProjectLinkFragment = {
    __typename?: "ProjectLink";
} & Pick<ProjectLink, "updatedAt" | "url" | "label" | "archivedAt" | "createdAt" | "id"> & {
    project: {
        __typename?: "Project";
    } & Pick<Project, "id">;
    creator: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type IssueImportFragment = {
    __typename?: "IssueImport";
} & Pick<IssueImport, "mapping" | "creatorId" | "updatedAt" | "service" | "status" | "archivedAt" | "createdAt" | "id" | "error">;
export declare type IntegrationResourceFragment = {
    __typename?: "IntegrationResource";
} & Pick<IntegrationResource, "resourceId" | "resourceType" | "updatedAt" | "archivedAt" | "createdAt" | "id"> & {
    data: {
        __typename?: "IntegrationResourceData";
    } & IntegrationResourceDataFragment;
    pullRequest: {
        __typename?: "PullRequestPayload";
    } & PullRequestPayloadFragment;
    integration: {
        __typename?: "Integration";
    } & Pick<Integration, "id">;
    issue: {
        __typename?: "Issue";
    } & Pick<Issue, "id">;
};
export declare type IntegrationFragment = {
    __typename?: "Integration";
} & Pick<Integration, "service" | "updatedAt" | "archivedAt" | "createdAt" | "id"> & {
    team?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
    creator: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type OrganizationInviteFragment = {
    __typename?: "OrganizationInvite";
} & Pick<OrganizationInvite, "external" | "email" | "updatedAt" | "archivedAt" | "createdAt" | "acceptedAt" | "expiresAt" | "id"> & {
    inviter: {
        __typename?: "User";
    } & Pick<User, "id">;
    invitee?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
export declare type IssueFragment = {
    __typename?: "Issue";
} & Pick<Issue, "trashed" | "url" | "identifier" | "priorityLabel" | "previousIdentifiers" | "customerTicketCount" | "branchName" | "dueDate" | "estimate" | "description" | "title" | "number" | "updatedAt" | "boardOrder" | "sortOrder" | "subIssueSortOrder" | "priority" | "archivedAt" | "createdAt" | "autoArchivedAt" | "autoClosedAt" | "canceledAt" | "completedAt" | "startedAt" | "snoozedUntilAt" | "id"> & {
    cycle?: Maybe<{
        __typename?: "Cycle";
    } & Pick<Cycle, "id">>;
    parent?: Maybe<{
        __typename?: "Issue";
    } & Pick<Issue, "id">>;
    project?: Maybe<{
        __typename?: "Project";
    } & Pick<Project, "id">>;
    team: {
        __typename?: "Team";
    } & Pick<Team, "id">;
    assignee?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
    creator?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
    snoozedBy?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
    state: {
        __typename?: "WorkflowState";
    } & Pick<WorkflowState, "id">;
};
export declare type OrganizationFragment = {
    __typename?: "Organization";
} & Pick<Organization, "allowedAuthServices" | "gitBranchFormat" | "userCount" | "createdIssueCount" | "periodUploadVolume" | "updatedAt" | "logoUrl" | "name" | "urlKey" | "deletionRequestedAt" | "archivedAt" | "createdAt" | "id" | "samlEnabled" | "gitLinkbackMessagesEnabled" | "gitPublicLinkbackMessagesEnabled" | "roadmapEnabled">;
export declare type TeamFragment = {
    __typename?: "Team";
} & Pick<Team, "cycleIssueAutoAssignCompleted" | "cycleIssueAutoAssignStarted" | "cycleCalenderUrl" | "upcomingCycleCount" | "cycleLockToActive" | "autoArchivePeriod" | "autoClosePeriod" | "autoCloseStateId" | "cycleCooldownTime" | "cycleStartDay" | "cycleDuration" | "icon" | "defaultTemplateForMembersId" | "defaultTemplateForNonMembersId" | "issueEstimationType" | "updatedAt" | "color" | "description" | "name" | "key" | "archivedAt" | "createdAt" | "timezone" | "id" | "inviteHash" | "defaultIssueEstimate" | "issueOrderingNoPriorityFirst" | "private" | "cyclesEnabled" | "issueEstimationExtended" | "issueEstimationAllowZero" | "groupIssueHistory" | "slackIssueComments" | "slackNewIssue" | "slackIssueStatuses" | "triageEnabled"> & {
    activeCycle?: Maybe<{
        __typename?: "Cycle";
    } & Pick<Cycle, "id">>;
    defaultTemplateForMembers?: Maybe<{
        __typename?: "Template";
    } & Pick<Template, "id">>;
    defaultTemplateForNonMembers?: Maybe<{
        __typename?: "Template";
    } & Pick<Template, "id">>;
    defaultIssueState?: Maybe<{
        __typename?: "WorkflowState";
    } & Pick<WorkflowState, "id">>;
    mergeWorkflowState?: Maybe<{
        __typename?: "WorkflowState";
    } & Pick<WorkflowState, "id">>;
    draftWorkflowState?: Maybe<{
        __typename?: "WorkflowState";
    } & Pick<WorkflowState, "id">>;
    startWorkflowState?: Maybe<{
        __typename?: "WorkflowState";
    } & Pick<WorkflowState, "id">>;
    reviewWorkflowState?: Maybe<{
        __typename?: "WorkflowState";
    } & Pick<WorkflowState, "id">>;
    markedAsDuplicateWorkflowState?: Maybe<{
        __typename?: "WorkflowState";
    } & Pick<WorkflowState, "id">>;
    triageIssueState?: Maybe<{
        __typename?: "WorkflowState";
    } & Pick<WorkflowState, "id">>;
};
export declare type DocumentStepFragment = {
    __typename?: "DocumentStep";
} & Pick<DocumentStep, "clientId" | "step" | "version" | "updatedAt" | "archivedAt" | "createdAt" | "id">;
export declare type SyncDeltaResponseFragment = {
    __typename?: "SyncDeltaResponse";
} & Pick<SyncDeltaResponse, "updates" | "success" | "loadMore">;
export declare type SyncResponseFragment = {
    __typename?: "SyncResponse";
} & Pick<SyncResponse, "delta" | "state" | "lastSyncId" | "subscribedSyncGroups" | "databaseVersion">;
export declare type ArchiveResponseFragment = {
    __typename?: "ArchiveResponse";
} & Pick<ArchiveResponse, "archive" | "totalCount" | "databaseVersion">;
export declare type DependencyResponseFragment = {
    __typename?: "DependencyResponse";
} & Pick<DependencyResponse, "dependencies">;
export declare type SyncBatchResponseFragment = {
    __typename?: "SyncBatchResponse";
} & Pick<SyncBatchResponse, "models">;
export declare type TeamMembershipFragment = {
    __typename?: "TeamMembership";
} & Pick<TeamMembership, "updatedAt" | "archivedAt" | "createdAt" | "id" | "owner"> & {
    team: {
        __typename?: "Team";
    } & Pick<Team, "id">;
    user: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type OrganizationDomainFragment = {
    __typename?: "OrganizationDomain";
} & Pick<OrganizationDomain, "name" | "verificationEmail" | "verified" | "updatedAt" | "archivedAt" | "createdAt" | "id"> & {
    creator?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
export declare type GithubOAuthTokenPayloadFragment = {
    __typename?: "GithubOAuthTokenPayload";
} & Pick<GithubOAuthTokenPayload, "token"> & {
    organizations?: Maybe<Array<{
        __typename?: "GithubOrg";
    } & GithubOrgFragment>>;
};
export declare type CommitPayloadFragment = {
    __typename?: "CommitPayload";
} & Pick<CommitPayload, "added" | "id" | "message" | "modified" | "removed" | "timestamp" | "url">;
export declare type GoogleSheetsSettingsFragment = {
    __typename?: "GoogleSheetsSettings";
} & Pick<GoogleSheetsSettings, "sheetId" | "spreadsheetId" | "spreadsheetUrl" | "updatedIssuesAt">;
export declare type IntegrationResourceDataFragment = {
    __typename?: "IntegrationResourceData";
} & {
    githubCommit?: Maybe<{
        __typename?: "CommitPayload";
    } & CommitPayloadFragment>;
    githubPullRequest?: Maybe<{
        __typename?: "PullRequestPayload";
    } & PullRequestPayloadFragment>;
    gitlabMergeRequest?: Maybe<{
        __typename?: "PullRequestPayload";
    } & PullRequestPayloadFragment>;
    sentryIssue?: Maybe<{
        __typename?: "SentryIssuePayload";
    } & SentryIssuePayloadFragment>;
};
export declare type IntercomSettingsFragment = {
    __typename?: "IntercomSettings";
} & Pick<IntercomSettings, "sendNoteOnStatusChange" | "sendNoteOnComment">;
export declare type IssueRelationHistoryPayloadFragment = {
    __typename?: "IssueRelationHistoryPayload";
} & Pick<IssueRelationHistoryPayload, "identifier" | "type">;
export declare type JiraSettingsFragment = {
    __typename?: "JiraSettings";
} & {
    projects: Array<{
        __typename?: "JiraProjectData";
    } & JiraProjectDataFragment>;
    projectMapping?: Maybe<Array<{
        __typename?: "JiraLinearMapping";
    } & JiraLinearMappingFragment>>;
};
export declare type IssueLabelFragment = {
    __typename?: "IssueLabel";
} & Pick<IssueLabel, "color" | "description" | "name" | "updatedAt" | "archivedAt" | "createdAt" | "id"> & {
    team?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
    creator?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
export declare type JiraProjectDataFragment = {
    __typename?: "JiraProjectData";
} & Pick<JiraProjectData, "id" | "key" | "name">;
export declare type NotificationSubscriptionFragment = {
    __typename?: "NotificationSubscription";
} & Pick<NotificationSubscription, "updatedAt" | "archivedAt" | "createdAt" | "type" | "id"> & {
    project?: Maybe<{
        __typename?: "Project";
    } & Pick<Project, "id">>;
    team?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
    user: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type OauthClientFragment = {
    __typename?: "OauthClient";
} & Pick<OauthClient, "imageUrl" | "description" | "redirectUris" | "developer" | "clientId" | "name" | "clientSecret" | "updatedAt" | "webhookResourceTypes" | "archivedAt" | "createdAt" | "id" | "developerUrl" | "webhookUrl" | "publicEnabled">;
export declare type FigmaEmbedFragment = {
    __typename?: "FigmaEmbed";
} & Pick<FigmaEmbed, "lastModified" | "name" | "url" | "nodeName">;
export declare type UploadFileFragment = {
    __typename?: "UploadFile";
} & Pick<UploadFile, "assetUrl" | "contentType" | "filename" | "uploadUrl" | "size" | "metaData"> & {
    headers: Array<{
        __typename?: "UploadFileHeader";
    } & UploadFileHeaderFragment>;
};
export declare type AuthorizedApplicationFragment = {
    __typename?: "AuthorizedApplication";
} & Pick<AuthorizedApplication, "name" | "imageUrl" | "description" | "developer" | "appId" | "clientId" | "scope" | "developerUrl" | "webhooksEnabled">;
export declare type UserAuthorizedApplicationFragment = {
    __typename?: "UserAuthorizedApplication";
} & Pick<UserAuthorizedApplication, "name" | "imageUrl" | "description" | "developer" | "clientId" | "developerUrl" | "webhooksEnabled" | "createdByLinear" | "isAuthorized">;
export declare type ApplicationFragment = {
    __typename?: "Application";
} & Pick<Application, "name" | "imageUrl" | "description" | "developer" | "clientId" | "developerUrl">;
export declare type PullRequestPayloadFragment = {
    __typename?: "PullRequestPayload";
} & Pick<PullRequestPayload, "branch" | "closedAt" | "createdAt" | "draft" | "id" | "mergedAt" | "number" | "repoLogin" | "repoName" | "status" | "title" | "updatedAt" | "url" | "userId" | "userLogin">;
export declare type GithubOrgFragment = {
    __typename?: "GithubOrg";
} & Pick<GithubOrg, "id" | "login" | "name"> & {
    repositories: Array<{
        __typename?: "GithubRepo";
    } & GithubRepoFragment>;
};
export declare type GithubRepoFragment = {
    __typename?: "GithubRepo";
} & Pick<GithubRepo, "id" | "name">;
export declare type SentryIssuePayloadFragment = {
    __typename?: "SentryIssuePayload";
} & Pick<SentryIssuePayload, "issueId" | "actorId" | "projectId" | "firstSeen" | "webUrl" | "actorName" | "firstVersion" | "shortId" | "projectSlug" | "issueTitle" | "actorType">;
export declare type SentrySettingsFragment = {
    __typename?: "SentrySettings";
} & Pick<SentrySettings, "organizationSlug">;
export declare type SlackPostSettingsFragment = {
    __typename?: "SlackPostSettings";
} & Pick<SlackPostSettings, "channel" | "channelId" | "configurationUrl">;
export declare type IntegrationSettingsFragment = {
    __typename?: "IntegrationSettings";
} & {
    googleSheets?: Maybe<{
        __typename?: "GoogleSheetsSettings";
    } & GoogleSheetsSettingsFragment>;
    intercom?: Maybe<{
        __typename?: "IntercomSettings";
    } & IntercomSettingsFragment>;
    jira?: Maybe<{
        __typename?: "JiraSettings";
    } & JiraSettingsFragment>;
    sentry?: Maybe<{
        __typename?: "SentrySettings";
    } & SentrySettingsFragment>;
    slackPost?: Maybe<{
        __typename?: "SlackPostSettings";
    } & SlackPostSettingsFragment>;
    slackProjectPost?: Maybe<{
        __typename?: "SlackPostSettings";
    } & SlackPostSettingsFragment>;
    zendesk?: Maybe<{
        __typename?: "ZendeskSettings";
    } & ZendeskSettingsFragment>;
};
export declare type SamlConfigurationFragment = {
    __typename?: "SamlConfiguration";
} & Pick<SamlConfiguration, "ssoBinding" | "allowedDomains" | "ssoEndpoint" | "ssoSignAlgo" | "issuerEntityId" | "ssoSigningCert">;
export declare type UserSettingsFragment = {
    __typename?: "UserSettings";
} & Pick<UserSettings, "unsubscribedFrom" | "updatedAt" | "notificationPreferences" | "archivedAt" | "createdAt" | "id"> & {
    user: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type SubscriptionFragment = {
    __typename?: "Subscription";
} & Pick<Subscription, "canceledAt" | "nextBillingAt" | "updatedAt" | "seats" | "pendingChangeType" | "type" | "archivedAt" | "createdAt" | "id"> & {
    creator?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
export declare type JiraLinearMappingFragment = {
    __typename?: "JiraLinearMapping";
} & Pick<JiraLinearMapping, "jiraProjectId" | "linearTeamId">;
export declare type FavoriteFragment = {
    __typename?: "Favorite";
} & Pick<Favorite, "updatedAt" | "folderName" | "sortOrder" | "archivedAt" | "createdAt" | "type" | "id"> & {
    customView?: Maybe<{
        __typename?: "CustomView";
    } & Pick<CustomView, "id">>;
    cycle?: Maybe<{
        __typename?: "Cycle";
    } & Pick<Cycle, "id">>;
    document?: Maybe<{
        __typename?: "Document";
    } & Pick<Document, "id">>;
    issue?: Maybe<{
        __typename?: "Issue";
    } & Pick<Issue, "id">>;
    label?: Maybe<{
        __typename?: "IssueLabel";
    } & Pick<IssueLabel, "id">>;
    project?: Maybe<{
        __typename?: "Project";
    } & Pick<Project, "id">>;
    projectTeam?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
    user: {
        __typename?: "User";
    } & Pick<User, "id">;
    parent?: Maybe<{
        __typename?: "Favorite";
    } & Pick<Favorite, "id">>;
};
export declare type ViewPreferencesFragment = {
    __typename?: "ViewPreferences";
} & Pick<ViewPreferences, "updatedAt" | "archivedAt" | "createdAt" | "id" | "type" | "viewType">;
export declare type AuditEntryFragment = {
    __typename?: "AuditEntry";
} & Pick<AuditEntry, "metadata" | "countryCode" | "ip" | "actorId" | "updatedAt" | "archivedAt" | "createdAt" | "id" | "type"> & {
    actor?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
export declare type ZendeskSettingsFragment = {
    __typename?: "ZendeskSettings";
} & Pick<ZendeskSettings, "botUserId" | "url" | "subdomain">;
export declare type AttachmentFragment = {
    __typename?: "Attachment";
} & Pick<Attachment, "sourceType" | "subtitle" | "title" | "metadata" | "groupBySource" | "source" | "url" | "updatedAt" | "archivedAt" | "createdAt" | "id"> & {
    creator?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
    issue: {
        __typename?: "Issue";
    } & Pick<Issue, "id">;
};
export declare type ApiKeyConnectionFragment = {
    __typename?: "ApiKeyConnection";
} & {
    nodes: Array<{
        __typename?: "ApiKey";
    } & ApiKeyFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type ApiKeyPayloadFragment = {
    __typename?: "ApiKeyPayload";
} & Pick<ApiKeyPayload, "lastSyncId" | "success"> & {
    apiKey: {
        __typename?: "ApiKey";
    } & ApiKeyFragment;
};
export declare type ArchivePayloadFragment = {
    __typename?: "ArchivePayload";
} & Pick<ArchivePayload, "lastSyncId" | "success">;
export declare type AttachmentConnectionFragment = {
    __typename?: "AttachmentConnection";
} & {
    nodes: Array<{
        __typename?: "Attachment";
    } & AttachmentFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type AttachmentPayloadFragment = {
    __typename?: "AttachmentPayload";
} & Pick<AttachmentPayload, "lastSyncId" | "success"> & {
    attachment: {
        __typename?: "Attachment";
    } & Pick<Attachment, "id">;
};
export declare type AuditEntryConnectionFragment = {
    __typename?: "AuditEntryConnection";
} & {
    nodes: Array<{
        __typename?: "AuditEntry";
    } & AuditEntryFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type AuditEntryTypeFragment = {
    __typename?: "AuditEntryType";
} & Pick<AuditEntryType, "description" | "type">;
export declare type AuthResolverResponseFragment = {
    __typename?: "AuthResolverResponse";
} & Pick<AuthResolverResponse, "email" | "lastUsedOrganizationId" | "token" | "allowDomainAccess" | "id"> & {
    availableOrganizations?: Maybe<Array<{
        __typename?: "Organization";
    } & OrganizationFragment>>;
    users: Array<{
        __typename?: "User";
    } & UserFragment>;
};
export declare type BillingDetailsPayloadFragment = {
    __typename?: "BillingDetailsPayload";
} & Pick<BillingDetailsPayload, "email" | "success"> & {
    invoices: Array<{
        __typename?: "Invoice";
    } & InvoiceFragment>;
    paymentMethod?: Maybe<{
        __typename?: "Card";
    } & CardFragment>;
};
export declare type BillingEmailPayloadFragment = {
    __typename?: "BillingEmailPayload";
} & Pick<BillingEmailPayload, "email" | "success">;
export declare type CardFragment = {
    __typename?: "Card";
} & Pick<Card, "brand" | "last4">;
export declare type CollaborationDocumentUpdatePayloadFragment = {
    __typename?: "CollaborationDocumentUpdatePayload";
} & Pick<CollaborationDocumentUpdatePayload, "success"> & {
    steps?: Maybe<{
        __typename?: "StepsResponse";
    } & StepsResponseFragment>;
};
export declare type CommentConnectionFragment = {
    __typename?: "CommentConnection";
} & {
    nodes: Array<{
        __typename?: "Comment";
    } & CommentFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type CommentPayloadFragment = {
    __typename?: "CommentPayload";
} & Pick<CommentPayload, "lastSyncId" | "success"> & {
    comment: {
        __typename?: "Comment";
    } & Pick<Comment, "id">;
};
export declare type ContactPayloadFragment = {
    __typename?: "ContactPayload";
} & Pick<ContactPayload, "success">;
export declare type CreateCsvExportReportPayloadFragment = {
    __typename?: "CreateCsvExportReportPayload";
} & Pick<CreateCsvExportReportPayload, "success">;
export declare type CreateOrJoinOrganizationResponseFragment = {
    __typename?: "CreateOrJoinOrganizationResponse";
} & {
    user: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type CustomViewConnectionFragment = {
    __typename?: "CustomViewConnection";
} & {
    nodes: Array<{
        __typename?: "CustomView";
    } & CustomViewFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type CustomViewPayloadFragment = {
    __typename?: "CustomViewPayload";
} & Pick<CustomViewPayload, "lastSyncId" | "success"> & {
    customView: {
        __typename?: "CustomView";
    } & Pick<CustomView, "id">;
};
export declare type CycleConnectionFragment = {
    __typename?: "CycleConnection";
} & {
    nodes: Array<{
        __typename?: "Cycle";
    } & CycleFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type CyclePayloadFragment = {
    __typename?: "CyclePayload";
} & Pick<CyclePayload, "lastSyncId" | "success"> & {
    cycle?: Maybe<{
        __typename?: "Cycle";
    } & Pick<Cycle, "id">>;
};
export declare type DebugPayloadFragment = {
    __typename?: "DebugPayload";
} & Pick<DebugPayload, "success">;
export declare type DocumentConnectionFragment = {
    __typename?: "DocumentConnection";
} & {
    nodes: Array<{
        __typename?: "Document";
    } & DocumentFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type DocumentPayloadFragment = {
    __typename?: "DocumentPayload";
} & Pick<DocumentPayload, "lastSyncId" | "success"> & {
    document: {
        __typename?: "Document";
    } & Pick<Document, "id">;
};
export declare type DocumentVersionConnectionFragment = {
    __typename?: "DocumentVersionConnection";
} & {
    nodes: Array<{
        __typename?: "DocumentVersion";
    } & DocumentVersionFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type EmailSubscribePayloadFragment = {
    __typename?: "EmailSubscribePayload";
} & Pick<EmailSubscribePayload, "success">;
export declare type EmailUnsubscribePayloadFragment = {
    __typename?: "EmailUnsubscribePayload";
} & Pick<EmailUnsubscribePayload, "success">;
export declare type EmailUserAccountAuthChallengeResponseFragment = {
    __typename?: "EmailUserAccountAuthChallengeResponse";
} & Pick<EmailUserAccountAuthChallengeResponse, "authType" | "success">;
export declare type EmojiConnectionFragment = {
    __typename?: "EmojiConnection";
} & {
    nodes: Array<{
        __typename?: "Emoji";
    } & EmojiFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type EmojiPayloadFragment = {
    __typename?: "EmojiPayload";
} & Pick<EmojiPayload, "lastSyncId" | "success"> & {
    emoji: {
        __typename?: "Emoji";
    } & Pick<Emoji, "id">;
};
export declare type EventPayloadFragment = {
    __typename?: "EventPayload";
} & Pick<EventPayload, "success">;
export declare type FavoriteConnectionFragment = {
    __typename?: "FavoriteConnection";
} & {
    nodes: Array<{
        __typename?: "Favorite";
    } & FavoriteFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type FavoritePayloadFragment = {
    __typename?: "FavoritePayload";
} & Pick<FavoritePayload, "lastSyncId" | "success"> & {
    favorite: {
        __typename?: "Favorite";
    } & Pick<Favorite, "id">;
};
export declare type FeedbackPayloadFragment = {
    __typename?: "FeedbackPayload";
} & Pick<FeedbackPayload, "success">;
export declare type FigmaEmbedPayloadFragment = {
    __typename?: "FigmaEmbedPayload";
} & Pick<FigmaEmbedPayload, "success"> & {
    figmaEmbed?: Maybe<{
        __typename?: "FigmaEmbed";
    } & FigmaEmbedFragment>;
};
export declare type FrontAttachmentPayloadFragment = {
    __typename?: "FrontAttachmentPayload";
} & Pick<FrontAttachmentPayload, "lastSyncId" | "success">;
export declare type GitHubCommitIntegrationPayloadFragment = {
    __typename?: "GitHubCommitIntegrationPayload";
} & Pick<GitHubCommitIntegrationPayload, "lastSyncId" | "webhookSecret" | "success"> & {
    integration?: Maybe<{
        __typename?: "Integration";
    } & Pick<Integration, "id">>;
};
export declare type ImageUploadFromUrlPayloadFragment = {
    __typename?: "ImageUploadFromUrlPayload";
} & Pick<ImageUploadFromUrlPayload, "url" | "lastSyncId" | "success">;
export declare type IntegrationConnectionFragment = {
    __typename?: "IntegrationConnection";
} & {
    nodes: Array<{
        __typename?: "Integration";
    } & IntegrationFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type IntegrationPayloadFragment = {
    __typename?: "IntegrationPayload";
} & Pick<IntegrationPayload, "lastSyncId" | "success"> & {
    integration?: Maybe<{
        __typename?: "Integration";
    } & Pick<Integration, "id">>;
};
export declare type IntegrationResourceConnectionFragment = {
    __typename?: "IntegrationResourceConnection";
} & {
    nodes: Array<{
        __typename?: "IntegrationResource";
    } & IntegrationResourceFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type InvoiceFragment = {
    __typename?: "Invoice";
} & Pick<Invoice, "url" | "created" | "dueDate" | "total" | "status">;
export declare type IssueBatchPayloadFragment = {
    __typename?: "IssueBatchPayload";
} & Pick<IssueBatchPayload, "lastSyncId" | "success"> & {
    issues: Array<{
        __typename?: "Issue";
    } & IssueFragment>;
};
export declare type IssueConnectionFragment = {
    __typename?: "IssueConnection";
} & {
    nodes: Array<{
        __typename?: "Issue";
    } & IssueFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type IssueDescriptionHistoryFragment = {
    __typename?: "IssueDescriptionHistory";
} & Pick<IssueDescriptionHistory, "actorId" | "id" | "updatedAt" | "descriptionData" | "type">;
export declare type IssueDescriptionHistoryPayloadFragment = {
    __typename?: "IssueDescriptionHistoryPayload";
} & Pick<IssueDescriptionHistoryPayload, "success"> & {
    history?: Maybe<Array<{
        __typename?: "IssueDescriptionHistory";
    } & IssueDescriptionHistoryFragment>>;
};
export declare type IssueHistoryConnectionFragment = {
    __typename?: "IssueHistoryConnection";
} & {
    nodes: Array<{
        __typename?: "IssueHistory";
    } & IssueHistoryFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type IssueImportDeletePayloadFragment = {
    __typename?: "IssueImportDeletePayload";
} & Pick<IssueImportDeletePayload, "lastSyncId" | "success"> & {
    issueImport?: Maybe<{
        __typename?: "IssueImport";
    } & IssueImportFragment>;
};
export declare type IssueImportPayloadFragment = {
    __typename?: "IssueImportPayload";
} & Pick<IssueImportPayload, "lastSyncId" | "success"> & {
    issueImport?: Maybe<{
        __typename?: "IssueImport";
    } & IssueImportFragment>;
};
export declare type IssueLabelConnectionFragment = {
    __typename?: "IssueLabelConnection";
} & {
    nodes: Array<{
        __typename?: "IssueLabel";
    } & IssueLabelFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type IssueLabelPayloadFragment = {
    __typename?: "IssueLabelPayload";
} & Pick<IssueLabelPayload, "lastSyncId" | "success"> & {
    issueLabel: {
        __typename?: "IssueLabel";
    } & Pick<IssueLabel, "id">;
};
export declare type IssuePayloadFragment = {
    __typename?: "IssuePayload";
} & Pick<IssuePayload, "lastSyncId" | "success"> & {
    issue?: Maybe<{
        __typename?: "Issue";
    } & Pick<Issue, "id">>;
};
export declare type IssuePriorityValueFragment = {
    __typename?: "IssuePriorityValue";
} & Pick<IssuePriorityValue, "label" | "priority">;
export declare type IssueRelationConnectionFragment = {
    __typename?: "IssueRelationConnection";
} & {
    nodes: Array<{
        __typename?: "IssueRelation";
    } & IssueRelationFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type IssueRelationPayloadFragment = {
    __typename?: "IssueRelationPayload";
} & Pick<IssueRelationPayload, "lastSyncId" | "success"> & {
    issueRelation: {
        __typename?: "IssueRelation";
    } & Pick<IssueRelation, "id">;
};
export declare type MilestoneConnectionFragment = {
    __typename?: "MilestoneConnection";
} & {
    nodes: Array<{
        __typename?: "Milestone";
    } & MilestoneFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type MilestonePayloadFragment = {
    __typename?: "MilestonePayload";
} & Pick<MilestonePayload, "lastSyncId" | "success"> & {
    milestone?: Maybe<{
        __typename?: "Milestone";
    } & Pick<Milestone, "id">>;
};
export declare type NotificationConnectionFragment = {
    __typename?: "NotificationConnection";
} & {
    nodes: Array<{
        __typename?: "Notification";
    } & NotificationFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type NotificationPayloadFragment = {
    __typename?: "NotificationPayload";
} & Pick<NotificationPayload, "lastSyncId" | "success"> & {
    notification: {
        __typename?: "Notification";
    } & Pick<Notification, "id">;
};
export declare type NotificationSubscriptionConnectionFragment = {
    __typename?: "NotificationSubscriptionConnection";
} & {
    nodes: Array<{
        __typename?: "NotificationSubscription";
    } & NotificationSubscriptionFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type NotificationSubscriptionPayloadFragment = {
    __typename?: "NotificationSubscriptionPayload";
} & Pick<NotificationSubscriptionPayload, "lastSyncId" | "success"> & {
    notificationSubscription: {
        __typename?: "NotificationSubscription";
    } & Pick<NotificationSubscription, "id">;
};
export declare type OauthAuthStringAuthorizePayloadFragment = {
    __typename?: "OauthAuthStringAuthorizePayload";
} & Pick<OauthAuthStringAuthorizePayload, "success">;
export declare type OauthAuthStringChallengePayloadFragment = {
    __typename?: "OauthAuthStringChallengePayload";
} & Pick<OauthAuthStringChallengePayload, "authString" | "success">;
export declare type OauthAuthStringCheckPayloadFragment = {
    __typename?: "OauthAuthStringCheckPayload";
} & Pick<OauthAuthStringCheckPayload, "token" | "success">;
export declare type OauthClientPayloadFragment = {
    __typename?: "OauthClientPayload";
} & Pick<OauthClientPayload, "lastSyncId" | "success"> & {
    oauthClient: {
        __typename?: "OauthClient";
    } & OauthClientFragment;
};
export declare type OauthTokenRevokePayloadFragment = {
    __typename?: "OauthTokenRevokePayload";
} & Pick<OauthTokenRevokePayload, "success">;
export declare type OrganizationCancelDeletePayloadFragment = {
    __typename?: "OrganizationCancelDeletePayload";
} & Pick<OrganizationCancelDeletePayload, "success">;
export declare type OrganizationDeletePayloadFragment = {
    __typename?: "OrganizationDeletePayload";
} & Pick<OrganizationDeletePayload, "success">;
export declare type OrganizationDomainPayloadFragment = {
    __typename?: "OrganizationDomainPayload";
} & Pick<OrganizationDomainPayload, "lastSyncId" | "success"> & {
    organizationDomain: {
        __typename?: "OrganizationDomain";
    } & OrganizationDomainFragment;
};
export declare type OrganizationDomainSimplePayloadFragment = {
    __typename?: "OrganizationDomainSimplePayload";
} & Pick<OrganizationDomainSimplePayload, "success">;
export declare type OrganizationExistsPayloadFragment = {
    __typename?: "OrganizationExistsPayload";
} & Pick<OrganizationExistsPayload, "success" | "exists">;
export declare type OrganizationInviteConnectionFragment = {
    __typename?: "OrganizationInviteConnection";
} & {
    nodes: Array<{
        __typename?: "OrganizationInvite";
    } & OrganizationInviteFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type OrganizationInviteDetailsPayloadFragment = {
    __typename?: "OrganizationInviteDetailsPayload";
} & Pick<OrganizationInviteDetailsPayload, "organizationId" | "organizationName" | "email" | "inviter" | "organizationLogoUrl" | "createdAt" | "accepted" | "expired">;
export declare type OrganizationInvitePayloadFragment = {
    __typename?: "OrganizationInvitePayload";
} & Pick<OrganizationInvitePayload, "lastSyncId" | "success"> & {
    organizationInvite: {
        __typename?: "OrganizationInvite";
    } & Pick<OrganizationInvite, "id">;
};
export declare type OrganizationPayloadFragment = {
    __typename?: "OrganizationPayload";
} & Pick<OrganizationPayload, "lastSyncId" | "success">;
export declare type PageInfoFragment = {
    __typename?: "PageInfo";
} & Pick<PageInfo, "startCursor" | "endCursor" | "hasPreviousPage" | "hasNextPage">;
export declare type ProjectConnectionFragment = {
    __typename?: "ProjectConnection";
} & {
    nodes: Array<{
        __typename?: "Project";
    } & ProjectFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type ProjectLinkConnectionFragment = {
    __typename?: "ProjectLinkConnection";
} & {
    nodes: Array<{
        __typename?: "ProjectLink";
    } & ProjectLinkFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type ProjectLinkPayloadFragment = {
    __typename?: "ProjectLinkPayload";
} & Pick<ProjectLinkPayload, "lastSyncId" | "success"> & {
    projectLink: {
        __typename?: "ProjectLink";
    } & Pick<ProjectLink, "id">;
};
export declare type ProjectPayloadFragment = {
    __typename?: "ProjectPayload";
} & Pick<ProjectPayload, "lastSyncId" | "success"> & {
    project?: Maybe<{
        __typename?: "Project";
    } & Pick<Project, "id">>;
};
export declare type PushSubscriptionConnectionFragment = {
    __typename?: "PushSubscriptionConnection";
} & {
    nodes: Array<{
        __typename?: "PushSubscription";
    } & PushSubscriptionFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type PushSubscriptionPayloadFragment = {
    __typename?: "PushSubscriptionPayload";
} & Pick<PushSubscriptionPayload, "lastSyncId" | "success">;
export declare type PushSubscriptionTestPayloadFragment = {
    __typename?: "PushSubscriptionTestPayload";
} & Pick<PushSubscriptionTestPayload, "success">;
export declare type ReactionConnectionFragment = {
    __typename?: "ReactionConnection";
} & {
    nodes: Array<{
        __typename?: "Reaction";
    } & ReactionFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type ReactionPayloadFragment = {
    __typename?: "ReactionPayload";
} & Pick<ReactionPayload, "lastSyncId" | "success"> & {
    reaction: {
        __typename?: "Reaction";
    } & Pick<Reaction, "id">;
};
export declare type RotateSecretPayloadFragment = {
    __typename?: "RotateSecretPayload";
} & Pick<RotateSecretPayload, "lastSyncId" | "success">;
export declare type SsoUrlFromEmailResponseFragment = {
    __typename?: "SsoUrlFromEmailResponse";
} & Pick<SsoUrlFromEmailResponse, "samlSsoUrl" | "success">;
export declare type StepsResponseFragment = {
    __typename?: "StepsResponse";
} & Pick<StepsResponse, "version" | "clientIds" | "steps">;
export declare type SubscriptionPayloadFragment = {
    __typename?: "SubscriptionPayload";
} & Pick<SubscriptionPayload, "canceledAt" | "lastSyncId" | "success">;
export declare type SubscriptionSessionPayloadFragment = {
    __typename?: "SubscriptionSessionPayload";
} & Pick<SubscriptionSessionPayload, "session">;
export declare type SynchronizedPayloadFragment = {
    __typename?: "SynchronizedPayload";
} & Pick<SynchronizedPayload, "lastSyncId">;
export declare type TeamConnectionFragment = {
    __typename?: "TeamConnection";
} & {
    nodes: Array<{
        __typename?: "Team";
    } & TeamFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type TeamMembershipConnectionFragment = {
    __typename?: "TeamMembershipConnection";
} & {
    nodes: Array<{
        __typename?: "TeamMembership";
    } & TeamMembershipFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type TeamMembershipPayloadFragment = {
    __typename?: "TeamMembershipPayload";
} & Pick<TeamMembershipPayload, "lastSyncId" | "success"> & {
    teamMembership?: Maybe<{
        __typename?: "TeamMembership";
    } & Pick<TeamMembership, "id">>;
};
export declare type TeamPayloadFragment = {
    __typename?: "TeamPayload";
} & Pick<TeamPayload, "lastSyncId" | "success"> & {
    team?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
};
export declare type TemplateConnectionFragment = {
    __typename?: "TemplateConnection";
} & {
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type TemplatePayloadFragment = {
    __typename?: "TemplatePayload";
} & Pick<TemplatePayload, "lastSyncId" | "success"> & {
    template: {
        __typename?: "Template";
    } & Pick<Template, "id">;
};
export declare type UploadFileHeaderFragment = {
    __typename?: "UploadFileHeader";
} & Pick<UploadFileHeader, "key" | "value">;
export declare type UploadPayloadFragment = {
    __typename?: "UploadPayload";
} & Pick<UploadPayload, "lastSyncId" | "success"> & {
    uploadFile?: Maybe<{
        __typename?: "UploadFile";
    } & UploadFileFragment>;
};
export declare type UserAdminPayloadFragment = {
    __typename?: "UserAdminPayload";
} & Pick<UserAdminPayload, "success">;
export declare type UserConnectionFragment = {
    __typename?: "UserConnection";
} & {
    nodes: Array<{
        __typename?: "User";
    } & UserFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type UserPayloadFragment = {
    __typename?: "UserPayload";
} & Pick<UserPayload, "lastSyncId" | "success"> & {
    user?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
export declare type UserSettingsFlagPayloadFragment = {
    __typename?: "UserSettingsFlagPayload";
} & Pick<UserSettingsFlagPayload, "flag" | "value" | "lastSyncId" | "success">;
export declare type UserSettingsFlagsResetPayloadFragment = {
    __typename?: "UserSettingsFlagsResetPayload";
} & Pick<UserSettingsFlagsResetPayload, "lastSyncId" | "success">;
export declare type UserSettingsPayloadFragment = {
    __typename?: "UserSettingsPayload";
} & Pick<UserSettingsPayload, "lastSyncId" | "success">;
export declare type UserSubscribeToNewsletterPayloadFragment = {
    __typename?: "UserSubscribeToNewsletterPayload";
} & Pick<UserSubscribeToNewsletterPayload, "success">;
export declare type ViewPreferencesPayloadFragment = {
    __typename?: "ViewPreferencesPayload";
} & Pick<ViewPreferencesPayload, "lastSyncId" | "success"> & {
    viewPreferences: {
        __typename?: "ViewPreferences";
    } & ViewPreferencesFragment;
};
export declare type WebhookConnectionFragment = {
    __typename?: "WebhookConnection";
} & {
    nodes: Array<{
        __typename?: "Webhook";
    } & WebhookFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type WebhookPayloadFragment = {
    __typename?: "WebhookPayload";
} & Pick<WebhookPayload, "lastSyncId" | "success"> & {
    webhook: {
        __typename?: "Webhook";
    } & Pick<Webhook, "id">;
};
export declare type WorkflowStateConnectionFragment = {
    __typename?: "WorkflowStateConnection";
} & {
    nodes: Array<{
        __typename?: "WorkflowState";
    } & WorkflowStateFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type WorkflowStatePayloadFragment = {
    __typename?: "WorkflowStatePayload";
} & Pick<WorkflowStatePayload, "lastSyncId" | "success"> & {
    workflowState: {
        __typename?: "WorkflowState";
    } & Pick<WorkflowState, "id">;
};
export declare type AdministrableTeamsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<TeamFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type AdministrableTeamsQuery = {
    __typename?: "Query";
} & {
    administrableTeams: {
        __typename?: "TeamConnection";
    } & TeamConnectionFragment;
};
export declare type ApplicationWithAuthorizationQueryVariables = Exact<{
    clientId: Scalars["String"];
    redirectUri?: Maybe<Scalars["String"]>;
    scope: Array<Scalars["String"]> | Scalars["String"];
}>;
export declare type ApplicationWithAuthorizationQuery = {
    __typename?: "Query";
} & {
    applicationWithAuthorization: {
        __typename?: "UserAuthorizedApplication";
    } & UserAuthorizedApplicationFragment;
};
export declare type AttachmentQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type AttachmentQuery = {
    __typename?: "Query";
} & {
    attachment: {
        __typename?: "Attachment";
    } & AttachmentFragment;
};
export declare type AttachmentIssueQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type AttachmentIssueQuery = {
    __typename?: "Query";
} & {
    attachmentIssue: {
        __typename?: "Issue";
    } & IssueFragment;
};
export declare type AttachmentIssue_AttachmentsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<AttachmentFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type AttachmentIssue_AttachmentsQuery = {
    __typename?: "Query";
} & {
    attachmentIssue: {
        __typename?: "Issue";
    } & {
        attachments: {
            __typename?: "AttachmentConnection";
        } & AttachmentConnectionFragment;
    };
};
export declare type AttachmentIssue_ChildrenQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type AttachmentIssue_ChildrenQuery = {
    __typename?: "Query";
} & {
    attachmentIssue: {
        __typename?: "Issue";
    } & {
        children: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type AttachmentIssue_CommentsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<CommentFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type AttachmentIssue_CommentsQuery = {
    __typename?: "Query";
} & {
    attachmentIssue: {
        __typename?: "Issue";
    } & {
        comments: {
            __typename?: "CommentConnection";
        } & CommentConnectionFragment;
    };
};
export declare type AttachmentIssue_HistoryQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type AttachmentIssue_HistoryQuery = {
    __typename?: "Query";
} & {
    attachmentIssue: {
        __typename?: "Issue";
    } & {
        history: {
            __typename?: "IssueHistoryConnection";
        } & IssueHistoryConnectionFragment;
    };
};
export declare type AttachmentIssue_InverseRelationsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type AttachmentIssue_InverseRelationsQuery = {
    __typename?: "Query";
} & {
    attachmentIssue: {
        __typename?: "Issue";
    } & {
        inverseRelations: {
            __typename?: "IssueRelationConnection";
        } & IssueRelationConnectionFragment;
    };
};
export declare type AttachmentIssue_LabelsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueLabelFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type AttachmentIssue_LabelsQuery = {
    __typename?: "Query";
} & {
    attachmentIssue: {
        __typename?: "Issue";
    } & {
        labels: {
            __typename?: "IssueLabelConnection";
        } & IssueLabelConnectionFragment;
    };
};
export declare type AttachmentIssue_RelationsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type AttachmentIssue_RelationsQuery = {
    __typename?: "Query";
} & {
    attachmentIssue: {
        __typename?: "Issue";
    } & {
        relations: {
            __typename?: "IssueRelationConnection";
        } & IssueRelationConnectionFragment;
    };
};
export declare type AttachmentIssue_SubscribersQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<UserFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    includeDisabled?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type AttachmentIssue_SubscribersQuery = {
    __typename?: "Query";
} & {
    attachmentIssue: {
        __typename?: "Issue";
    } & {
        subscribers: {
            __typename?: "UserConnection";
        } & UserConnectionFragment;
    };
};
export declare type AttachmentsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<AttachmentFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type AttachmentsQuery = {
    __typename?: "Query";
} & {
    attachments: {
        __typename?: "AttachmentConnection";
    } & AttachmentConnectionFragment;
};
export declare type AttachmentsForUrlQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
    url: Scalars["String"];
}>;
export declare type AttachmentsForUrlQuery = {
    __typename?: "Query";
} & {
    attachmentsForURL: {
        __typename?: "AttachmentConnection";
    } & AttachmentConnectionFragment;
};
export declare type AuditEntriesQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<AuditEntryFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type AuditEntriesQuery = {
    __typename?: "Query";
} & {
    auditEntries: {
        __typename?: "AuditEntryConnection";
    } & AuditEntryConnectionFragment;
};
export declare type AuditEntryTypesQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type AuditEntryTypesQuery = {
    __typename?: "Query";
} & {
    auditEntryTypes: Array<{
        __typename?: "AuditEntryType";
    } & AuditEntryTypeFragment>;
};
export declare type AuthorizedApplicationsQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type AuthorizedApplicationsQuery = {
    __typename?: "Query";
} & {
    authorizedApplications: Array<{
        __typename?: "AuthorizedApplication";
    } & AuthorizedApplicationFragment>;
};
export declare type AvailableUsersQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type AvailableUsersQuery = {
    __typename?: "Query";
} & {
    availableUsers: {
        __typename?: "AuthResolverResponse";
    } & AuthResolverResponseFragment;
};
export declare type BillingDetailsQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type BillingDetailsQuery = {
    __typename?: "Query";
} & {
    billingDetails: {
        __typename?: "BillingDetailsPayload";
    } & BillingDetailsPayloadFragment;
};
export declare type BillingDetails_PaymentMethodQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type BillingDetails_PaymentMethodQuery = {
    __typename?: "Query";
} & {
    billingDetails: {
        __typename?: "BillingDetailsPayload";
    } & {
        paymentMethod?: Maybe<{
            __typename?: "Card";
        } & CardFragment>;
    };
};
export declare type CollaborativeDocumentJoinQueryVariables = Exact<{
    clientId: Scalars["String"];
    issueId: Scalars["String"];
    version: Scalars["Int"];
}>;
export declare type CollaborativeDocumentJoinQuery = {
    __typename?: "Query";
} & {
    collaborativeDocumentJoin: {
        __typename?: "CollaborationDocumentUpdatePayload";
    } & CollaborationDocumentUpdatePayloadFragment;
};
export declare type CollaborativeDocumentJoin_StepsQueryVariables = Exact<{
    clientId: Scalars["String"];
    issueId: Scalars["String"];
    version: Scalars["Int"];
}>;
export declare type CollaborativeDocumentJoin_StepsQuery = {
    __typename?: "Query";
} & {
    collaborativeDocumentJoin: {
        __typename?: "CollaborationDocumentUpdatePayload";
    } & {
        steps?: Maybe<{
            __typename?: "StepsResponse";
        } & StepsResponseFragment>;
    };
};
export declare type CommentQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type CommentQuery = {
    __typename?: "Query";
} & {
    comment: {
        __typename?: "Comment";
    } & CommentFragment;
};
export declare type CommentsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<CommentFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type CommentsQuery = {
    __typename?: "Query";
} & {
    comments: {
        __typename?: "CommentConnection";
    } & CommentConnectionFragment;
};
export declare type CustomViewQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type CustomViewQuery = {
    __typename?: "Query";
} & {
    customView: {
        __typename?: "CustomView";
    } & CustomViewFragment;
};
export declare type CustomViewsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type CustomViewsQuery = {
    __typename?: "Query";
} & {
    customViews: {
        __typename?: "CustomViewConnection";
    } & CustomViewConnectionFragment;
};
export declare type CycleQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type CycleQuery = {
    __typename?: "Query";
} & {
    cycle: {
        __typename?: "Cycle";
    } & CycleFragment;
};
export declare type Cycle_IssuesQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Cycle_IssuesQuery = {
    __typename?: "Query";
} & {
    cycle: {
        __typename?: "Cycle";
    } & {
        issues: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type Cycle_UncompletedIssuesUponCloseQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Cycle_UncompletedIssuesUponCloseQuery = {
    __typename?: "Query";
} & {
    cycle: {
        __typename?: "Cycle";
    } & {
        uncompletedIssuesUponClose: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type CyclesQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<CycleFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type CyclesQuery = {
    __typename?: "Query";
} & {
    cycles: {
        __typename?: "CycleConnection";
    } & CycleConnectionFragment;
};
export declare type DocumentQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type DocumentQuery = {
    __typename?: "Query";
} & {
    document: {
        __typename?: "Document";
    } & DocumentFragment;
};
export declare type DocumentsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type DocumentsQuery = {
    __typename?: "Query";
} & {
    documents: {
        __typename?: "DocumentConnection";
    } & DocumentConnectionFragment;
};
export declare type EmojiQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type EmojiQuery = {
    __typename?: "Query";
} & {
    emoji: {
        __typename?: "Emoji";
    } & EmojiFragment;
};
export declare type EmojisQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type EmojisQuery = {
    __typename?: "Query";
} & {
    emojis: {
        __typename?: "EmojiConnection";
    } & EmojiConnectionFragment;
};
export declare type FavoriteQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type FavoriteQuery = {
    __typename?: "Query";
} & {
    favorite: {
        __typename?: "Favorite";
    } & FavoriteFragment;
};
export declare type Favorite_ChildrenQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Favorite_ChildrenQuery = {
    __typename?: "Query";
} & {
    favorite: {
        __typename?: "Favorite";
    } & {
        children: {
            __typename?: "FavoriteConnection";
        } & FavoriteConnectionFragment;
    };
};
export declare type FavoritesQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type FavoritesQuery = {
    __typename?: "Query";
} & {
    favorites: {
        __typename?: "FavoriteConnection";
    } & FavoriteConnectionFragment;
};
export declare type FigmaEmbedInfoQueryVariables = Exact<{
    fileId: Scalars["String"];
    nodeId?: Maybe<Scalars["String"]>;
}>;
export declare type FigmaEmbedInfoQuery = {
    __typename?: "Query";
} & {
    figmaEmbedInfo: {
        __typename?: "FigmaEmbedPayload";
    } & FigmaEmbedPayloadFragment;
};
export declare type FigmaEmbedInfo_FigmaEmbedQueryVariables = Exact<{
    fileId: Scalars["String"];
    nodeId?: Maybe<Scalars["String"]>;
}>;
export declare type FigmaEmbedInfo_FigmaEmbedQuery = {
    __typename?: "Query";
} & {
    figmaEmbedInfo: {
        __typename?: "FigmaEmbedPayload";
    } & {
        figmaEmbed?: Maybe<{
            __typename?: "FigmaEmbed";
        } & FigmaEmbedFragment>;
    };
};
export declare type IntegrationQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type IntegrationQuery = {
    __typename?: "Query";
} & {
    integration: {
        __typename?: "Integration";
    } & IntegrationFragment;
};
export declare type IntegrationsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type IntegrationsQuery = {
    __typename?: "Query";
} & {
    integrations: {
        __typename?: "IntegrationConnection";
    } & IntegrationConnectionFragment;
};
export declare type IssueQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type IssueQuery = {
    __typename?: "Query";
} & {
    issue: {
        __typename?: "Issue";
    } & IssueFragment;
};
export declare type Issue_AttachmentsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<AttachmentFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Issue_AttachmentsQuery = {
    __typename?: "Query";
} & {
    issue: {
        __typename?: "Issue";
    } & {
        attachments: {
            __typename?: "AttachmentConnection";
        } & AttachmentConnectionFragment;
    };
};
export declare type Issue_ChildrenQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Issue_ChildrenQuery = {
    __typename?: "Query";
} & {
    issue: {
        __typename?: "Issue";
    } & {
        children: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type Issue_CommentsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<CommentFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Issue_CommentsQuery = {
    __typename?: "Query";
} & {
    issue: {
        __typename?: "Issue";
    } & {
        comments: {
            __typename?: "CommentConnection";
        } & CommentConnectionFragment;
    };
};
export declare type Issue_HistoryQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Issue_HistoryQuery = {
    __typename?: "Query";
} & {
    issue: {
        __typename?: "Issue";
    } & {
        history: {
            __typename?: "IssueHistoryConnection";
        } & IssueHistoryConnectionFragment;
    };
};
export declare type Issue_InverseRelationsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Issue_InverseRelationsQuery = {
    __typename?: "Query";
} & {
    issue: {
        __typename?: "Issue";
    } & {
        inverseRelations: {
            __typename?: "IssueRelationConnection";
        } & IssueRelationConnectionFragment;
    };
};
export declare type Issue_LabelsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueLabelFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Issue_LabelsQuery = {
    __typename?: "Query";
} & {
    issue: {
        __typename?: "Issue";
    } & {
        labels: {
            __typename?: "IssueLabelConnection";
        } & IssueLabelConnectionFragment;
    };
};
export declare type Issue_RelationsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Issue_RelationsQuery = {
    __typename?: "Query";
} & {
    issue: {
        __typename?: "Issue";
    } & {
        relations: {
            __typename?: "IssueRelationConnection";
        } & IssueRelationConnectionFragment;
    };
};
export declare type Issue_SubscribersQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<UserFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    includeDisabled?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Issue_SubscribersQuery = {
    __typename?: "Query";
} & {
    issue: {
        __typename?: "Issue";
    } & {
        subscribers: {
            __typename?: "UserConnection";
        } & UserConnectionFragment;
    };
};
export declare type IssueImportFinishGithubOAuthQueryVariables = Exact<{
    code: Scalars["String"];
}>;
export declare type IssueImportFinishGithubOAuthQuery = {
    __typename?: "Query";
} & {
    issueImportFinishGithubOAuth: {
        __typename?: "GithubOAuthTokenPayload";
    } & GithubOAuthTokenPayloadFragment;
};
export declare type IssueLabelQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type IssueLabelQuery = {
    __typename?: "Query";
} & {
    issueLabel: {
        __typename?: "IssueLabel";
    } & IssueLabelFragment;
};
export declare type IssueLabel_IssuesQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type IssueLabel_IssuesQuery = {
    __typename?: "Query";
} & {
    issueLabel: {
        __typename?: "IssueLabel";
    } & {
        issues: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type IssueLabelsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueLabelFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type IssueLabelsQuery = {
    __typename?: "Query";
} & {
    issueLabels: {
        __typename?: "IssueLabelConnection";
    } & IssueLabelConnectionFragment;
};
export declare type IssuePriorityValuesQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type IssuePriorityValuesQuery = {
    __typename?: "Query";
} & {
    issuePriorityValues: Array<{
        __typename?: "IssuePriorityValue";
    } & IssuePriorityValueFragment>;
};
export declare type IssueRelationQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type IssueRelationQuery = {
    __typename?: "Query";
} & {
    issueRelation: {
        __typename?: "IssueRelation";
    } & IssueRelationFragment;
};
export declare type IssueRelationsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type IssueRelationsQuery = {
    __typename?: "Query";
} & {
    issueRelations: {
        __typename?: "IssueRelationConnection";
    } & IssueRelationConnectionFragment;
};
export declare type IssueSearchQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
    query: Scalars["String"];
}>;
export declare type IssueSearchQuery = {
    __typename?: "Query";
} & {
    issueSearch: {
        __typename?: "IssueConnection";
    } & IssueConnectionFragment;
};
export declare type IssuesQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type IssuesQuery = {
    __typename?: "Query";
} & {
    issues: {
        __typename?: "IssueConnection";
    } & IssueConnectionFragment;
};
export declare type MilestoneQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type MilestoneQuery = {
    __typename?: "Query";
} & {
    milestone: {
        __typename?: "Milestone";
    } & MilestoneFragment;
};
export declare type Milestone_ProjectsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<ProjectFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Milestone_ProjectsQuery = {
    __typename?: "Query";
} & {
    milestone: {
        __typename?: "Milestone";
    } & {
        projects: {
            __typename?: "ProjectConnection";
        } & ProjectConnectionFragment;
    };
};
export declare type MilestonesQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<MilestoneFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type MilestonesQuery = {
    __typename?: "Query";
} & {
    milestones: {
        __typename?: "MilestoneConnection";
    } & MilestoneConnectionFragment;
};
export declare type NotificationQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type NotificationQuery = {
    __typename?: "Query";
} & {
    notification: {
        __typename?: "Notification";
    } & NotificationFragment;
};
export declare type NotificationSubscriptionQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type NotificationSubscriptionQuery = {
    __typename?: "Query";
} & {
    notificationSubscription: {
        __typename?: "NotificationSubscription";
    } & NotificationSubscriptionFragment;
};
export declare type NotificationSubscriptionsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type NotificationSubscriptionsQuery = {
    __typename?: "Query";
} & {
    notificationSubscriptions: {
        __typename?: "NotificationSubscriptionConnection";
    } & NotificationSubscriptionConnectionFragment;
};
export declare type NotificationsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type NotificationsQuery = {
    __typename?: "Query";
} & {
    notifications: {
        __typename?: "NotificationConnection";
    } & NotificationConnectionFragment;
};
export declare type OrganizationQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type OrganizationQuery = {
    __typename?: "Query";
} & {
    organization: {
        __typename?: "Organization";
    } & OrganizationFragment;
};
export declare type Organization_IntegrationsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Organization_IntegrationsQuery = {
    __typename?: "Query";
} & {
    organization: {
        __typename?: "Organization";
    } & {
        integrations: {
            __typename?: "IntegrationConnection";
        } & IntegrationConnectionFragment;
    };
};
export declare type Organization_LabelsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueLabelFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Organization_LabelsQuery = {
    __typename?: "Query";
} & {
    organization: {
        __typename?: "Organization";
    } & {
        labels: {
            __typename?: "IssueLabelConnection";
        } & IssueLabelConnectionFragment;
    };
};
export declare type Organization_MilestonesQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<MilestoneFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Organization_MilestonesQuery = {
    __typename?: "Query";
} & {
    organization: {
        __typename?: "Organization";
    } & {
        milestones: {
            __typename?: "MilestoneConnection";
        } & MilestoneConnectionFragment;
    };
};
export declare type Organization_TeamsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<TeamFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Organization_TeamsQuery = {
    __typename?: "Query";
} & {
    organization: {
        __typename?: "Organization";
    } & {
        teams: {
            __typename?: "TeamConnection";
        } & TeamConnectionFragment;
    };
};
export declare type Organization_TemplatesQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Organization_TemplatesQuery = {
    __typename?: "Query";
} & {
    organization: {
        __typename?: "Organization";
    } & {
        templates: {
            __typename?: "TemplateConnection";
        } & TemplateConnectionFragment;
    };
};
export declare type Organization_UsersQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    includeDisabled?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Organization_UsersQuery = {
    __typename?: "Query";
} & {
    organization: {
        __typename?: "Organization";
    } & {
        users: {
            __typename?: "UserConnection";
        } & UserConnectionFragment;
    };
};
export declare type OrganizationExistsQueryVariables = Exact<{
    urlKey: Scalars["String"];
}>;
export declare type OrganizationExistsQuery = {
    __typename?: "Query";
} & {
    organizationExists: {
        __typename?: "OrganizationExistsPayload";
    } & OrganizationExistsPayloadFragment;
};
export declare type OrganizationInviteQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type OrganizationInviteQuery = {
    __typename?: "Query";
} & {
    organizationInvite: {
        __typename?: "OrganizationInvite";
    } & OrganizationInviteFragment;
};
export declare type OrganizationInviteDetailsQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type OrganizationInviteDetailsQuery = {
    __typename?: "Query";
} & {
    organizationInviteDetails: {
        __typename?: "OrganizationInviteDetailsPayload";
    } & OrganizationInviteDetailsPayloadFragment;
};
export declare type OrganizationInvitesQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type OrganizationInvitesQuery = {
    __typename?: "Query";
} & {
    organizationInvites: {
        __typename?: "OrganizationInviteConnection";
    } & OrganizationInviteConnectionFragment;
};
export declare type ProjectQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type ProjectQuery = {
    __typename?: "Query";
} & {
    project: {
        __typename?: "Project";
    } & ProjectFragment;
};
export declare type Project_DocumentsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Project_DocumentsQuery = {
    __typename?: "Query";
} & {
    project: {
        __typename?: "Project";
    } & {
        documents: {
            __typename?: "DocumentConnection";
        } & DocumentConnectionFragment;
    };
};
export declare type Project_IssuesQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Project_IssuesQuery = {
    __typename?: "Query";
} & {
    project: {
        __typename?: "Project";
    } & {
        issues: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type Project_LinksQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Project_LinksQuery = {
    __typename?: "Query";
} & {
    project: {
        __typename?: "Project";
    } & {
        links: {
            __typename?: "ProjectLinkConnection";
        } & ProjectLinkConnectionFragment;
    };
};
export declare type Project_MembersQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<UserFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    includeDisabled?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Project_MembersQuery = {
    __typename?: "Query";
} & {
    project: {
        __typename?: "Project";
    } & {
        members: {
            __typename?: "UserConnection";
        } & UserConnectionFragment;
    };
};
export declare type Project_TeamsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<TeamFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Project_TeamsQuery = {
    __typename?: "Query";
} & {
    project: {
        __typename?: "Project";
    } & {
        teams: {
            __typename?: "TeamConnection";
        } & TeamConnectionFragment;
    };
};
export declare type ProjectLinkQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type ProjectLinkQuery = {
    __typename?: "Query";
} & {
    projectLink: {
        __typename?: "ProjectLink";
    } & ProjectLinkFragment;
};
export declare type ProjectLinksQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type ProjectLinksQuery = {
    __typename?: "Query";
} & {
    projectLinks: {
        __typename?: "ProjectLinkConnection";
    } & ProjectLinkConnectionFragment;
};
export declare type ProjectsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<ProjectFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type ProjectsQuery = {
    __typename?: "Query";
} & {
    projects: {
        __typename?: "ProjectConnection";
    } & ProjectConnectionFragment;
};
export declare type PushSubscriptionTestQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type PushSubscriptionTestQuery = {
    __typename?: "Query";
} & {
    pushSubscriptionTest: {
        __typename?: "PushSubscriptionTestPayload";
    } & PushSubscriptionTestPayloadFragment;
};
export declare type ReactionQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type ReactionQuery = {
    __typename?: "Query";
} & {
    reaction: {
        __typename?: "Reaction";
    } & ReactionFragment;
};
export declare type ReactionsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type ReactionsQuery = {
    __typename?: "Query";
} & {
    reactions: {
        __typename?: "ReactionConnection";
    } & ReactionConnectionFragment;
};
export declare type SsoUrlFromEmailQueryVariables = Exact<{
    email: Scalars["String"];
    isDesktop?: Maybe<Scalars["Boolean"]>;
}>;
export declare type SsoUrlFromEmailQuery = {
    __typename?: "Query";
} & {
    ssoUrlFromEmail: {
        __typename?: "SsoUrlFromEmailResponse";
    } & SsoUrlFromEmailResponseFragment;
};
export declare type SubscriptionQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type SubscriptionQuery = {
    __typename?: "Query";
} & {
    subscription?: Maybe<{
        __typename?: "Subscription";
    } & SubscriptionFragment>;
};
export declare type TeamQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type TeamQuery = {
    __typename?: "Query";
} & {
    team: {
        __typename?: "Team";
    } & TeamFragment;
};
export declare type Team_CyclesQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<CycleFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Team_CyclesQuery = {
    __typename?: "Query";
} & {
    team: {
        __typename?: "Team";
    } & {
        cycles: {
            __typename?: "CycleConnection";
        } & CycleConnectionFragment;
    };
};
export declare type Team_IssuesQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Team_IssuesQuery = {
    __typename?: "Query";
} & {
    team: {
        __typename?: "Team";
    } & {
        issues: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type Team_LabelsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueLabelFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Team_LabelsQuery = {
    __typename?: "Query";
} & {
    team: {
        __typename?: "Team";
    } & {
        labels: {
            __typename?: "IssueLabelConnection";
        } & IssueLabelConnectionFragment;
    };
};
export declare type Team_MembersQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<UserFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    includeDisabled?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Team_MembersQuery = {
    __typename?: "Query";
} & {
    team: {
        __typename?: "Team";
    } & {
        members: {
            __typename?: "UserConnection";
        } & UserConnectionFragment;
    };
};
export declare type Team_MembershipsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Team_MembershipsQuery = {
    __typename?: "Query";
} & {
    team: {
        __typename?: "Team";
    } & {
        memberships: {
            __typename?: "TeamMembershipConnection";
        } & TeamMembershipConnectionFragment;
    };
};
export declare type Team_ProjectsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<ProjectFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Team_ProjectsQuery = {
    __typename?: "Query";
} & {
    team: {
        __typename?: "Team";
    } & {
        projects: {
            __typename?: "ProjectConnection";
        } & ProjectConnectionFragment;
    };
};
export declare type Team_StatesQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<WorkflowStateFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Team_StatesQuery = {
    __typename?: "Query";
} & {
    team: {
        __typename?: "Team";
    } & {
        states: {
            __typename?: "WorkflowStateConnection";
        } & WorkflowStateConnectionFragment;
    };
};
export declare type Team_TemplatesQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Team_TemplatesQuery = {
    __typename?: "Query";
} & {
    team: {
        __typename?: "Team";
    } & {
        templates: {
            __typename?: "TemplateConnection";
        } & TemplateConnectionFragment;
    };
};
export declare type Team_WebhooksQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Team_WebhooksQuery = {
    __typename?: "Query";
} & {
    team: {
        __typename?: "Team";
    } & {
        webhooks: {
            __typename?: "WebhookConnection";
        } & WebhookConnectionFragment;
    };
};
export declare type TeamMembershipQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type TeamMembershipQuery = {
    __typename?: "Query";
} & {
    teamMembership: {
        __typename?: "TeamMembership";
    } & TeamMembershipFragment;
};
export declare type TeamMembershipsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type TeamMembershipsQuery = {
    __typename?: "Query";
} & {
    teamMemberships: {
        __typename?: "TeamMembershipConnection";
    } & TeamMembershipConnectionFragment;
};
export declare type TeamsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<TeamFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type TeamsQuery = {
    __typename?: "Query";
} & {
    teams: {
        __typename?: "TeamConnection";
    } & TeamConnectionFragment;
};
export declare type TemplateQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type TemplateQuery = {
    __typename?: "Query";
} & {
    template: {
        __typename?: "Template";
    } & TemplateFragment;
};
export declare type TemplatesQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type TemplatesQuery = {
    __typename?: "Query";
} & {
    templates: Array<{
        __typename?: "Template";
    } & TemplateFragment>;
};
export declare type UserQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type UserQuery = {
    __typename?: "Query";
} & {
    user: {
        __typename?: "User";
    } & UserFragment;
};
export declare type User_AssignedIssuesQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type User_AssignedIssuesQuery = {
    __typename?: "Query";
} & {
    user: {
        __typename?: "User";
    } & {
        assignedIssues: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type User_CreatedIssuesQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type User_CreatedIssuesQuery = {
    __typename?: "Query";
} & {
    user: {
        __typename?: "User";
    } & {
        createdIssues: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type User_TeamMembershipsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type User_TeamMembershipsQuery = {
    __typename?: "Query";
} & {
    user: {
        __typename?: "User";
    } & {
        teamMemberships: {
            __typename?: "TeamMembershipConnection";
        } & TeamMembershipConnectionFragment;
    };
};
export declare type User_TeamsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<TeamFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type User_TeamsQuery = {
    __typename?: "Query";
} & {
    user: {
        __typename?: "User";
    } & {
        teams: {
            __typename?: "TeamConnection";
        } & TeamConnectionFragment;
    };
};
export declare type UserSettingsQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type UserSettingsQuery = {
    __typename?: "Query";
} & {
    userSettings: {
        __typename?: "UserSettings";
    } & UserSettingsFragment;
};
export declare type UsersQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<UserFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    includeDisabled?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type UsersQuery = {
    __typename?: "Query";
} & {
    users: {
        __typename?: "UserConnection";
    } & UserConnectionFragment;
};
export declare type ViewerQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type ViewerQuery = {
    __typename?: "Query";
} & {
    viewer: {
        __typename?: "User";
    } & UserFragment;
};
export declare type Viewer_AssignedIssuesQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Viewer_AssignedIssuesQuery = {
    __typename?: "Query";
} & {
    viewer: {
        __typename?: "User";
    } & {
        assignedIssues: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type Viewer_CreatedIssuesQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Viewer_CreatedIssuesQuery = {
    __typename?: "Query";
} & {
    viewer: {
        __typename?: "User";
    } & {
        createdIssues: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type Viewer_TeamMembershipsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Viewer_TeamMembershipsQuery = {
    __typename?: "Query";
} & {
    viewer: {
        __typename?: "User";
    } & {
        teamMemberships: {
            __typename?: "TeamMembershipConnection";
        } & TeamMembershipConnectionFragment;
    };
};
export declare type Viewer_TeamsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<TeamFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Viewer_TeamsQuery = {
    __typename?: "Query";
} & {
    viewer: {
        __typename?: "User";
    } & {
        teams: {
            __typename?: "TeamConnection";
        } & TeamConnectionFragment;
    };
};
export declare type WebhookQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type WebhookQuery = {
    __typename?: "Query";
} & {
    webhook: {
        __typename?: "Webhook";
    } & WebhookFragment;
};
export declare type WebhooksQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type WebhooksQuery = {
    __typename?: "Query";
} & {
    webhooks: {
        __typename?: "WebhookConnection";
    } & WebhookConnectionFragment;
};
export declare type WorkflowStateQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type WorkflowStateQuery = {
    __typename?: "Query";
} & {
    workflowState: {
        __typename?: "WorkflowState";
    } & WorkflowStateFragment;
};
export declare type WorkflowState_IssuesQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type WorkflowState_IssuesQuery = {
    __typename?: "Query";
} & {
    workflowState: {
        __typename?: "WorkflowState";
    } & {
        issues: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type WorkflowStatesQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<WorkflowStateFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type WorkflowStatesQuery = {
    __typename?: "Query";
} & {
    workflowStates: {
        __typename?: "WorkflowStateConnection";
    } & WorkflowStateConnectionFragment;
};
export declare type AttachmentArchiveMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type AttachmentArchiveMutation = {
    __typename?: "Mutation";
} & {
    attachmentArchive: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type AttachmentCreateMutationVariables = Exact<{
    input: AttachmentCreateInput;
}>;
export declare type AttachmentCreateMutation = {
    __typename?: "Mutation";
} & {
    attachmentCreate: {
        __typename?: "AttachmentPayload";
    } & AttachmentPayloadFragment;
};
export declare type AttachmentDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type AttachmentDeleteMutation = {
    __typename?: "Mutation";
} & {
    attachmentDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type AttachmentLinkFrontMutationVariables = Exact<{
    conversationId: Scalars["String"];
    issueId: Scalars["String"];
}>;
export declare type AttachmentLinkFrontMutation = {
    __typename?: "Mutation";
} & {
    attachmentLinkFront: {
        __typename?: "FrontAttachmentPayload";
    } & FrontAttachmentPayloadFragment;
};
export declare type AttachmentLinkIntercomMutationVariables = Exact<{
    conversationId: Scalars["String"];
    issueId: Scalars["String"];
}>;
export declare type AttachmentLinkIntercomMutation = {
    __typename?: "Mutation";
} & {
    attachmentLinkIntercom: {
        __typename?: "AttachmentPayload";
    } & AttachmentPayloadFragment;
};
export declare type AttachmentLinkJiraIssueMutationVariables = Exact<{
    issueId: Scalars["String"];
    jiraIssueId: Scalars["String"];
}>;
export declare type AttachmentLinkJiraIssueMutation = {
    __typename?: "Mutation";
} & {
    attachmentLinkJiraIssue: {
        __typename?: "AttachmentPayload";
    } & AttachmentPayloadFragment;
};
export declare type AttachmentLinkUrlMutationVariables = Exact<{
    issueId: Scalars["String"];
    title?: Maybe<Scalars["String"]>;
    url: Scalars["String"];
}>;
export declare type AttachmentLinkUrlMutation = {
    __typename?: "Mutation";
} & {
    attachmentLinkURL: {
        __typename?: "AttachmentPayload";
    } & AttachmentPayloadFragment;
};
export declare type AttachmentLinkZendeskMutationVariables = Exact<{
    issueId: Scalars["String"];
    ticketId: Scalars["String"];
}>;
export declare type AttachmentLinkZendeskMutation = {
    __typename?: "Mutation";
} & {
    attachmentLinkZendesk: {
        __typename?: "AttachmentPayload";
    } & AttachmentPayloadFragment;
};
export declare type AttachmentUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: AttachmentUpdateInput;
}>;
export declare type AttachmentUpdateMutation = {
    __typename?: "Mutation";
} & {
    attachmentUpdate: {
        __typename?: "AttachmentPayload";
    } & AttachmentPayloadFragment;
};
export declare type BillingEmailUpdateMutationVariables = Exact<{
    input: BillingEmailUpdateInput;
}>;
export declare type BillingEmailUpdateMutation = {
    __typename?: "Mutation";
} & {
    billingEmailUpdate: {
        __typename?: "BillingEmailPayload";
    } & BillingEmailPayloadFragment;
};
export declare type CollaborativeDocumentUpdateMutationVariables = Exact<{
    input: CollaborationDocumentUpdateInput;
}>;
export declare type CollaborativeDocumentUpdateMutation = {
    __typename?: "Mutation";
} & {
    collaborativeDocumentUpdate: {
        __typename?: "CollaborationDocumentUpdatePayload";
    } & CollaborationDocumentUpdatePayloadFragment;
};
export declare type CommentCreateMutationVariables = Exact<{
    input: CommentCreateInput;
}>;
export declare type CommentCreateMutation = {
    __typename?: "Mutation";
} & {
    commentCreate: {
        __typename?: "CommentPayload";
    } & CommentPayloadFragment;
};
export declare type CommentDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type CommentDeleteMutation = {
    __typename?: "Mutation";
} & {
    commentDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type CommentUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: CommentUpdateInput;
}>;
export declare type CommentUpdateMutation = {
    __typename?: "Mutation";
} & {
    commentUpdate: {
        __typename?: "CommentPayload";
    } & CommentPayloadFragment;
};
export declare type ContactCreateMutationVariables = Exact<{
    input: ContactCreateInput;
}>;
export declare type ContactCreateMutation = {
    __typename?: "Mutation";
} & {
    contactCreate: {
        __typename?: "ContactPayload";
    } & ContactPayloadFragment;
};
export declare type CreateCsvExportReportMutationVariables = Exact<{
    includePrivateTeamIds?: Maybe<Array<Scalars["String"]> | Scalars["String"]>;
}>;
export declare type CreateCsvExportReportMutation = {
    __typename?: "Mutation";
} & {
    createCsvExportReport: {
        __typename?: "CreateCsvExportReportPayload";
    } & CreateCsvExportReportPayloadFragment;
};
export declare type CreateOrganizationFromOnboardingMutationVariables = Exact<{
    input: CreateOrganizationInput;
    survey?: Maybe<OnboardingCustomerSurvey>;
}>;
export declare type CreateOrganizationFromOnboardingMutation = {
    __typename?: "Mutation";
} & {
    createOrganizationFromOnboarding: {
        __typename?: "CreateOrJoinOrganizationResponse";
    } & CreateOrJoinOrganizationResponseFragment;
};
export declare type CustomViewCreateMutationVariables = Exact<{
    input: CustomViewCreateInput;
}>;
export declare type CustomViewCreateMutation = {
    __typename?: "Mutation";
} & {
    customViewCreate: {
        __typename?: "CustomViewPayload";
    } & CustomViewPayloadFragment;
};
export declare type CustomViewDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type CustomViewDeleteMutation = {
    __typename?: "Mutation";
} & {
    customViewDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type CustomViewUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: CustomViewUpdateInput;
}>;
export declare type CustomViewUpdateMutation = {
    __typename?: "Mutation";
} & {
    customViewUpdate: {
        __typename?: "CustomViewPayload";
    } & CustomViewPayloadFragment;
};
export declare type CycleArchiveMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type CycleArchiveMutation = {
    __typename?: "Mutation";
} & {
    cycleArchive: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type CycleCreateMutationVariables = Exact<{
    input: CycleCreateInput;
}>;
export declare type CycleCreateMutation = {
    __typename?: "Mutation";
} & {
    cycleCreate: {
        __typename?: "CyclePayload";
    } & CyclePayloadFragment;
};
export declare type CycleUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: CycleUpdateInput;
}>;
export declare type CycleUpdateMutation = {
    __typename?: "Mutation";
} & {
    cycleUpdate: {
        __typename?: "CyclePayload";
    } & CyclePayloadFragment;
};
export declare type DebugFailWithInternalErrorMutationVariables = Exact<{
    [key: string]: never;
}>;
export declare type DebugFailWithInternalErrorMutation = {
    __typename?: "Mutation";
} & {
    debugFailWithInternalError: {
        __typename?: "DebugPayload";
    } & DebugPayloadFragment;
};
export declare type DocumentCreateMutationVariables = Exact<{
    input: DocumentCreateInput;
}>;
export declare type DocumentCreateMutation = {
    __typename?: "Mutation";
} & {
    documentCreate: {
        __typename?: "DocumentPayload";
    } & DocumentPayloadFragment;
};
export declare type DocumentDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type DocumentDeleteMutation = {
    __typename?: "Mutation";
} & {
    documentDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type DocumentUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: DocumentUpdateInput;
}>;
export declare type DocumentUpdateMutation = {
    __typename?: "Mutation";
} & {
    documentUpdate: {
        __typename?: "DocumentPayload";
    } & DocumentPayloadFragment;
};
export declare type EmailSubscribeMutationVariables = Exact<{
    input: EmailSubscribeInput;
}>;
export declare type EmailSubscribeMutation = {
    __typename?: "Mutation";
} & {
    emailSubscribe: {
        __typename?: "EmailSubscribePayload";
    } & EmailSubscribePayloadFragment;
};
export declare type EmailTokenUserAccountAuthMutationVariables = Exact<{
    input: TokenUserAccountAuthInput;
}>;
export declare type EmailTokenUserAccountAuthMutation = {
    __typename?: "Mutation";
} & {
    emailTokenUserAccountAuth: {
        __typename?: "AuthResolverResponse";
    } & AuthResolverResponseFragment;
};
export declare type EmailUnsubscribeMutationVariables = Exact<{
    input: EmailUnsubscribeInput;
}>;
export declare type EmailUnsubscribeMutation = {
    __typename?: "Mutation";
} & {
    emailUnsubscribe: {
        __typename?: "EmailUnsubscribePayload";
    } & EmailUnsubscribePayloadFragment;
};
export declare type EmailUserAccountAuthChallengeMutationVariables = Exact<{
    input: EmailUserAccountAuthChallengeInput;
}>;
export declare type EmailUserAccountAuthChallengeMutation = {
    __typename?: "Mutation";
} & {
    emailUserAccountAuthChallenge: {
        __typename?: "EmailUserAccountAuthChallengeResponse";
    } & EmailUserAccountAuthChallengeResponseFragment;
};
export declare type EmojiCreateMutationVariables = Exact<{
    input: EmojiCreateInput;
}>;
export declare type EmojiCreateMutation = {
    __typename?: "Mutation";
} & {
    emojiCreate: {
        __typename?: "EmojiPayload";
    } & EmojiPayloadFragment;
};
export declare type EmojiDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type EmojiDeleteMutation = {
    __typename?: "Mutation";
} & {
    emojiDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type EventCreateMutationVariables = Exact<{
    input: EventCreateInput;
}>;
export declare type EventCreateMutation = {
    __typename?: "Mutation";
} & {
    eventCreate: {
        __typename?: "EventPayload";
    } & EventPayloadFragment;
};
export declare type FavoriteCreateMutationVariables = Exact<{
    input: FavoriteCreateInput;
}>;
export declare type FavoriteCreateMutation = {
    __typename?: "Mutation";
} & {
    favoriteCreate: {
        __typename?: "FavoritePayload";
    } & FavoritePayloadFragment;
};
export declare type FavoriteDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type FavoriteDeleteMutation = {
    __typename?: "Mutation";
} & {
    favoriteDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type FavoriteUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: FavoriteUpdateInput;
}>;
export declare type FavoriteUpdateMutation = {
    __typename?: "Mutation";
} & {
    favoriteUpdate: {
        __typename?: "FavoritePayload";
    } & FavoritePayloadFragment;
};
export declare type FeedbackCreateMutationVariables = Exact<{
    input: FeedbackCreateInput;
}>;
export declare type FeedbackCreateMutation = {
    __typename?: "Mutation";
} & {
    feedbackCreate: {
        __typename?: "FeedbackPayload";
    } & FeedbackPayloadFragment;
};
export declare type FileUploadMutationVariables = Exact<{
    contentType: Scalars["String"];
    filename: Scalars["String"];
    metaData?: Maybe<Scalars["JSON"]>;
    size: Scalars["Int"];
}>;
export declare type FileUploadMutation = {
    __typename?: "Mutation";
} & {
    fileUpload: {
        __typename?: "UploadPayload";
    } & UploadPayloadFragment;
};
export declare type GoogleUserAccountAuthMutationVariables = Exact<{
    input: GoogleUserAccountAuthInput;
}>;
export declare type GoogleUserAccountAuthMutation = {
    __typename?: "Mutation";
} & {
    googleUserAccountAuth: {
        __typename?: "AuthResolverResponse";
    } & AuthResolverResponseFragment;
};
export declare type ImageUploadFromUrlMutationVariables = Exact<{
    url: Scalars["String"];
}>;
export declare type ImageUploadFromUrlMutation = {
    __typename?: "Mutation";
} & {
    imageUploadFromUrl: {
        __typename?: "ImageUploadFromUrlPayload";
    } & ImageUploadFromUrlPayloadFragment;
};
export declare type IntegrationDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type IntegrationDeleteMutation = {
    __typename?: "Mutation";
} & {
    integrationDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type IntegrationFigmaMutationVariables = Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
}>;
export declare type IntegrationFigmaMutation = {
    __typename?: "Mutation";
} & {
    integrationFigma: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationFrontMutationVariables = Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
}>;
export declare type IntegrationFrontMutation = {
    __typename?: "Mutation";
} & {
    integrationFront: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationGithubCommitCreateMutationVariables = Exact<{
    [key: string]: never;
}>;
export declare type IntegrationGithubCommitCreateMutation = {
    __typename?: "Mutation";
} & {
    integrationGithubCommitCreate: {
        __typename?: "GitHubCommitIntegrationPayload";
    } & GitHubCommitIntegrationPayloadFragment;
};
export declare type IntegrationGithubConnectMutationVariables = Exact<{
    installationId: Scalars["String"];
}>;
export declare type IntegrationGithubConnectMutation = {
    __typename?: "Mutation";
} & {
    integrationGithubConnect: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationGitlabConnectMutationVariables = Exact<{
    accessToken: Scalars["String"];
    gitlabUrl: Scalars["String"];
}>;
export declare type IntegrationGitlabConnectMutation = {
    __typename?: "Mutation";
} & {
    integrationGitlabConnect: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationGoogleSheetsMutationVariables = Exact<{
    code: Scalars["String"];
}>;
export declare type IntegrationGoogleSheetsMutation = {
    __typename?: "Mutation";
} & {
    integrationGoogleSheets: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationIntercomMutationVariables = Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
}>;
export declare type IntegrationIntercomMutation = {
    __typename?: "Mutation";
} & {
    integrationIntercom: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationIntercomDeleteMutationVariables = Exact<{
    [key: string]: never;
}>;
export declare type IntegrationIntercomDeleteMutation = {
    __typename?: "Mutation";
} & {
    integrationIntercomDelete: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationIntercomSettingsUpdateMutationVariables = Exact<{
    input: IntercomSettingsInput;
}>;
export declare type IntegrationIntercomSettingsUpdateMutation = {
    __typename?: "Mutation";
} & {
    integrationIntercomSettingsUpdate: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationLoomMutationVariables = Exact<{
    [key: string]: never;
}>;
export declare type IntegrationLoomMutation = {
    __typename?: "Mutation";
} & {
    integrationLoom: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationResourceArchiveMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type IntegrationResourceArchiveMutation = {
    __typename?: "Mutation";
} & {
    integrationResourceArchive: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type IntegrationSentryConnectMutationVariables = Exact<{
    code: Scalars["String"];
    installationId: Scalars["String"];
    organizationSlug: Scalars["String"];
}>;
export declare type IntegrationSentryConnectMutation = {
    __typename?: "Mutation";
} & {
    integrationSentryConnect: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationSettingsUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: IntegrationSettingsInput;
}>;
export declare type IntegrationSettingsUpdateMutation = {
    __typename?: "Mutation";
} & {
    integrationSettingsUpdate: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationSlackMutationVariables = Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
    shouldUseV2Auth?: Maybe<Scalars["Boolean"]>;
}>;
export declare type IntegrationSlackMutation = {
    __typename?: "Mutation";
} & {
    integrationSlack: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationSlackImportEmojisMutationVariables = Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
}>;
export declare type IntegrationSlackImportEmojisMutation = {
    __typename?: "Mutation";
} & {
    integrationSlackImportEmojis: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationSlackPersonalMutationVariables = Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
}>;
export declare type IntegrationSlackPersonalMutation = {
    __typename?: "Mutation";
} & {
    integrationSlackPersonal: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationSlackPostMutationVariables = Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
    shouldUseV2Auth?: Maybe<Scalars["Boolean"]>;
    teamId: Scalars["String"];
}>;
export declare type IntegrationSlackPostMutation = {
    __typename?: "Mutation";
} & {
    integrationSlackPost: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationSlackProjectPostMutationVariables = Exact<{
    code: Scalars["String"];
    projectId: Scalars["String"];
    redirectUri: Scalars["String"];
}>;
export declare type IntegrationSlackProjectPostMutation = {
    __typename?: "Mutation";
} & {
    integrationSlackProjectPost: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationZendeskMutationVariables = Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
    scope: Scalars["String"];
    subdomain: Scalars["String"];
}>;
export declare type IntegrationZendeskMutation = {
    __typename?: "Mutation";
} & {
    integrationZendesk: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IssueArchiveMutationVariables = Exact<{
    id: Scalars["String"];
    trash?: Maybe<Scalars["Boolean"]>;
}>;
export declare type IssueArchiveMutation = {
    __typename?: "Mutation";
} & {
    issueArchive: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type IssueBatchUpdateMutationVariables = Exact<{
    ids: Array<Scalars["UUID"]> | Scalars["UUID"];
    input: IssueUpdateInput;
}>;
export declare type IssueBatchUpdateMutation = {
    __typename?: "Mutation";
} & {
    issueBatchUpdate: {
        __typename?: "IssueBatchPayload";
    } & IssueBatchPayloadFragment;
};
export declare type IssueCreateMutationVariables = Exact<{
    input: IssueCreateInput;
}>;
export declare type IssueCreateMutation = {
    __typename?: "Mutation";
} & {
    issueCreate: {
        __typename?: "IssuePayload";
    } & IssuePayloadFragment;
};
export declare type IssueDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type IssueDeleteMutation = {
    __typename?: "Mutation";
} & {
    issueDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type IssueImportCreateAsanaMutationVariables = Exact<{
    asanaTeamName: Scalars["String"];
    asanaToken: Scalars["String"];
    id?: Maybe<Scalars["String"]>;
    includeClosedIssues?: Maybe<Scalars["Boolean"]>;
    instantProcess?: Maybe<Scalars["Boolean"]>;
    teamId: Scalars["String"];
}>;
export declare type IssueImportCreateAsanaMutation = {
    __typename?: "Mutation";
} & {
    issueImportCreateAsana: {
        __typename?: "IssueImportPayload";
    } & IssueImportPayloadFragment;
};
export declare type IssueImportCreateClubhouseMutationVariables = Exact<{
    clubhouseTeamName: Scalars["String"];
    clubhouseToken: Scalars["String"];
    id?: Maybe<Scalars["String"]>;
    includeClosedIssues?: Maybe<Scalars["Boolean"]>;
    instantProcess?: Maybe<Scalars["Boolean"]>;
    teamId: Scalars["String"];
}>;
export declare type IssueImportCreateClubhouseMutation = {
    __typename?: "Mutation";
} & {
    issueImportCreateClubhouse: {
        __typename?: "IssueImportPayload";
    } & IssueImportPayloadFragment;
};
export declare type IssueImportCreateGithubMutationVariables = Exact<{
    githubRepoName: Scalars["String"];
    githubRepoOwner: Scalars["String"];
    githubShouldImportOrgProjects?: Maybe<Scalars["Boolean"]>;
    githubToken: Scalars["String"];
    id?: Maybe<Scalars["String"]>;
    includeClosedIssues?: Maybe<Scalars["Boolean"]>;
    instantProcess?: Maybe<Scalars["Boolean"]>;
    teamId: Scalars["String"];
}>;
export declare type IssueImportCreateGithubMutation = {
    __typename?: "Mutation";
} & {
    issueImportCreateGithub: {
        __typename?: "IssueImportPayload";
    } & IssueImportPayloadFragment;
};
export declare type IssueImportCreateJiraMutationVariables = Exact<{
    id?: Maybe<Scalars["String"]>;
    includeClosedIssues?: Maybe<Scalars["Boolean"]>;
    instantProcess?: Maybe<Scalars["Boolean"]>;
    jiraEmail: Scalars["String"];
    jiraHostname: Scalars["String"];
    jiraProject: Scalars["String"];
    jiraToken: Scalars["String"];
    teamId: Scalars["String"];
}>;
export declare type IssueImportCreateJiraMutation = {
    __typename?: "Mutation";
} & {
    issueImportCreateJira: {
        __typename?: "IssueImportPayload";
    } & IssueImportPayloadFragment;
};
export declare type IssueImportDeleteMutationVariables = Exact<{
    issueImportId: Scalars["String"];
}>;
export declare type IssueImportDeleteMutation = {
    __typename?: "Mutation";
} & {
    issueImportDelete: {
        __typename?: "IssueImportDeletePayload";
    } & IssueImportDeletePayloadFragment;
};
export declare type IssueImportProcessMutationVariables = Exact<{
    issueImportId: Scalars["String"];
    mapping: Scalars["JSONObject"];
}>;
export declare type IssueImportProcessMutation = {
    __typename?: "Mutation";
} & {
    issueImportProcess: {
        __typename?: "IssueImportPayload";
    } & IssueImportPayloadFragment;
};
export declare type IssueImportUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: IssueImportUpdateInput;
}>;
export declare type IssueImportUpdateMutation = {
    __typename?: "Mutation";
} & {
    issueImportUpdate: {
        __typename?: "IssueImportPayload";
    } & IssueImportPayloadFragment;
};
export declare type IssueLabelArchiveMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type IssueLabelArchiveMutation = {
    __typename?: "Mutation";
} & {
    issueLabelArchive: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type IssueLabelCreateMutationVariables = Exact<{
    input: IssueLabelCreateInput;
    replaceTeamLabels?: Maybe<Scalars["Boolean"]>;
}>;
export declare type IssueLabelCreateMutation = {
    __typename?: "Mutation";
} & {
    issueLabelCreate: {
        __typename?: "IssueLabelPayload";
    } & IssueLabelPayloadFragment;
};
export declare type IssueLabelUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: IssueLabelUpdateInput;
}>;
export declare type IssueLabelUpdateMutation = {
    __typename?: "Mutation";
} & {
    issueLabelUpdate: {
        __typename?: "IssueLabelPayload";
    } & IssueLabelPayloadFragment;
};
export declare type IssueRelationCreateMutationVariables = Exact<{
    input: IssueRelationCreateInput;
}>;
export declare type IssueRelationCreateMutation = {
    __typename?: "Mutation";
} & {
    issueRelationCreate: {
        __typename?: "IssueRelationPayload";
    } & IssueRelationPayloadFragment;
};
export declare type IssueRelationDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type IssueRelationDeleteMutation = {
    __typename?: "Mutation";
} & {
    issueRelationDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type IssueRelationUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: IssueRelationUpdateInput;
}>;
export declare type IssueRelationUpdateMutation = {
    __typename?: "Mutation";
} & {
    issueRelationUpdate: {
        __typename?: "IssueRelationPayload";
    } & IssueRelationPayloadFragment;
};
export declare type IssueUnarchiveMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type IssueUnarchiveMutation = {
    __typename?: "Mutation";
} & {
    issueUnarchive: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type IssueUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: IssueUpdateInput;
}>;
export declare type IssueUpdateMutation = {
    __typename?: "Mutation";
} & {
    issueUpdate: {
        __typename?: "IssuePayload";
    } & IssuePayloadFragment;
};
export declare type JiraIntegrationConnectMutationVariables = Exact<{
    input: JiraConfigurationInput;
}>;
export declare type JiraIntegrationConnectMutation = {
    __typename?: "Mutation";
} & {
    jiraIntegrationConnect: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type JoinOrganizationFromOnboardingMutationVariables = Exact<{
    input: JoinOrganizationInput;
}>;
export declare type JoinOrganizationFromOnboardingMutation = {
    __typename?: "Mutation";
} & {
    joinOrganizationFromOnboarding: {
        __typename?: "CreateOrJoinOrganizationResponse";
    } & CreateOrJoinOrganizationResponseFragment;
};
export declare type LeaveOrganizationMutationVariables = Exact<{
    organizationId: Scalars["String"];
}>;
export declare type LeaveOrganizationMutation = {
    __typename?: "Mutation";
} & {
    leaveOrganization: {
        __typename?: "CreateOrJoinOrganizationResponse";
    } & CreateOrJoinOrganizationResponseFragment;
};
export declare type MilestoneCreateMutationVariables = Exact<{
    input: MilestoneCreateInput;
}>;
export declare type MilestoneCreateMutation = {
    __typename?: "Mutation";
} & {
    milestoneCreate: {
        __typename?: "MilestonePayload";
    } & MilestonePayloadFragment;
};
export declare type MilestoneDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type MilestoneDeleteMutation = {
    __typename?: "Mutation";
} & {
    milestoneDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type MilestoneUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: MilestoneUpdateInput;
}>;
export declare type MilestoneUpdateMutation = {
    __typename?: "Mutation";
} & {
    milestoneUpdate: {
        __typename?: "MilestonePayload";
    } & MilestonePayloadFragment;
};
export declare type NotificationArchiveMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type NotificationArchiveMutation = {
    __typename?: "Mutation";
} & {
    notificationArchive: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type NotificationCreateMutationVariables = Exact<{
    id: Scalars["String"];
    input: NotificationUpdateInput;
}>;
export declare type NotificationCreateMutation = {
    __typename?: "Mutation";
} & {
    notificationCreate: {
        __typename?: "NotificationPayload";
    } & NotificationPayloadFragment;
};
export declare type NotificationSubscriptionCreateMutationVariables = Exact<{
    input: NotificationSubscriptionCreateInput;
}>;
export declare type NotificationSubscriptionCreateMutation = {
    __typename?: "Mutation";
} & {
    notificationSubscriptionCreate: {
        __typename?: "NotificationSubscriptionPayload";
    } & NotificationSubscriptionPayloadFragment;
};
export declare type NotificationSubscriptionDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type NotificationSubscriptionDeleteMutation = {
    __typename?: "Mutation";
} & {
    notificationSubscriptionDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type NotificationUnarchiveMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type NotificationUnarchiveMutation = {
    __typename?: "Mutation";
} & {
    notificationUnarchive: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type NotificationUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: NotificationUpdateInput;
}>;
export declare type NotificationUpdateMutation = {
    __typename?: "Mutation";
} & {
    notificationUpdate: {
        __typename?: "NotificationPayload";
    } & NotificationPayloadFragment;
};
export declare type OauthClientArchiveMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type OauthClientArchiveMutation = {
    __typename?: "Mutation";
} & {
    oauthClientArchive: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type OauthClientCreateMutationVariables = Exact<{
    input: OauthClientCreateInput;
}>;
export declare type OauthClientCreateMutation = {
    __typename?: "Mutation";
} & {
    oauthClientCreate: {
        __typename?: "OauthClientPayload";
    } & OauthClientPayloadFragment;
};
export declare type OauthClientRotateSecretMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type OauthClientRotateSecretMutation = {
    __typename?: "Mutation";
} & {
    oauthClientRotateSecret: {
        __typename?: "RotateSecretPayload";
    } & RotateSecretPayloadFragment;
};
export declare type OauthClientUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: OauthClientUpdateInput;
}>;
export declare type OauthClientUpdateMutation = {
    __typename?: "Mutation";
} & {
    oauthClientUpdate: {
        __typename?: "OauthClientPayload";
    } & OauthClientPayloadFragment;
};
export declare type OauthTokenRevokeMutationVariables = Exact<{
    appId: Scalars["String"];
    scope: Array<Scalars["String"]> | Scalars["String"];
}>;
export declare type OauthTokenRevokeMutation = {
    __typename?: "Mutation";
} & {
    oauthTokenRevoke: {
        __typename?: "OauthTokenRevokePayload";
    } & OauthTokenRevokePayloadFragment;
};
export declare type OrganizationCancelDeleteMutationVariables = Exact<{
    [key: string]: never;
}>;
export declare type OrganizationCancelDeleteMutation = {
    __typename?: "Mutation";
} & {
    organizationCancelDelete: {
        __typename?: "OrganizationCancelDeletePayload";
    } & OrganizationCancelDeletePayloadFragment;
};
export declare type OrganizationDeleteMutationVariables = Exact<{
    input: DeleteOrganizationInput;
}>;
export declare type OrganizationDeleteMutation = {
    __typename?: "Mutation";
} & {
    organizationDelete: {
        __typename?: "OrganizationDeletePayload";
    } & OrganizationDeletePayloadFragment;
};
export declare type OrganizationDeleteChallengeMutationVariables = Exact<{
    [key: string]: never;
}>;
export declare type OrganizationDeleteChallengeMutation = {
    __typename?: "Mutation";
} & {
    organizationDeleteChallenge: {
        __typename?: "OrganizationDeletePayload";
    } & OrganizationDeletePayloadFragment;
};
export declare type OrganizationDomainCreateMutationVariables = Exact<{
    input: OrganizationDomainCreateInput;
}>;
export declare type OrganizationDomainCreateMutation = {
    __typename?: "Mutation";
} & {
    organizationDomainCreate: {
        __typename?: "OrganizationDomainPayload";
    } & OrganizationDomainPayloadFragment;
};
export declare type OrganizationDomainDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type OrganizationDomainDeleteMutation = {
    __typename?: "Mutation";
} & {
    organizationDomainDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type OrganizationDomainVerifyMutationVariables = Exact<{
    input: OrganizationDomainVerificationInput;
}>;
export declare type OrganizationDomainVerifyMutation = {
    __typename?: "Mutation";
} & {
    organizationDomainVerify: {
        __typename?: "OrganizationDomainPayload";
    } & OrganizationDomainPayloadFragment;
};
export declare type OrganizationInviteCreateMutationVariables = Exact<{
    input: OrganizationInviteCreateInput;
}>;
export declare type OrganizationInviteCreateMutation = {
    __typename?: "Mutation";
} & {
    organizationInviteCreate: {
        __typename?: "OrganizationInvitePayload";
    } & OrganizationInvitePayloadFragment;
};
export declare type OrganizationInviteDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type OrganizationInviteDeleteMutation = {
    __typename?: "Mutation";
} & {
    organizationInviteDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type OrganizationUpdateMutationVariables = Exact<{
    input: UpdateOrganizationInput;
}>;
export declare type OrganizationUpdateMutation = {
    __typename?: "Mutation";
} & {
    organizationUpdate: {
        __typename?: "OrganizationPayload";
    } & OrganizationPayloadFragment;
};
export declare type ProjectArchiveMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type ProjectArchiveMutation = {
    __typename?: "Mutation";
} & {
    projectArchive: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type ProjectCreateMutationVariables = Exact<{
    input: ProjectCreateInput;
}>;
export declare type ProjectCreateMutation = {
    __typename?: "Mutation";
} & {
    projectCreate: {
        __typename?: "ProjectPayload";
    } & ProjectPayloadFragment;
};
export declare type ProjectLinkCreateMutationVariables = Exact<{
    input: ProjectLinkCreateInput;
}>;
export declare type ProjectLinkCreateMutation = {
    __typename?: "Mutation";
} & {
    projectLinkCreate: {
        __typename?: "ProjectLinkPayload";
    } & ProjectLinkPayloadFragment;
};
export declare type ProjectLinkDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type ProjectLinkDeleteMutation = {
    __typename?: "Mutation";
} & {
    projectLinkDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type ProjectLinkUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: ProjectLinkUpdateInput;
}>;
export declare type ProjectLinkUpdateMutation = {
    __typename?: "Mutation";
} & {
    projectLinkUpdate: {
        __typename?: "ProjectLinkPayload";
    } & ProjectLinkPayloadFragment;
};
export declare type ProjectUnarchiveMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type ProjectUnarchiveMutation = {
    __typename?: "Mutation";
} & {
    projectUnarchive: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type ProjectUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: ProjectUpdateInput;
}>;
export declare type ProjectUpdateMutation = {
    __typename?: "Mutation";
} & {
    projectUpdate: {
        __typename?: "ProjectPayload";
    } & ProjectPayloadFragment;
};
export declare type PushSubscriptionCreateMutationVariables = Exact<{
    input: PushSubscriptionCreateInput;
}>;
export declare type PushSubscriptionCreateMutation = {
    __typename?: "Mutation";
} & {
    pushSubscriptionCreate: {
        __typename?: "PushSubscriptionPayload";
    } & PushSubscriptionPayloadFragment;
};
export declare type PushSubscriptionDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type PushSubscriptionDeleteMutation = {
    __typename?: "Mutation";
} & {
    pushSubscriptionDelete: {
        __typename?: "PushSubscriptionPayload";
    } & PushSubscriptionPayloadFragment;
};
export declare type ReactionCreateMutationVariables = Exact<{
    input: ReactionCreateInput;
}>;
export declare type ReactionCreateMutation = {
    __typename?: "Mutation";
} & {
    reactionCreate: {
        __typename?: "ReactionPayload";
    } & ReactionPayloadFragment;
};
export declare type ReactionDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type ReactionDeleteMutation = {
    __typename?: "Mutation";
} & {
    reactionDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type RefreshGoogleSheetsDataMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type RefreshGoogleSheetsDataMutation = {
    __typename?: "Mutation";
} & {
    refreshGoogleSheetsData: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type ResendOrganizationInviteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type ResendOrganizationInviteMutation = {
    __typename?: "Mutation";
} & {
    resendOrganizationInvite: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type SamlTokenUserAccountAuthMutationVariables = Exact<{
    input: TokenUserAccountAuthInput;
}>;
export declare type SamlTokenUserAccountAuthMutation = {
    __typename?: "Mutation";
} & {
    samlTokenUserAccountAuth: {
        __typename?: "AuthResolverResponse";
    } & AuthResolverResponseFragment;
};
export declare type TeamCreateMutationVariables = Exact<{
    copySettingsFromTeamId?: Maybe<Scalars["String"]>;
    input: TeamCreateInput;
}>;
export declare type TeamCreateMutation = {
    __typename?: "Mutation";
} & {
    teamCreate: {
        __typename?: "TeamPayload";
    } & TeamPayloadFragment;
};
export declare type TeamDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type TeamDeleteMutation = {
    __typename?: "Mutation";
} & {
    teamDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type TeamKeyDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type TeamKeyDeleteMutation = {
    __typename?: "Mutation";
} & {
    teamKeyDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type TeamMembershipCreateMutationVariables = Exact<{
    input: TeamMembershipCreateInput;
}>;
export declare type TeamMembershipCreateMutation = {
    __typename?: "Mutation";
} & {
    teamMembershipCreate: {
        __typename?: "TeamMembershipPayload";
    } & TeamMembershipPayloadFragment;
};
export declare type TeamMembershipDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type TeamMembershipDeleteMutation = {
    __typename?: "Mutation";
} & {
    teamMembershipDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type TeamMembershipUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: TeamMembershipUpdateInput;
}>;
export declare type TeamMembershipUpdateMutation = {
    __typename?: "Mutation";
} & {
    teamMembershipUpdate: {
        __typename?: "TeamMembershipPayload";
    } & TeamMembershipPayloadFragment;
};
export declare type TeamUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: TeamUpdateInput;
}>;
export declare type TeamUpdateMutation = {
    __typename?: "Mutation";
} & {
    teamUpdate: {
        __typename?: "TeamPayload";
    } & TeamPayloadFragment;
};
export declare type TemplateCreateMutationVariables = Exact<{
    input: TemplateCreateInput;
}>;
export declare type TemplateCreateMutation = {
    __typename?: "Mutation";
} & {
    templateCreate: {
        __typename?: "TemplatePayload";
    } & TemplatePayloadFragment;
};
export declare type TemplateDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type TemplateDeleteMutation = {
    __typename?: "Mutation";
} & {
    templateDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type TemplateUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: TemplateUpdateInput;
}>;
export declare type TemplateUpdateMutation = {
    __typename?: "Mutation";
} & {
    templateUpdate: {
        __typename?: "TemplatePayload";
    } & TemplatePayloadFragment;
};
export declare type UserDemoteAdminMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type UserDemoteAdminMutation = {
    __typename?: "Mutation";
} & {
    userDemoteAdmin: {
        __typename?: "UserAdminPayload";
    } & UserAdminPayloadFragment;
};
export declare type UserFlagUpdateMutationVariables = Exact<{
    flag: UserFlagType;
    operation: UserFlagUpdateOperation;
}>;
export declare type UserFlagUpdateMutation = {
    __typename?: "Mutation";
} & {
    userFlagUpdate: {
        __typename?: "UserSettingsFlagPayload";
    } & UserSettingsFlagPayloadFragment;
};
export declare type UserPromoteAdminMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type UserPromoteAdminMutation = {
    __typename?: "Mutation";
} & {
    userPromoteAdmin: {
        __typename?: "UserAdminPayload";
    } & UserAdminPayloadFragment;
};
export declare type UserSettingsFlagIncrementMutationVariables = Exact<{
    flag: Scalars["String"];
}>;
export declare type UserSettingsFlagIncrementMutation = {
    __typename?: "Mutation";
} & {
    userSettingsFlagIncrement: {
        __typename?: "UserSettingsFlagPayload";
    } & UserSettingsFlagPayloadFragment;
};
export declare type UserSettingsFlagsResetMutationVariables = Exact<{
    [key: string]: never;
}>;
export declare type UserSettingsFlagsResetMutation = {
    __typename?: "Mutation";
} & {
    userSettingsFlagsReset: {
        __typename?: "UserSettingsFlagsResetPayload";
    } & UserSettingsFlagsResetPayloadFragment;
};
export declare type UserSettingsUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: UserSettingsUpdateInput;
}>;
export declare type UserSettingsUpdateMutation = {
    __typename?: "Mutation";
} & {
    userSettingsUpdate: {
        __typename?: "UserSettingsPayload";
    } & UserSettingsPayloadFragment;
};
export declare type UserSubscribeToNewsletterMutationVariables = Exact<{
    [key: string]: never;
}>;
export declare type UserSubscribeToNewsletterMutation = {
    __typename?: "Mutation";
} & {
    userSubscribeToNewsletter: {
        __typename?: "UserSubscribeToNewsletterPayload";
    } & UserSubscribeToNewsletterPayloadFragment;
};
export declare type UserSuspendMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type UserSuspendMutation = {
    __typename?: "Mutation";
} & {
    userSuspend: {
        __typename?: "UserAdminPayload";
    } & UserAdminPayloadFragment;
};
export declare type UserUnsuspendMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type UserUnsuspendMutation = {
    __typename?: "Mutation";
} & {
    userUnsuspend: {
        __typename?: "UserAdminPayload";
    } & UserAdminPayloadFragment;
};
export declare type UserUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: UpdateUserInput;
}>;
export declare type UserUpdateMutation = {
    __typename?: "Mutation";
} & {
    userUpdate: {
        __typename?: "UserPayload";
    } & UserPayloadFragment;
};
export declare type ViewPreferencesCreateMutationVariables = Exact<{
    input: ViewPreferencesCreateInput;
}>;
export declare type ViewPreferencesCreateMutation = {
    __typename?: "Mutation";
} & {
    viewPreferencesCreate: {
        __typename?: "ViewPreferencesPayload";
    } & ViewPreferencesPayloadFragment;
};
export declare type ViewPreferencesDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type ViewPreferencesDeleteMutation = {
    __typename?: "Mutation";
} & {
    viewPreferencesDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type ViewPreferencesUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: ViewPreferencesUpdateInput;
}>;
export declare type ViewPreferencesUpdateMutation = {
    __typename?: "Mutation";
} & {
    viewPreferencesUpdate: {
        __typename?: "ViewPreferencesPayload";
    } & ViewPreferencesPayloadFragment;
};
export declare type WebhookCreateMutationVariables = Exact<{
    input: WebhookCreateInput;
}>;
export declare type WebhookCreateMutation = {
    __typename?: "Mutation";
} & {
    webhookCreate: {
        __typename?: "WebhookPayload";
    } & WebhookPayloadFragment;
};
export declare type WebhookDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type WebhookDeleteMutation = {
    __typename?: "Mutation";
} & {
    webhookDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type WebhookUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: WebhookUpdateInput;
}>;
export declare type WebhookUpdateMutation = {
    __typename?: "Mutation";
} & {
    webhookUpdate: {
        __typename?: "WebhookPayload";
    } & WebhookPayloadFragment;
};
export declare type WorkflowStateArchiveMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type WorkflowStateArchiveMutation = {
    __typename?: "Mutation";
} & {
    workflowStateArchive: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type WorkflowStateCreateMutationVariables = Exact<{
    input: WorkflowStateCreateInput;
}>;
export declare type WorkflowStateCreateMutation = {
    __typename?: "Mutation";
} & {
    workflowStateCreate: {
        __typename?: "WorkflowStatePayload";
    } & WorkflowStatePayloadFragment;
};
export declare type WorkflowStateUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: WorkflowStateUpdateInput;
}>;
export declare type WorkflowStateUpdateMutation = {
    __typename?: "Mutation";
} & {
    workflowStateUpdate: {
        __typename?: "WorkflowStatePayload";
    } & WorkflowStatePayloadFragment;
};
export declare const TemplateFragmentDoc: DocumentNode<TemplateFragment, unknown>;
export declare const UserFragmentDoc: DocumentNode<UserFragment, unknown>;
export declare const UserAccountFragmentDoc: DocumentNode<UserAccountFragment, unknown>;
export declare const DocumentStepFragmentDoc: DocumentNode<DocumentStepFragment, unknown>;
export declare const SyncDeltaResponseFragmentDoc: DocumentNode<SyncDeltaResponseFragment, unknown>;
export declare const SyncResponseFragmentDoc: DocumentNode<SyncResponseFragment, unknown>;
export declare const ArchiveResponseFragmentDoc: DocumentNode<ArchiveResponseFragment, unknown>;
export declare const DependencyResponseFragmentDoc: DocumentNode<DependencyResponseFragment, unknown>;
export declare const SyncBatchResponseFragmentDoc: DocumentNode<SyncBatchResponseFragment, unknown>;
export declare const GithubRepoFragmentDoc: DocumentNode<GithubRepoFragment, unknown>;
export declare const GithubOrgFragmentDoc: DocumentNode<GithubOrgFragment, unknown>;
export declare const GithubOAuthTokenPayloadFragmentDoc: DocumentNode<GithubOAuthTokenPayloadFragment, unknown>;
export declare const AuthorizedApplicationFragmentDoc: DocumentNode<AuthorizedApplicationFragment, unknown>;
export declare const UserAuthorizedApplicationFragmentDoc: DocumentNode<UserAuthorizedApplicationFragment, unknown>;
export declare const ApplicationFragmentDoc: DocumentNode<ApplicationFragment, unknown>;
export declare const GoogleSheetsSettingsFragmentDoc: DocumentNode<GoogleSheetsSettingsFragment, unknown>;
export declare const IntercomSettingsFragmentDoc: DocumentNode<IntercomSettingsFragment, unknown>;
export declare const JiraProjectDataFragmentDoc: DocumentNode<JiraProjectDataFragment, unknown>;
export declare const JiraLinearMappingFragmentDoc: DocumentNode<JiraLinearMappingFragment, unknown>;
export declare const JiraSettingsFragmentDoc: DocumentNode<JiraSettingsFragment, unknown>;
export declare const SentrySettingsFragmentDoc: DocumentNode<SentrySettingsFragment, unknown>;
export declare const SlackPostSettingsFragmentDoc: DocumentNode<SlackPostSettingsFragment, unknown>;
export declare const ZendeskSettingsFragmentDoc: DocumentNode<ZendeskSettingsFragment, unknown>;
export declare const IntegrationSettingsFragmentDoc: DocumentNode<IntegrationSettingsFragment, unknown>;
export declare const SamlConfigurationFragmentDoc: DocumentNode<SamlConfigurationFragment, unknown>;
export declare const UserSettingsFragmentDoc: DocumentNode<UserSettingsFragment, unknown>;
export declare const SubscriptionFragmentDoc: DocumentNode<SubscriptionFragment, unknown>;
export declare const ApiKeyFragmentDoc: DocumentNode<ApiKeyFragment, unknown>;
export declare const PageInfoFragmentDoc: DocumentNode<PageInfoFragment, unknown>;
export declare const ApiKeyConnectionFragmentDoc: DocumentNode<ApiKeyConnectionFragment, unknown>;
export declare const ApiKeyPayloadFragmentDoc: DocumentNode<ApiKeyPayloadFragment, unknown>;
export declare const ArchivePayloadFragmentDoc: DocumentNode<ArchivePayloadFragment, unknown>;
export declare const AttachmentFragmentDoc: DocumentNode<AttachmentFragment, unknown>;
export declare const AttachmentConnectionFragmentDoc: DocumentNode<AttachmentConnectionFragment, unknown>;
export declare const AttachmentPayloadFragmentDoc: DocumentNode<AttachmentPayloadFragment, unknown>;
export declare const AuditEntryFragmentDoc: DocumentNode<AuditEntryFragment, unknown>;
export declare const AuditEntryConnectionFragmentDoc: DocumentNode<AuditEntryConnectionFragment, unknown>;
export declare const AuditEntryTypeFragmentDoc: DocumentNode<AuditEntryTypeFragment, unknown>;
export declare const OrganizationFragmentDoc: DocumentNode<OrganizationFragment, unknown>;
export declare const AuthResolverResponseFragmentDoc: DocumentNode<AuthResolverResponseFragment, unknown>;
export declare const InvoiceFragmentDoc: DocumentNode<InvoiceFragment, unknown>;
export declare const CardFragmentDoc: DocumentNode<CardFragment, unknown>;
export declare const BillingDetailsPayloadFragmentDoc: DocumentNode<BillingDetailsPayloadFragment, unknown>;
export declare const BillingEmailPayloadFragmentDoc: DocumentNode<BillingEmailPayloadFragment, unknown>;
export declare const StepsResponseFragmentDoc: DocumentNode<StepsResponseFragment, unknown>;
export declare const CollaborationDocumentUpdatePayloadFragmentDoc: DocumentNode<CollaborationDocumentUpdatePayloadFragment, unknown>;
export declare const CommentFragmentDoc: DocumentNode<CommentFragment, unknown>;
export declare const CommentConnectionFragmentDoc: DocumentNode<CommentConnectionFragment, unknown>;
export declare const CommentPayloadFragmentDoc: DocumentNode<CommentPayloadFragment, unknown>;
export declare const ContactPayloadFragmentDoc: DocumentNode<ContactPayloadFragment, unknown>;
export declare const CreateCsvExportReportPayloadFragmentDoc: DocumentNode<CreateCsvExportReportPayloadFragment, unknown>;
export declare const CreateOrJoinOrganizationResponseFragmentDoc: DocumentNode<CreateOrJoinOrganizationResponseFragment, unknown>;
export declare const CustomViewFragmentDoc: DocumentNode<CustomViewFragment, unknown>;
export declare const CustomViewConnectionFragmentDoc: DocumentNode<CustomViewConnectionFragment, unknown>;
export declare const CustomViewPayloadFragmentDoc: DocumentNode<CustomViewPayloadFragment, unknown>;
export declare const CycleFragmentDoc: DocumentNode<CycleFragment, unknown>;
export declare const CycleConnectionFragmentDoc: DocumentNode<CycleConnectionFragment, unknown>;
export declare const CyclePayloadFragmentDoc: DocumentNode<CyclePayloadFragment, unknown>;
export declare const DebugPayloadFragmentDoc: DocumentNode<DebugPayloadFragment, unknown>;
export declare const DocumentFragmentDoc: DocumentNode<DocumentFragment, unknown>;
export declare const DocumentConnectionFragmentDoc: DocumentNode<DocumentConnectionFragment, unknown>;
export declare const DocumentPayloadFragmentDoc: DocumentNode<DocumentPayloadFragment, unknown>;
export declare const DocumentVersionFragmentDoc: DocumentNode<DocumentVersionFragment, unknown>;
export declare const DocumentVersionConnectionFragmentDoc: DocumentNode<DocumentVersionConnectionFragment, unknown>;
export declare const EmailSubscribePayloadFragmentDoc: DocumentNode<EmailSubscribePayloadFragment, unknown>;
export declare const EmailUnsubscribePayloadFragmentDoc: DocumentNode<EmailUnsubscribePayloadFragment, unknown>;
export declare const EmailUserAccountAuthChallengeResponseFragmentDoc: DocumentNode<EmailUserAccountAuthChallengeResponseFragment, unknown>;
export declare const EmojiFragmentDoc: DocumentNode<EmojiFragment, unknown>;
export declare const EmojiConnectionFragmentDoc: DocumentNode<EmojiConnectionFragment, unknown>;
export declare const EmojiPayloadFragmentDoc: DocumentNode<EmojiPayloadFragment, unknown>;
export declare const EventPayloadFragmentDoc: DocumentNode<EventPayloadFragment, unknown>;
export declare const FavoriteFragmentDoc: DocumentNode<FavoriteFragment, unknown>;
export declare const FavoriteConnectionFragmentDoc: DocumentNode<FavoriteConnectionFragment, unknown>;
export declare const FavoritePayloadFragmentDoc: DocumentNode<FavoritePayloadFragment, unknown>;
export declare const FeedbackPayloadFragmentDoc: DocumentNode<FeedbackPayloadFragment, unknown>;
export declare const FigmaEmbedFragmentDoc: DocumentNode<FigmaEmbedFragment, unknown>;
export declare const FigmaEmbedPayloadFragmentDoc: DocumentNode<FigmaEmbedPayloadFragment, unknown>;
export declare const FrontAttachmentPayloadFragmentDoc: DocumentNode<FrontAttachmentPayloadFragment, unknown>;
export declare const GitHubCommitIntegrationPayloadFragmentDoc: DocumentNode<GitHubCommitIntegrationPayloadFragment, unknown>;
export declare const ImageUploadFromUrlPayloadFragmentDoc: DocumentNode<ImageUploadFromUrlPayloadFragment, unknown>;
export declare const IntegrationFragmentDoc: DocumentNode<IntegrationFragment, unknown>;
export declare const IntegrationConnectionFragmentDoc: DocumentNode<IntegrationConnectionFragment, unknown>;
export declare const IntegrationPayloadFragmentDoc: DocumentNode<IntegrationPayloadFragment, unknown>;
export declare const CommitPayloadFragmentDoc: DocumentNode<CommitPayloadFragment, unknown>;
export declare const PullRequestPayloadFragmentDoc: DocumentNode<PullRequestPayloadFragment, unknown>;
export declare const SentryIssuePayloadFragmentDoc: DocumentNode<SentryIssuePayloadFragment, unknown>;
export declare const IntegrationResourceDataFragmentDoc: DocumentNode<IntegrationResourceDataFragment, unknown>;
export declare const IntegrationResourceFragmentDoc: DocumentNode<IntegrationResourceFragment, unknown>;
export declare const IntegrationResourceConnectionFragmentDoc: DocumentNode<IntegrationResourceConnectionFragment, unknown>;
export declare const IssueFragmentDoc: DocumentNode<IssueFragment, unknown>;
export declare const IssueBatchPayloadFragmentDoc: DocumentNode<IssueBatchPayloadFragment, unknown>;
export declare const IssueConnectionFragmentDoc: DocumentNode<IssueConnectionFragment, unknown>;
export declare const IssueDescriptionHistoryFragmentDoc: DocumentNode<IssueDescriptionHistoryFragment, unknown>;
export declare const IssueDescriptionHistoryPayloadFragmentDoc: DocumentNode<IssueDescriptionHistoryPayloadFragment, unknown>;
export declare const IssueRelationHistoryPayloadFragmentDoc: DocumentNode<IssueRelationHistoryPayloadFragment, unknown>;
export declare const IssueImportFragmentDoc: DocumentNode<IssueImportFragment, unknown>;
export declare const IssueHistoryFragmentDoc: DocumentNode<IssueHistoryFragment, unknown>;
export declare const IssueHistoryConnectionFragmentDoc: DocumentNode<IssueHistoryConnectionFragment, unknown>;
export declare const IssueImportDeletePayloadFragmentDoc: DocumentNode<IssueImportDeletePayloadFragment, unknown>;
export declare const IssueImportPayloadFragmentDoc: DocumentNode<IssueImportPayloadFragment, unknown>;
export declare const IssueLabelFragmentDoc: DocumentNode<IssueLabelFragment, unknown>;
export declare const IssueLabelConnectionFragmentDoc: DocumentNode<IssueLabelConnectionFragment, unknown>;
export declare const IssueLabelPayloadFragmentDoc: DocumentNode<IssueLabelPayloadFragment, unknown>;
export declare const IssuePayloadFragmentDoc: DocumentNode<IssuePayloadFragment, unknown>;
export declare const IssuePriorityValueFragmentDoc: DocumentNode<IssuePriorityValueFragment, unknown>;
export declare const IssueRelationFragmentDoc: DocumentNode<IssueRelationFragment, unknown>;
export declare const IssueRelationConnectionFragmentDoc: DocumentNode<IssueRelationConnectionFragment, unknown>;
export declare const IssueRelationPayloadFragmentDoc: DocumentNode<IssueRelationPayloadFragment, unknown>;
export declare const MilestoneFragmentDoc: DocumentNode<MilestoneFragment, unknown>;
export declare const MilestoneConnectionFragmentDoc: DocumentNode<MilestoneConnectionFragment, unknown>;
export declare const MilestonePayloadFragmentDoc: DocumentNode<MilestonePayloadFragment, unknown>;
export declare const NotificationFragmentDoc: DocumentNode<NotificationFragment, unknown>;
export declare const NotificationConnectionFragmentDoc: DocumentNode<NotificationConnectionFragment, unknown>;
export declare const NotificationPayloadFragmentDoc: DocumentNode<NotificationPayloadFragment, unknown>;
export declare const NotificationSubscriptionFragmentDoc: DocumentNode<NotificationSubscriptionFragment, unknown>;
export declare const NotificationSubscriptionConnectionFragmentDoc: DocumentNode<NotificationSubscriptionConnectionFragment, unknown>;
export declare const NotificationSubscriptionPayloadFragmentDoc: DocumentNode<NotificationSubscriptionPayloadFragment, unknown>;
export declare const OauthAuthStringAuthorizePayloadFragmentDoc: DocumentNode<OauthAuthStringAuthorizePayloadFragment, unknown>;
export declare const OauthAuthStringChallengePayloadFragmentDoc: DocumentNode<OauthAuthStringChallengePayloadFragment, unknown>;
export declare const OauthAuthStringCheckPayloadFragmentDoc: DocumentNode<OauthAuthStringCheckPayloadFragment, unknown>;
export declare const OauthClientFragmentDoc: DocumentNode<OauthClientFragment, unknown>;
export declare const OauthClientPayloadFragmentDoc: DocumentNode<OauthClientPayloadFragment, unknown>;
export declare const OauthTokenRevokePayloadFragmentDoc: DocumentNode<OauthTokenRevokePayloadFragment, unknown>;
export declare const OrganizationCancelDeletePayloadFragmentDoc: DocumentNode<OrganizationCancelDeletePayloadFragment, unknown>;
export declare const OrganizationDeletePayloadFragmentDoc: DocumentNode<OrganizationDeletePayloadFragment, unknown>;
export declare const OrganizationDomainFragmentDoc: DocumentNode<OrganizationDomainFragment, unknown>;
export declare const OrganizationDomainPayloadFragmentDoc: DocumentNode<OrganizationDomainPayloadFragment, unknown>;
export declare const OrganizationDomainSimplePayloadFragmentDoc: DocumentNode<OrganizationDomainSimplePayloadFragment, unknown>;
export declare const OrganizationExistsPayloadFragmentDoc: DocumentNode<OrganizationExistsPayloadFragment, unknown>;
export declare const OrganizationInviteFragmentDoc: DocumentNode<OrganizationInviteFragment, unknown>;
export declare const OrganizationInviteConnectionFragmentDoc: DocumentNode<OrganizationInviteConnectionFragment, unknown>;
export declare const OrganizationInviteDetailsPayloadFragmentDoc: DocumentNode<OrganizationInviteDetailsPayloadFragment, unknown>;
export declare const OrganizationInvitePayloadFragmentDoc: DocumentNode<OrganizationInvitePayloadFragment, unknown>;
export declare const OrganizationPayloadFragmentDoc: DocumentNode<OrganizationPayloadFragment, unknown>;
export declare const ProjectFragmentDoc: DocumentNode<ProjectFragment, unknown>;
export declare const ProjectConnectionFragmentDoc: DocumentNode<ProjectConnectionFragment, unknown>;
export declare const ProjectLinkFragmentDoc: DocumentNode<ProjectLinkFragment, unknown>;
export declare const ProjectLinkConnectionFragmentDoc: DocumentNode<ProjectLinkConnectionFragment, unknown>;
export declare const ProjectLinkPayloadFragmentDoc: DocumentNode<ProjectLinkPayloadFragment, unknown>;
export declare const ProjectPayloadFragmentDoc: DocumentNode<ProjectPayloadFragment, unknown>;
export declare const PushSubscriptionFragmentDoc: DocumentNode<PushSubscriptionFragment, unknown>;
export declare const PushSubscriptionConnectionFragmentDoc: DocumentNode<PushSubscriptionConnectionFragment, unknown>;
export declare const PushSubscriptionPayloadFragmentDoc: DocumentNode<PushSubscriptionPayloadFragment, unknown>;
export declare const PushSubscriptionTestPayloadFragmentDoc: DocumentNode<PushSubscriptionTestPayloadFragment, unknown>;
export declare const ReactionFragmentDoc: DocumentNode<ReactionFragment, unknown>;
export declare const ReactionConnectionFragmentDoc: DocumentNode<ReactionConnectionFragment, unknown>;
export declare const ReactionPayloadFragmentDoc: DocumentNode<ReactionPayloadFragment, unknown>;
export declare const RotateSecretPayloadFragmentDoc: DocumentNode<RotateSecretPayloadFragment, unknown>;
export declare const SsoUrlFromEmailResponseFragmentDoc: DocumentNode<SsoUrlFromEmailResponseFragment, unknown>;
export declare const SubscriptionPayloadFragmentDoc: DocumentNode<SubscriptionPayloadFragment, unknown>;
export declare const SubscriptionSessionPayloadFragmentDoc: DocumentNode<SubscriptionSessionPayloadFragment, unknown>;
export declare const SynchronizedPayloadFragmentDoc: DocumentNode<SynchronizedPayloadFragment, unknown>;
export declare const TeamFragmentDoc: DocumentNode<TeamFragment, unknown>;
export declare const TeamConnectionFragmentDoc: DocumentNode<TeamConnectionFragment, unknown>;
export declare const TeamMembershipFragmentDoc: DocumentNode<TeamMembershipFragment, unknown>;
export declare const TeamMembershipConnectionFragmentDoc: DocumentNode<TeamMembershipConnectionFragment, unknown>;
export declare const TeamMembershipPayloadFragmentDoc: DocumentNode<TeamMembershipPayloadFragment, unknown>;
export declare const TeamPayloadFragmentDoc: DocumentNode<TeamPayloadFragment, unknown>;
export declare const TemplateConnectionFragmentDoc: DocumentNode<TemplateConnectionFragment, unknown>;
export declare const TemplatePayloadFragmentDoc: DocumentNode<TemplatePayloadFragment, unknown>;
export declare const UploadFileHeaderFragmentDoc: DocumentNode<UploadFileHeaderFragment, unknown>;
export declare const UploadFileFragmentDoc: DocumentNode<UploadFileFragment, unknown>;
export declare const UploadPayloadFragmentDoc: DocumentNode<UploadPayloadFragment, unknown>;
export declare const UserAdminPayloadFragmentDoc: DocumentNode<UserAdminPayloadFragment, unknown>;
export declare const UserConnectionFragmentDoc: DocumentNode<UserConnectionFragment, unknown>;
export declare const UserPayloadFragmentDoc: DocumentNode<UserPayloadFragment, unknown>;
export declare const UserSettingsFlagPayloadFragmentDoc: DocumentNode<UserSettingsFlagPayloadFragment, unknown>;
export declare const UserSettingsFlagsResetPayloadFragmentDoc: DocumentNode<UserSettingsFlagsResetPayloadFragment, unknown>;
export declare const UserSettingsPayloadFragmentDoc: DocumentNode<UserSettingsPayloadFragment, unknown>;
export declare const UserSubscribeToNewsletterPayloadFragmentDoc: DocumentNode<UserSubscribeToNewsletterPayloadFragment, unknown>;
export declare const ViewPreferencesFragmentDoc: DocumentNode<ViewPreferencesFragment, unknown>;
export declare const ViewPreferencesPayloadFragmentDoc: DocumentNode<ViewPreferencesPayloadFragment, unknown>;
export declare const WebhookFragmentDoc: DocumentNode<WebhookFragment, unknown>;
export declare const WebhookConnectionFragmentDoc: DocumentNode<WebhookConnectionFragment, unknown>;
export declare const WebhookPayloadFragmentDoc: DocumentNode<WebhookPayloadFragment, unknown>;
export declare const WorkflowStateFragmentDoc: DocumentNode<WorkflowStateFragment, unknown>;
export declare const WorkflowStateConnectionFragmentDoc: DocumentNode<WorkflowStateConnectionFragment, unknown>;
export declare const WorkflowStatePayloadFragmentDoc: DocumentNode<WorkflowStatePayloadFragment, unknown>;
export declare const AdministrableTeamsDocument: DocumentNode<AdministrableTeamsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<TeamFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const ApplicationWithAuthorizationDocument: DocumentNode<ApplicationWithAuthorizationQuery, Exact<{
    clientId: Scalars["String"];
    redirectUri?: Maybe<string> | undefined;
    scope: Array<Scalars["String"]> | Scalars["String"];
}>>;
export declare const AttachmentDocument: DocumentNode<AttachmentQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const AttachmentIssueDocument: DocumentNode<AttachmentIssueQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const AttachmentIssue_AttachmentsDocument: DocumentNode<AttachmentIssue_AttachmentsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<AttachmentFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const AttachmentIssue_ChildrenDocument: DocumentNode<AttachmentIssue_ChildrenQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const AttachmentIssue_CommentsDocument: DocumentNode<AttachmentIssue_CommentsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<CommentFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const AttachmentIssue_HistoryDocument: DocumentNode<AttachmentIssue_HistoryQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const AttachmentIssue_InverseRelationsDocument: DocumentNode<AttachmentIssue_InverseRelationsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const AttachmentIssue_LabelsDocument: DocumentNode<AttachmentIssue_LabelsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueLabelFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const AttachmentIssue_RelationsDocument: DocumentNode<AttachmentIssue_RelationsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const AttachmentIssue_SubscribersDocument: DocumentNode<AttachmentIssue_SubscribersQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<UserFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    includeDisabled?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const AttachmentsDocument: DocumentNode<AttachmentsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<AttachmentFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const AttachmentsForUrlDocument: DocumentNode<AttachmentsForUrlQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
    url: Scalars["String"];
}>>;
export declare const AuditEntriesDocument: DocumentNode<AuditEntriesQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<AuditEntryFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const AuditEntryTypesDocument: DocumentNode<AuditEntryTypesQuery, Exact<{
    [key: string]: never;
}>>;
export declare const AuthorizedApplicationsDocument: DocumentNode<AuthorizedApplicationsQuery, Exact<{
    [key: string]: never;
}>>;
export declare const AvailableUsersDocument: DocumentNode<AvailableUsersQuery, Exact<{
    [key: string]: never;
}>>;
export declare const BillingDetailsDocument: DocumentNode<BillingDetailsQuery, Exact<{
    [key: string]: never;
}>>;
export declare const BillingDetails_PaymentMethodDocument: DocumentNode<BillingDetails_PaymentMethodQuery, Exact<{
    [key: string]: never;
}>>;
export declare const CollaborativeDocumentJoinDocument: DocumentNode<CollaborativeDocumentJoinQuery, Exact<{
    clientId: Scalars["String"];
    issueId: Scalars["String"];
    version: Scalars["Int"];
}>>;
export declare const CollaborativeDocumentJoin_StepsDocument: DocumentNode<CollaborativeDocumentJoin_StepsQuery, Exact<{
    clientId: Scalars["String"];
    issueId: Scalars["String"];
    version: Scalars["Int"];
}>>;
export declare const CommentDocument: DocumentNode<CommentQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const CommentsDocument: DocumentNode<CommentsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<CommentFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const CustomViewDocument: DocumentNode<CustomViewQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const CustomViewsDocument: DocumentNode<CustomViewsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const CycleDocument: DocumentNode<CycleQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const Cycle_IssuesDocument: DocumentNode<Cycle_IssuesQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Cycle_UncompletedIssuesUponCloseDocument: DocumentNode<Cycle_UncompletedIssuesUponCloseQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const CyclesDocument: DocumentNode<CyclesQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<CycleFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const DocumentDocument: DocumentNode<DocumentQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const DocumentsDocument: DocumentNode<DocumentsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const EmojiDocument: DocumentNode<EmojiQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const EmojisDocument: DocumentNode<EmojisQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const FavoriteDocument: DocumentNode<FavoriteQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const Favorite_ChildrenDocument: DocumentNode<Favorite_ChildrenQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const FavoritesDocument: DocumentNode<FavoritesQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const FigmaEmbedInfoDocument: DocumentNode<FigmaEmbedInfoQuery, Exact<{
    fileId: Scalars["String"];
    nodeId?: Maybe<string> | undefined;
}>>;
export declare const FigmaEmbedInfo_FigmaEmbedDocument: DocumentNode<FigmaEmbedInfo_FigmaEmbedQuery, Exact<{
    fileId: Scalars["String"];
    nodeId?: Maybe<string> | undefined;
}>>;
export declare const IntegrationDocument: DocumentNode<IntegrationQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const IntegrationsDocument: DocumentNode<IntegrationsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const IssueDocument: DocumentNode<IssueQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const Issue_AttachmentsDocument: DocumentNode<Issue_AttachmentsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<AttachmentFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Issue_ChildrenDocument: DocumentNode<Issue_ChildrenQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Issue_CommentsDocument: DocumentNode<Issue_CommentsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<CommentFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Issue_HistoryDocument: DocumentNode<Issue_HistoryQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Issue_InverseRelationsDocument: DocumentNode<Issue_InverseRelationsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Issue_LabelsDocument: DocumentNode<Issue_LabelsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueLabelFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Issue_RelationsDocument: DocumentNode<Issue_RelationsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Issue_SubscribersDocument: DocumentNode<Issue_SubscribersQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<UserFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    includeDisabled?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const IssueImportFinishGithubOAuthDocument: DocumentNode<IssueImportFinishGithubOAuthQuery, Exact<{
    code: Scalars["String"];
}>>;
export declare const IssueLabelDocument: DocumentNode<IssueLabelQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const IssueLabel_IssuesDocument: DocumentNode<IssueLabel_IssuesQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const IssueLabelsDocument: DocumentNode<IssueLabelsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueLabelFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const IssuePriorityValuesDocument: DocumentNode<IssuePriorityValuesQuery, Exact<{
    [key: string]: never;
}>>;
export declare const IssueRelationDocument: DocumentNode<IssueRelationQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const IssueRelationsDocument: DocumentNode<IssueRelationsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const IssueSearchDocument: DocumentNode<IssueSearchQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
    query: Scalars["String"];
}>>;
export declare const IssuesDocument: DocumentNode<IssuesQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const MilestoneDocument: DocumentNode<MilestoneQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const Milestone_ProjectsDocument: DocumentNode<Milestone_ProjectsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<ProjectFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const MilestonesDocument: DocumentNode<MilestonesQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<MilestoneFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const NotificationDocument: DocumentNode<NotificationQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const NotificationSubscriptionDocument: DocumentNode<NotificationSubscriptionQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const NotificationSubscriptionsDocument: DocumentNode<NotificationSubscriptionsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const NotificationsDocument: DocumentNode<NotificationsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const OrganizationDocument: DocumentNode<OrganizationQuery, Exact<{
    [key: string]: never;
}>>;
export declare const Organization_IntegrationsDocument: DocumentNode<Organization_IntegrationsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Organization_LabelsDocument: DocumentNode<Organization_LabelsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueLabelFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Organization_MilestonesDocument: DocumentNode<Organization_MilestonesQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<MilestoneFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Organization_TeamsDocument: DocumentNode<Organization_TeamsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<TeamFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Organization_TemplatesDocument: DocumentNode<Organization_TemplatesQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Organization_UsersDocument: DocumentNode<Organization_UsersQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    includeDisabled?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const OrganizationExistsDocument: DocumentNode<OrganizationExistsQuery, Exact<{
    urlKey: Scalars["String"];
}>>;
export declare const OrganizationInviteDocument: DocumentNode<OrganizationInviteQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const OrganizationInviteDetailsDocument: DocumentNode<OrganizationInviteDetailsQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const OrganizationInvitesDocument: DocumentNode<OrganizationInvitesQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const ProjectDocument: DocumentNode<ProjectQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const Project_DocumentsDocument: DocumentNode<Project_DocumentsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Project_IssuesDocument: DocumentNode<Project_IssuesQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Project_LinksDocument: DocumentNode<Project_LinksQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Project_MembersDocument: DocumentNode<Project_MembersQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<UserFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    includeDisabled?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Project_TeamsDocument: DocumentNode<Project_TeamsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<TeamFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const ProjectLinkDocument: DocumentNode<ProjectLinkQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const ProjectLinksDocument: DocumentNode<ProjectLinksQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const ProjectsDocument: DocumentNode<ProjectsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<ProjectFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const PushSubscriptionTestDocument: DocumentNode<PushSubscriptionTestQuery, Exact<{
    [key: string]: never;
}>>;
export declare const ReactionDocument: DocumentNode<ReactionQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const ReactionsDocument: DocumentNode<ReactionsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const SsoUrlFromEmailDocument: DocumentNode<SsoUrlFromEmailQuery, Exact<{
    email: Scalars["String"];
    isDesktop?: Maybe<boolean> | undefined;
}>>;
export declare const SubscriptionDocument: DocumentNode<SubscriptionQuery, Exact<{
    [key: string]: never;
}>>;
export declare const TeamDocument: DocumentNode<TeamQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const Team_CyclesDocument: DocumentNode<Team_CyclesQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<CycleFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Team_IssuesDocument: DocumentNode<Team_IssuesQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Team_LabelsDocument: DocumentNode<Team_LabelsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueLabelFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Team_MembersDocument: DocumentNode<Team_MembersQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<UserFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    includeDisabled?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Team_MembershipsDocument: DocumentNode<Team_MembershipsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Team_ProjectsDocument: DocumentNode<Team_ProjectsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<ProjectFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Team_StatesDocument: DocumentNode<Team_StatesQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<WorkflowStateFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Team_TemplatesDocument: DocumentNode<Team_TemplatesQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Team_WebhooksDocument: DocumentNode<Team_WebhooksQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const TeamMembershipDocument: DocumentNode<TeamMembershipQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const TeamMembershipsDocument: DocumentNode<TeamMembershipsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const TeamsDocument: DocumentNode<TeamsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<TeamFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const TemplateDocument: DocumentNode<TemplateQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const TemplatesDocument: DocumentNode<TemplatesQuery, Exact<{
    [key: string]: never;
}>>;
export declare const UserDocument: DocumentNode<UserQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const User_AssignedIssuesDocument: DocumentNode<User_AssignedIssuesQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const User_CreatedIssuesDocument: DocumentNode<User_CreatedIssuesQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const User_TeamMembershipsDocument: DocumentNode<User_TeamMembershipsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const User_TeamsDocument: DocumentNode<User_TeamsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<TeamFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const UserSettingsDocument: DocumentNode<UserSettingsQuery, Exact<{
    [key: string]: never;
}>>;
export declare const UsersDocument: DocumentNode<UsersQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<UserFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    includeDisabled?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const ViewerDocument: DocumentNode<ViewerQuery, Exact<{
    [key: string]: never;
}>>;
export declare const Viewer_AssignedIssuesDocument: DocumentNode<Viewer_AssignedIssuesQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Viewer_CreatedIssuesDocument: DocumentNode<Viewer_CreatedIssuesQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Viewer_TeamMembershipsDocument: DocumentNode<Viewer_TeamMembershipsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Viewer_TeamsDocument: DocumentNode<Viewer_TeamsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<TeamFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const WebhookDocument: DocumentNode<WebhookQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const WebhooksDocument: DocumentNode<WebhooksQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const WorkflowStateDocument: DocumentNode<WorkflowStateQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const WorkflowState_IssuesDocument: DocumentNode<WorkflowState_IssuesQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const WorkflowStatesDocument: DocumentNode<WorkflowStatesQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<WorkflowStateFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const AttachmentArchiveDocument: DocumentNode<AttachmentArchiveMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const AttachmentCreateDocument: DocumentNode<AttachmentCreateMutation, Exact<{
    input: AttachmentCreateInput;
}>>;
export declare const AttachmentDeleteDocument: DocumentNode<AttachmentDeleteMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const AttachmentLinkFrontDocument: DocumentNode<AttachmentLinkFrontMutation, Exact<{
    conversationId: Scalars["String"];
    issueId: Scalars["String"];
}>>;
export declare const AttachmentLinkIntercomDocument: DocumentNode<AttachmentLinkIntercomMutation, Exact<{
    conversationId: Scalars["String"];
    issueId: Scalars["String"];
}>>;
export declare const AttachmentLinkJiraIssueDocument: DocumentNode<AttachmentLinkJiraIssueMutation, Exact<{
    issueId: Scalars["String"];
    jiraIssueId: Scalars["String"];
}>>;
export declare const AttachmentLinkUrlDocument: DocumentNode<AttachmentLinkUrlMutation, Exact<{
    issueId: Scalars["String"];
    title?: Maybe<string> | undefined;
    url: Scalars["String"];
}>>;
export declare const AttachmentLinkZendeskDocument: DocumentNode<AttachmentLinkZendeskMutation, Exact<{
    issueId: Scalars["String"];
    ticketId: Scalars["String"];
}>>;
export declare const AttachmentUpdateDocument: DocumentNode<AttachmentUpdateMutation, Exact<{
    id: Scalars["String"];
    input: AttachmentUpdateInput;
}>>;
export declare const BillingEmailUpdateDocument: DocumentNode<BillingEmailUpdateMutation, Exact<{
    input: BillingEmailUpdateInput;
}>>;
export declare const CollaborativeDocumentUpdateDocument: DocumentNode<CollaborativeDocumentUpdateMutation, Exact<{
    input: CollaborationDocumentUpdateInput;
}>>;
export declare const CommentCreateDocument: DocumentNode<CommentCreateMutation, Exact<{
    input: CommentCreateInput;
}>>;
export declare const CommentDeleteDocument: DocumentNode<CommentDeleteMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const CommentUpdateDocument: DocumentNode<CommentUpdateMutation, Exact<{
    id: Scalars["String"];
    input: CommentUpdateInput;
}>>;
export declare const ContactCreateDocument: DocumentNode<ContactCreateMutation, Exact<{
    input: ContactCreateInput;
}>>;
export declare const CreateCsvExportReportDocument: DocumentNode<CreateCsvExportReportMutation, Exact<{
    includePrivateTeamIds?: Maybe<string | string[]> | undefined;
}>>;
export declare const CreateOrganizationFromOnboardingDocument: DocumentNode<CreateOrganizationFromOnboardingMutation, Exact<{
    input: CreateOrganizationInput;
    survey?: Maybe<OnboardingCustomerSurvey> | undefined;
}>>;
export declare const CustomViewCreateDocument: DocumentNode<CustomViewCreateMutation, Exact<{
    input: CustomViewCreateInput;
}>>;
export declare const CustomViewDeleteDocument: DocumentNode<CustomViewDeleteMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const CustomViewUpdateDocument: DocumentNode<CustomViewUpdateMutation, Exact<{
    id: Scalars["String"];
    input: CustomViewUpdateInput;
}>>;
export declare const CycleArchiveDocument: DocumentNode<CycleArchiveMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const CycleCreateDocument: DocumentNode<CycleCreateMutation, Exact<{
    input: CycleCreateInput;
}>>;
export declare const CycleUpdateDocument: DocumentNode<CycleUpdateMutation, Exact<{
    id: Scalars["String"];
    input: CycleUpdateInput;
}>>;
export declare const DebugFailWithInternalErrorDocument: DocumentNode<DebugFailWithInternalErrorMutation, Exact<{
    [key: string]: never;
}>>;
export declare const DocumentCreateDocument: DocumentNode<DocumentCreateMutation, Exact<{
    input: DocumentCreateInput;
}>>;
export declare const DocumentDeleteDocument: DocumentNode<DocumentDeleteMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const DocumentUpdateDocument: DocumentNode<DocumentUpdateMutation, Exact<{
    id: Scalars["String"];
    input: DocumentUpdateInput;
}>>;
export declare const EmailSubscribeDocument: DocumentNode<EmailSubscribeMutation, Exact<{
    input: EmailSubscribeInput;
}>>;
export declare const EmailTokenUserAccountAuthDocument: DocumentNode<EmailTokenUserAccountAuthMutation, Exact<{
    input: TokenUserAccountAuthInput;
}>>;
export declare const EmailUnsubscribeDocument: DocumentNode<EmailUnsubscribeMutation, Exact<{
    input: EmailUnsubscribeInput;
}>>;
export declare const EmailUserAccountAuthChallengeDocument: DocumentNode<EmailUserAccountAuthChallengeMutation, Exact<{
    input: EmailUserAccountAuthChallengeInput;
}>>;
export declare const EmojiCreateDocument: DocumentNode<EmojiCreateMutation, Exact<{
    input: EmojiCreateInput;
}>>;
export declare const EmojiDeleteDocument: DocumentNode<EmojiDeleteMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const EventCreateDocument: DocumentNode<EventCreateMutation, Exact<{
    input: EventCreateInput;
}>>;
export declare const FavoriteCreateDocument: DocumentNode<FavoriteCreateMutation, Exact<{
    input: FavoriteCreateInput;
}>>;
export declare const FavoriteDeleteDocument: DocumentNode<FavoriteDeleteMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const FavoriteUpdateDocument: DocumentNode<FavoriteUpdateMutation, Exact<{
    id: Scalars["String"];
    input: FavoriteUpdateInput;
}>>;
export declare const FeedbackCreateDocument: DocumentNode<FeedbackCreateMutation, Exact<{
    input: FeedbackCreateInput;
}>>;
export declare const FileUploadDocument: DocumentNode<FileUploadMutation, Exact<{
    contentType: Scalars["String"];
    filename: Scalars["String"];
    metaData?: Maybe<Record<string, unknown>> | undefined;
    size: Scalars["Int"];
}>>;
export declare const GoogleUserAccountAuthDocument: DocumentNode<GoogleUserAccountAuthMutation, Exact<{
    input: GoogleUserAccountAuthInput;
}>>;
export declare const ImageUploadFromUrlDocument: DocumentNode<ImageUploadFromUrlMutation, Exact<{
    url: Scalars["String"];
}>>;
export declare const IntegrationDeleteDocument: DocumentNode<IntegrationDeleteMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const IntegrationFigmaDocument: DocumentNode<IntegrationFigmaMutation, Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
}>>;
export declare const IntegrationFrontDocument: DocumentNode<IntegrationFrontMutation, Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
}>>;
export declare const IntegrationGithubCommitCreateDocument: DocumentNode<IntegrationGithubCommitCreateMutation, Exact<{
    [key: string]: never;
}>>;
export declare const IntegrationGithubConnectDocument: DocumentNode<IntegrationGithubConnectMutation, Exact<{
    installationId: Scalars["String"];
}>>;
export declare const IntegrationGitlabConnectDocument: DocumentNode<IntegrationGitlabConnectMutation, Exact<{
    accessToken: Scalars["String"];
    gitlabUrl: Scalars["String"];
}>>;
export declare const IntegrationGoogleSheetsDocument: DocumentNode<IntegrationGoogleSheetsMutation, Exact<{
    code: Scalars["String"];
}>>;
export declare const IntegrationIntercomDocument: DocumentNode<IntegrationIntercomMutation, Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
}>>;
export declare const IntegrationIntercomDeleteDocument: DocumentNode<IntegrationIntercomDeleteMutation, Exact<{
    [key: string]: never;
}>>;
export declare const IntegrationIntercomSettingsUpdateDocument: DocumentNode<IntegrationIntercomSettingsUpdateMutation, Exact<{
    input: IntercomSettingsInput;
}>>;
export declare const IntegrationLoomDocument: DocumentNode<IntegrationLoomMutation, Exact<{
    [key: string]: never;
}>>;
export declare const IntegrationResourceArchiveDocument: DocumentNode<IntegrationResourceArchiveMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const IntegrationSentryConnectDocument: DocumentNode<IntegrationSentryConnectMutation, Exact<{
    code: Scalars["String"];
    installationId: Scalars["String"];
    organizationSlug: Scalars["String"];
}>>;
export declare const IntegrationSettingsUpdateDocument: DocumentNode<IntegrationSettingsUpdateMutation, Exact<{
    id: Scalars["String"];
    input: IntegrationSettingsInput;
}>>;
export declare const IntegrationSlackDocument: DocumentNode<IntegrationSlackMutation, Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
    shouldUseV2Auth?: Maybe<boolean> | undefined;
}>>;
export declare const IntegrationSlackImportEmojisDocument: DocumentNode<IntegrationSlackImportEmojisMutation, Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
}>>;
export declare const IntegrationSlackPersonalDocument: DocumentNode<IntegrationSlackPersonalMutation, Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
}>>;
export declare const IntegrationSlackPostDocument: DocumentNode<IntegrationSlackPostMutation, Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
    shouldUseV2Auth?: Maybe<boolean> | undefined;
    teamId: Scalars["String"];
}>>;
export declare const IntegrationSlackProjectPostDocument: DocumentNode<IntegrationSlackProjectPostMutation, Exact<{
    code: Scalars["String"];
    projectId: Scalars["String"];
    redirectUri: Scalars["String"];
}>>;
export declare const IntegrationZendeskDocument: DocumentNode<IntegrationZendeskMutation, Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
    scope: Scalars["String"];
    subdomain: Scalars["String"];
}>>;
export declare const IssueArchiveDocument: DocumentNode<IssueArchiveMutation, Exact<{
    id: Scalars["String"];
    trash?: Maybe<boolean> | undefined;
}>>;
export declare const IssueBatchUpdateDocument: DocumentNode<IssueBatchUpdateMutation, Exact<{
    ids: Array<Scalars["UUID"]> | Scalars["UUID"];
    input: IssueUpdateInput;
}>>;
export declare const IssueCreateDocument: DocumentNode<IssueCreateMutation, Exact<{
    input: IssueCreateInput;
}>>;
export declare const IssueDeleteDocument: DocumentNode<IssueDeleteMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const IssueImportCreateAsanaDocument: DocumentNode<IssueImportCreateAsanaMutation, Exact<{
    asanaTeamName: Scalars["String"];
    asanaToken: Scalars["String"];
    id?: Maybe<string> | undefined;
    includeClosedIssues?: Maybe<boolean> | undefined;
    instantProcess?: Maybe<boolean> | undefined;
    teamId: Scalars["String"];
}>>;
export declare const IssueImportCreateClubhouseDocument: DocumentNode<IssueImportCreateClubhouseMutation, Exact<{
    clubhouseTeamName: Scalars["String"];
    clubhouseToken: Scalars["String"];
    id?: Maybe<string> | undefined;
    includeClosedIssues?: Maybe<boolean> | undefined;
    instantProcess?: Maybe<boolean> | undefined;
    teamId: Scalars["String"];
}>>;
export declare const IssueImportCreateGithubDocument: DocumentNode<IssueImportCreateGithubMutation, Exact<{
    githubRepoName: Scalars["String"];
    githubRepoOwner: Scalars["String"];
    githubShouldImportOrgProjects?: Maybe<boolean> | undefined;
    githubToken: Scalars["String"];
    id?: Maybe<string> | undefined;
    includeClosedIssues?: Maybe<boolean> | undefined;
    instantProcess?: Maybe<boolean> | undefined;
    teamId: Scalars["String"];
}>>;
export declare const IssueImportCreateJiraDocument: DocumentNode<IssueImportCreateJiraMutation, Exact<{
    id?: Maybe<string> | undefined;
    includeClosedIssues?: Maybe<boolean> | undefined;
    instantProcess?: Maybe<boolean> | undefined;
    jiraEmail: Scalars["String"];
    jiraHostname: Scalars["String"];
    jiraProject: Scalars["String"];
    jiraToken: Scalars["String"];
    teamId: Scalars["String"];
}>>;
export declare const IssueImportDeleteDocument: DocumentNode<IssueImportDeleteMutation, Exact<{
    issueImportId: Scalars["String"];
}>>;
export declare const IssueImportProcessDocument: DocumentNode<IssueImportProcessMutation, Exact<{
    issueImportId: Scalars["String"];
    mapping: Scalars["JSONObject"];
}>>;
export declare const IssueImportUpdateDocument: DocumentNode<IssueImportUpdateMutation, Exact<{
    id: Scalars["String"];
    input: IssueImportUpdateInput;
}>>;
export declare const IssueLabelArchiveDocument: DocumentNode<IssueLabelArchiveMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const IssueLabelCreateDocument: DocumentNode<IssueLabelCreateMutation, Exact<{
    input: IssueLabelCreateInput;
    replaceTeamLabels?: Maybe<boolean> | undefined;
}>>;
export declare const IssueLabelUpdateDocument: DocumentNode<IssueLabelUpdateMutation, Exact<{
    id: Scalars["String"];
    input: IssueLabelUpdateInput;
}>>;
export declare const IssueRelationCreateDocument: DocumentNode<IssueRelationCreateMutation, Exact<{
    input: IssueRelationCreateInput;
}>>;
export declare const IssueRelationDeleteDocument: DocumentNode<IssueRelationDeleteMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const IssueRelationUpdateDocument: DocumentNode<IssueRelationUpdateMutation, Exact<{
    id: Scalars["String"];
    input: IssueRelationUpdateInput;
}>>;
export declare const IssueUnarchiveDocument: DocumentNode<IssueUnarchiveMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const IssueUpdateDocument: DocumentNode<IssueUpdateMutation, Exact<{
    id: Scalars["String"];
    input: IssueUpdateInput;
}>>;
export declare const JiraIntegrationConnectDocument: DocumentNode<JiraIntegrationConnectMutation, Exact<{
    input: JiraConfigurationInput;
}>>;
export declare const JoinOrganizationFromOnboardingDocument: DocumentNode<JoinOrganizationFromOnboardingMutation, Exact<{
    input: JoinOrganizationInput;
}>>;
export declare const LeaveOrganizationDocument: DocumentNode<LeaveOrganizationMutation, Exact<{
    organizationId: Scalars["String"];
}>>;
export declare const MilestoneCreateDocument: DocumentNode<MilestoneCreateMutation, Exact<{
    input: MilestoneCreateInput;
}>>;
export declare const MilestoneDeleteDocument: DocumentNode<MilestoneDeleteMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const MilestoneUpdateDocument: DocumentNode<MilestoneUpdateMutation, Exact<{
    id: Scalars["String"];
    input: MilestoneUpdateInput;
}>>;
export declare const NotificationArchiveDocument: DocumentNode<NotificationArchiveMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const NotificationCreateDocument: DocumentNode<NotificationCreateMutation, Exact<{
    id: Scalars["String"];
    input: NotificationUpdateInput;
}>>;
export declare const NotificationSubscriptionCreateDocument: DocumentNode<NotificationSubscriptionCreateMutation, Exact<{
    input: NotificationSubscriptionCreateInput;
}>>;
export declare const NotificationSubscriptionDeleteDocument: DocumentNode<NotificationSubscriptionDeleteMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const NotificationUnarchiveDocument: DocumentNode<NotificationUnarchiveMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const NotificationUpdateDocument: DocumentNode<NotificationUpdateMutation, Exact<{
    id: Scalars["String"];
    input: NotificationUpdateInput;
}>>;
export declare const OauthClientArchiveDocument: DocumentNode<OauthClientArchiveMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const OauthClientCreateDocument: DocumentNode<OauthClientCreateMutation, Exact<{
    input: OauthClientCreateInput;
}>>;
export declare const OauthClientRotateSecretDocument: DocumentNode<OauthClientRotateSecretMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const OauthClientUpdateDocument: DocumentNode<OauthClientUpdateMutation, Exact<{
    id: Scalars["String"];
    input: OauthClientUpdateInput;
}>>;
export declare const OauthTokenRevokeDocument: DocumentNode<OauthTokenRevokeMutation, Exact<{
    appId: Scalars["String"];
    scope: Array<Scalars["String"]> | Scalars["String"];
}>>;
export declare const OrganizationCancelDeleteDocument: DocumentNode<OrganizationCancelDeleteMutation, Exact<{
    [key: string]: never;
}>>;
export declare const OrganizationDeleteDocument: DocumentNode<OrganizationDeleteMutation, Exact<{
    input: DeleteOrganizationInput;
}>>;
export declare const OrganizationDeleteChallengeDocument: DocumentNode<OrganizationDeleteChallengeMutation, Exact<{
    [key: string]: never;
}>>;
export declare const OrganizationDomainCreateDocument: DocumentNode<OrganizationDomainCreateMutation, Exact<{
    input: OrganizationDomainCreateInput;
}>>;
export declare const OrganizationDomainDeleteDocument: DocumentNode<OrganizationDomainDeleteMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const OrganizationDomainVerifyDocument: DocumentNode<OrganizationDomainVerifyMutation, Exact<{
    input: OrganizationDomainVerificationInput;
}>>;
export declare const OrganizationInviteCreateDocument: DocumentNode<OrganizationInviteCreateMutation, Exact<{
    input: OrganizationInviteCreateInput;
}>>;
export declare const OrganizationInviteDeleteDocument: DocumentNode<OrganizationInviteDeleteMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const OrganizationUpdateDocument: DocumentNode<OrganizationUpdateMutation, Exact<{
    input: UpdateOrganizationInput;
}>>;
export declare const ProjectArchiveDocument: DocumentNode<ProjectArchiveMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const ProjectCreateDocument: DocumentNode<ProjectCreateMutation, Exact<{
    input: ProjectCreateInput;
}>>;
export declare const ProjectLinkCreateDocument: DocumentNode<ProjectLinkCreateMutation, Exact<{
    input: ProjectLinkCreateInput;
}>>;
export declare const ProjectLinkDeleteDocument: DocumentNode<ProjectLinkDeleteMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const ProjectLinkUpdateDocument: DocumentNode<ProjectLinkUpdateMutation, Exact<{
    id: Scalars["String"];
    input: ProjectLinkUpdateInput;
}>>;
export declare const ProjectUnarchiveDocument: DocumentNode<ProjectUnarchiveMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const ProjectUpdateDocument: DocumentNode<ProjectUpdateMutation, Exact<{
    id: Scalars["String"];
    input: ProjectUpdateInput;
}>>;
export declare const PushSubscriptionCreateDocument: DocumentNode<PushSubscriptionCreateMutation, Exact<{
    input: PushSubscriptionCreateInput;
}>>;
export declare const PushSubscriptionDeleteDocument: DocumentNode<PushSubscriptionDeleteMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const ReactionCreateDocument: DocumentNode<ReactionCreateMutation, Exact<{
    input: ReactionCreateInput;
}>>;
export declare const ReactionDeleteDocument: DocumentNode<ReactionDeleteMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const RefreshGoogleSheetsDataDocument: DocumentNode<RefreshGoogleSheetsDataMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const ResendOrganizationInviteDocument: DocumentNode<ResendOrganizationInviteMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const SamlTokenUserAccountAuthDocument: DocumentNode<SamlTokenUserAccountAuthMutation, Exact<{
    input: TokenUserAccountAuthInput;
}>>;
export declare const TeamCreateDocument: DocumentNode<TeamCreateMutation, Exact<{
    copySettingsFromTeamId?: Maybe<string> | undefined;
    input: TeamCreateInput;
}>>;
export declare const TeamDeleteDocument: DocumentNode<TeamDeleteMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const TeamKeyDeleteDocument: DocumentNode<TeamKeyDeleteMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const TeamMembershipCreateDocument: DocumentNode<TeamMembershipCreateMutation, Exact<{
    input: TeamMembershipCreateInput;
}>>;
export declare const TeamMembershipDeleteDocument: DocumentNode<TeamMembershipDeleteMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const TeamMembershipUpdateDocument: DocumentNode<TeamMembershipUpdateMutation, Exact<{
    id: Scalars["String"];
    input: TeamMembershipUpdateInput;
}>>;
export declare const TeamUpdateDocument: DocumentNode<TeamUpdateMutation, Exact<{
    id: Scalars["String"];
    input: TeamUpdateInput;
}>>;
export declare const TemplateCreateDocument: DocumentNode<TemplateCreateMutation, Exact<{
    input: TemplateCreateInput;
}>>;
export declare const TemplateDeleteDocument: DocumentNode<TemplateDeleteMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const TemplateUpdateDocument: DocumentNode<TemplateUpdateMutation, Exact<{
    id: Scalars["String"];
    input: TemplateUpdateInput;
}>>;
export declare const UserDemoteAdminDocument: DocumentNode<UserDemoteAdminMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const UserFlagUpdateDocument: DocumentNode<UserFlagUpdateMutation, Exact<{
    flag: UserFlagType;
    operation: UserFlagUpdateOperation;
}>>;
export declare const UserPromoteAdminDocument: DocumentNode<UserPromoteAdminMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const UserSettingsFlagIncrementDocument: DocumentNode<UserSettingsFlagIncrementMutation, Exact<{
    flag: Scalars["String"];
}>>;
export declare const UserSettingsFlagsResetDocument: DocumentNode<UserSettingsFlagsResetMutation, Exact<{
    [key: string]: never;
}>>;
export declare const UserSettingsUpdateDocument: DocumentNode<UserSettingsUpdateMutation, Exact<{
    id: Scalars["String"];
    input: UserSettingsUpdateInput;
}>>;
export declare const UserSubscribeToNewsletterDocument: DocumentNode<UserSubscribeToNewsletterMutation, Exact<{
    [key: string]: never;
}>>;
export declare const UserSuspendDocument: DocumentNode<UserSuspendMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const UserUnsuspendDocument: DocumentNode<UserUnsuspendMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const UserUpdateDocument: DocumentNode<UserUpdateMutation, Exact<{
    id: Scalars["String"];
    input: UpdateUserInput;
}>>;
export declare const ViewPreferencesCreateDocument: DocumentNode<ViewPreferencesCreateMutation, Exact<{
    input: ViewPreferencesCreateInput;
}>>;
export declare const ViewPreferencesDeleteDocument: DocumentNode<ViewPreferencesDeleteMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const ViewPreferencesUpdateDocument: DocumentNode<ViewPreferencesUpdateMutation, Exact<{
    id: Scalars["String"];
    input: ViewPreferencesUpdateInput;
}>>;
export declare const WebhookCreateDocument: DocumentNode<WebhookCreateMutation, Exact<{
    input: WebhookCreateInput;
}>>;
export declare const WebhookDeleteDocument: DocumentNode<WebhookDeleteMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const WebhookUpdateDocument: DocumentNode<WebhookUpdateMutation, Exact<{
    id: Scalars["String"];
    input: WebhookUpdateInput;
}>>;
export declare const WorkflowStateArchiveDocument: DocumentNode<WorkflowStateArchiveMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const WorkflowStateCreateDocument: DocumentNode<WorkflowStateCreateMutation, Exact<{
    input: WorkflowStateCreateInput;
}>>;
export declare const WorkflowStateUpdateDocument: DocumentNode<WorkflowStateUpdateMutation, Exact<{
    id: Scalars["String"];
    input: WorkflowStateUpdateInput;
}>>;
//# sourceMappingURL=_generated_documents.d.ts.map