import { DocumentNode } from "graphql/language/ast";
import * as L from "./_generated_documents";
/** The function for calling the graphql client */
export declare type LinearRequest = <Response, Variables extends Record<string, unknown>>(doc: DocumentNode, variables?: Variables) => Promise<Response>;
/**
 * Base class to provide a request function
 *
 * @param request - function to call the graphql client
 */
export declare class Request {
    protected _request: LinearRequest;
    constructor(request: LinearRequest);
}
/** Fetch return type wrapped in a promise */
export declare type LinearFetch<Response> = Promise<Response>;
/**
 * Variables required for pagination
 * Follows the Relay spec
 */
export declare type LinearConnectionVariables = {
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
/**
 * Connection models containing a list of nodes and pagination information
 * Follows the Relay spec
 */
export declare class LinearConnection<Node> extends Request {
    pageInfo: PageInfo;
    nodes: Node[];
    constructor(request: LinearRequest);
}
/**
 * The base connection class to provide pagination
 * Follows the Relay spec
 *
 * @param request - function to call the graphql client
 * @param fetch - Function to refetch the connection given different pagination variables
 * @param nodes - The list of models to initialize the connection
 * @param pageInfo - The pagination information to initialize the connection
 */
export declare class Connection<Node> extends LinearConnection<Node> {
    private _fetch;
    constructor(request: LinearRequest, fetch: (variables?: LinearConnectionVariables) => LinearFetch<LinearConnection<Node> | undefined>, nodes: Node[], pageInfo: PageInfo);
    /** Add nodes to the end of the existing nodes */
    private _appendNodes;
    /** Add nodes to the start of the existing nodes */
    private _prependNodes;
    /** Update the pagination end cursor */
    private _appendPageInfo;
    /** Update the pagination start cursor */
    private _prependPageInfo;
    /** Fetch the next page of results and append to nodes */
    fetchNext(): Promise<this>;
    /** Fetch the previous page of results and prepend to nodes */
    fetchPrevious(): Promise<this>;
}
/**
 * An API key. Grants access to the user's resources.
 *
 * @param request - function to call the graphql client
 * @param data - L.ApiKeyFragment response data
 */
export declare class ApiKey extends Request {
    constructor(request: LinearRequest, data: L.ApiKeyFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** The label of the API key. */
    label: string;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
}
/**
 * ApiKeyConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this ApiKeyConnection model
 * @param data - ApiKeyConnection response data
 */
export declare class ApiKeyConnection extends Connection<ApiKey> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<ApiKey> | undefined>, data: L.ApiKeyConnectionFragment);
}
/**
 * ApiKeyPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ApiKeyPayloadFragment response data
 */
export declare class ApiKeyPayload extends Request {
    constructor(request: LinearRequest, data: L.ApiKeyPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The API key that was created. */
    apiKey: ApiKey;
}
/**
 * Public information of the OAuth application.
 *
 * @param request - function to call the graphql client
 * @param data - L.ApplicationFragment response data
 */
export declare class Application extends Request {
    constructor(request: LinearRequest, data: L.ApplicationFragment);
    /** OAuth application's client ID. */
    clientId: string;
    /** Information about the application. */
    description?: string;
    /** Name of the developer. */
    developer: string;
    /** Url of the developer (homepage or docs). */
    developerUrl: string;
    /** Image of the application. */
    imageUrl?: string;
    /** Application name. */
    name: string;
}
/**
 * ArchivePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ArchivePayloadFragment response data
 */
export declare class ArchivePayload extends Request {
    constructor(request: LinearRequest, data: L.ArchivePayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * Contains requested archived model objects.
 *
 * @param request - function to call the graphql client
 * @param data - L.ArchiveResponseFragment response data
 */
export declare class ArchiveResponse extends Request {
    constructor(request: LinearRequest, data: L.ArchiveResponseFragment);
    /** A JSON serialized collection of model objects loaded from the archive */
    archive: string;
    /** The version of the remote database. Incremented by 1 for each migration run on the database. */
    databaseVersion: number;
    /** The total number of entities in the archive. */
    totalCount: number;
}
/**
 * [Alpha] Issue attachment (e.g. support ticket, pull request).
 *
 * @param request - function to call the graphql client
 * @param data - L.AttachmentFragment response data
 */
export declare class Attachment extends Request {
    private _creator?;
    private _issue;
    constructor(request: LinearRequest, data: L.AttachmentFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** Indicates if attachments for the same source application should be grouped in the Linear UI. */
    groupBySource: boolean;
    /** The unique identifier of the entity. */
    id: string;
    /** Custom metadata related to the attachment. */
    metadata: Record<string, unknown>;
    /** Information about the source which created the attachment. */
    source?: Record<string, unknown>;
    /** An accessor helper to source.type, defines the source type of the attachment. */
    sourceType?: Record<string, unknown>;
    /** Content for the subtitle line in the Linear attachment widget. */
    subtitle?: string;
    /** Content for the title line in the Linear attachment widget. */
    title: string;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** Location of the attachment which is also used as an identifier. */
    url: string;
    /** The creator of the attachment. */
    get creator(): LinearFetch<User> | undefined;
    /** The issue this attachment belongs to. */
    get issue(): LinearFetch<Issue> | undefined;
    /** [DEPRECATED] Archives an issue attachment. */
    archive(): LinearFetch<ArchivePayload>;
    /** [Alpha] Deletes an issue attachment. */
    delete(): LinearFetch<ArchivePayload>;
    /** [Alpha] Updates an existing issue attachment. */
    update(input: L.AttachmentUpdateInput): LinearFetch<AttachmentPayload>;
}
/**
 * AttachmentConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this AttachmentConnection model
 * @param data - AttachmentConnection response data
 */
export declare class AttachmentConnection extends Connection<Attachment> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Attachment> | undefined>, data: L.AttachmentConnectionFragment);
}
/**
 * AttachmentPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.AttachmentPayloadFragment response data
 */
export declare class AttachmentPayload extends Request {
    private _attachment;
    constructor(request: LinearRequest, data: L.AttachmentPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The issue attachment that was created. */
    get attachment(): LinearFetch<Attachment> | undefined;
}
/**
 * Workspace audit log entry object.
 *
 * @param request - function to call the graphql client
 * @param data - L.AuditEntryFragment response data
 */
export declare class AuditEntry extends Request {
    private _actor?;
    constructor(request: LinearRequest, data: L.AuditEntryFragment);
    /** The ID of the user that caused the audit entry to be created. */
    actorId?: string;
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** Country code of request resulting to audit entry. */
    countryCode?: string;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** IP from actor when entry was recorded. */
    ip?: string;
    /** Additional metadata related to the audit entry. */
    metadata?: Record<string, unknown>;
    type: string;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** The user that caused the audit entry to be created. */
    get actor(): LinearFetch<User> | undefined;
}
/**
 * AuditEntryConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this AuditEntryConnection model
 * @param data - AuditEntryConnection response data
 */
export declare class AuditEntryConnection extends Connection<AuditEntry> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<AuditEntry> | undefined>, data: L.AuditEntryConnectionFragment);
}
/**
 * AuditEntryType model
 *
 * @param request - function to call the graphql client
 * @param data - L.AuditEntryTypeFragment response data
 */
export declare class AuditEntryType extends Request {
    constructor(request: LinearRequest, data: L.AuditEntryTypeFragment);
    /** Description of the audit entry type. */
    description: string;
    /** The audit entry type. */
    type: string;
}
/**
 * AuthResolverResponse model
 *
 * @param request - function to call the graphql client
 * @param data - L.AuthResolverResponseFragment response data
 */
export declare class AuthResolverResponse extends Request {
    constructor(request: LinearRequest, data: L.AuthResolverResponseFragment);
    /** Should the signup flow allow access for the domain. */
    allowDomainAccess?: boolean;
    /** Email for the authenticated account. */
    email?: string;
    /** User account ID. */
    id: string;
    /** ID of the organization last accessed by the user. */
    lastUsedOrganizationId?: string;
    /** JWT token for authentication of the account. */
    token?: string;
    /** Organizations this account has access to, but is not yet a member. */
    availableOrganizations?: Organization[];
    /** Users belonging to this account. */
    users: User[];
}
/**
 * Public information of the OAuth application, plus the authorized scopes for a given user.
 *
 * @param request - function to call the graphql client
 * @param data - L.AuthorizedApplicationFragment response data
 */
export declare class AuthorizedApplication extends Request {
    constructor(request: LinearRequest, data: L.AuthorizedApplicationFragment);
    /** OAuth application's ID. */
    appId: string;
    /** OAuth application's client ID. */
    clientId: string;
    /** Information about the application. */
    description?: string;
    /** Name of the developer. */
    developer: string;
    /** Url of the developer (homepage or docs). */
    developerUrl: string;
    /** Image of the application. */
    imageUrl?: string;
    /** Application name. */
    name: string;
    /** Scopes that are authorized for this application for a given user. */
    scope: string[];
    /** Whether or not webhooks are enabled for the application. */
    webhooksEnabled: boolean;
}
/**
 * BillingDetailsPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.BillingDetailsPayloadFragment response data
 */
export declare class BillingDetailsPayload extends Request {
    constructor(request: LinearRequest, data: L.BillingDetailsPayloadFragment);
    /** The customer's email address the invoices are sent to. */
    email?: string;
    /** Whether the operation was successful. */
    success: boolean;
    /** List of invoices, if any. */
    invoices: Invoice[];
    /** The payment method. */
    paymentMethod?: Card;
}
/**
 * BillingEmailPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.BillingEmailPayloadFragment response data
 */
export declare class BillingEmailPayload extends Request {
    constructor(request: LinearRequest, data: L.BillingEmailPayloadFragment);
    /** The customer's email address the invoices are sent to. */
    email?: string;
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * Card model
 *
 * @param request - function to call the graphql client
 * @param data - L.CardFragment response data
 */
export declare class Card extends Request {
    constructor(request: LinearRequest, data: L.CardFragment);
    /** The brand of the card, e.g. Visa. */
    brand: string;
    /** The last four digits used to identify the card. */
    last4: string;
}
/**
 * CollaborationDocumentUpdatePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.CollaborationDocumentUpdatePayloadFragment response data
 */
export declare class CollaborationDocumentUpdatePayload extends Request {
    constructor(request: LinearRequest, data: L.CollaborationDocumentUpdatePayloadFragment);
    /** Whether the operation was successful. */
    success: boolean;
    /** Document steps the client has not seen yet and need to rebase it's local steps on. */
    steps?: StepsResponse;
}
/**
 * A comment associated with an issue.
 *
 * @param request - function to call the graphql client
 * @param data - L.CommentFragment response data
 */
export declare class Comment extends Request {
    private _issue;
    private _user;
    constructor(request: LinearRequest, data: L.CommentFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The comment content in markdown format. */
    body: string;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The time user edited the comment. */
    editedAt?: Date;
    /** The unique identifier of the entity. */
    id: string;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** Comment's URL. */
    url: string;
    /** The issue that the comment is associated with. */
    get issue(): LinearFetch<Issue> | undefined;
    /** The user who wrote the comment. */
    get user(): LinearFetch<User> | undefined;
    /** Deletes a comment. */
    delete(): LinearFetch<ArchivePayload>;
    /** Updates a comment. */
    update(input: L.CommentUpdateInput): LinearFetch<CommentPayload>;
}
/**
 * CommentConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this CommentConnection model
 * @param data - CommentConnection response data
 */
export declare class CommentConnection extends Connection<Comment> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Comment> | undefined>, data: L.CommentConnectionFragment);
}
/**
 * CommentPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.CommentPayloadFragment response data
 */
export declare class CommentPayload extends Request {
    private _comment;
    constructor(request: LinearRequest, data: L.CommentPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The comment that was created or updated. */
    get comment(): LinearFetch<Comment> | undefined;
}
/**
 * GitHub's commit data
 *
 * @param request - function to call the graphql client
 * @param data - L.CommitPayloadFragment response data
 */
export declare class CommitPayload extends Request {
    constructor(request: LinearRequest, data: L.CommitPayloadFragment);
    added: string[];
    id: string;
    message: string;
    modified: string[];
    removed: string[];
    timestamp: string;
    url: string;
}
/**
 * ContactPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ContactPayloadFragment response data
 */
export declare class ContactPayload extends Request {
    constructor(request: LinearRequest, data: L.ContactPayloadFragment);
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * CreateCsvExportReportPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.CreateCsvExportReportPayloadFragment response data
 */
export declare class CreateCsvExportReportPayload extends Request {
    constructor(request: LinearRequest, data: L.CreateCsvExportReportPayloadFragment);
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * CreateOrJoinOrganizationResponse model
 *
 * @param request - function to call the graphql client
 * @param data - L.CreateOrJoinOrganizationResponseFragment response data
 */
export declare class CreateOrJoinOrganizationResponse extends Request {
    private _user;
    constructor(request: LinearRequest, data: L.CreateOrJoinOrganizationResponseFragment);
    get organization(): LinearFetch<Organization>;
    get user(): LinearFetch<User> | undefined;
}
/**
 * A custom view that has been saved by a user.
 *
 * @param request - function to call the graphql client
 * @param data - L.CustomViewFragment response data
 */
export declare class CustomView extends Request {
    private _creator;
    private _team?;
    constructor(request: LinearRequest, data: L.CustomViewFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The color of the icon of the custom view. */
    color?: string;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The description of the custom view. */
    description?: string;
    /** [Alpha] The filter applied to issues in the custom view. */
    filterData: Record<string, unknown>;
    /** The filters applied to issues in the custom view. */
    filters: Record<string, unknown>;
    /** The icon of the custom view. */
    icon?: string;
    /** The unique identifier of the entity. */
    id: string;
    /** The name of the custom view. */
    name: string;
    /** Whether the custom view is shared with everyone in the organization. */
    shared: boolean;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** The user who created the custom view. */
    get creator(): LinearFetch<User> | undefined;
    /** The organization of the custom view. */
    get organization(): LinearFetch<Organization>;
    /** The team associated with the custom view. */
    get team(): LinearFetch<Team> | undefined;
    /** Deletes a custom view. */
    delete(): LinearFetch<ArchivePayload>;
    /** Updates a custom view. */
    update(input: L.CustomViewUpdateInput): LinearFetch<CustomViewPayload>;
}
/**
 * CustomViewConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this CustomViewConnection model
 * @param data - CustomViewConnection response data
 */
export declare class CustomViewConnection extends Connection<CustomView> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<CustomView> | undefined>, data: L.CustomViewConnectionFragment);
}
/**
 * CustomViewPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.CustomViewPayloadFragment response data
 */
export declare class CustomViewPayload extends Request {
    private _customView;
    constructor(request: LinearRequest, data: L.CustomViewPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The custom view that was created or updated. */
    get customView(): LinearFetch<CustomView> | undefined;
}
/**
 * A set of issues to be resolved in a specified amount of time.
 *
 * @param request - function to call the graphql client
 * @param data - L.CycleFragment response data
 */
export declare class Cycle extends Request {
    private _team;
    constructor(request: LinearRequest, data: L.CycleFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the cycle was automatically archived by the auto pruning process. */
    autoArchivedAt?: Date;
    /** The completion time of the cycle. If null, the cycle hasn't been completed. */
    completedAt?: Date;
    /** The number of completed issues in the cycle after each day. */
    completedIssueCountHistory: number[];
    /** The number of completed estimation points after each day. */
    completedScopeHistory: number[];
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The end time of the cycle. */
    endsAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** The total number of issues in the cycle after each day. */
    issueCountHistory: number[];
    /** The custom name of the cycle. */
    name?: string;
    /** The number of the cycle. */
    number: number;
    /** The overall progress of the cycle. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points. */
    progress: number;
    /** The total number of estimation points after each day. */
    scopeHistory: number[];
    /** The start time of the cycle. */
    startsAt: Date;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** The team that the cycle is associated with. */
    get team(): LinearFetch<Team> | undefined;
    /** Issues associated with the cycle. */
    issues(variables?: Omit<L.Cycle_IssuesQueryVariables, "id">): LinearFetch<IssueConnection>;
    /** Issues that weren't completed when the cycle was closed. */
    uncompletedIssuesUponClose(variables?: Omit<L.Cycle_UncompletedIssuesUponCloseQueryVariables, "id">): LinearFetch<IssueConnection>;
    /** Archives a cycle. */
    archive(): LinearFetch<ArchivePayload>;
    /** Updates a cycle. */
    update(input: L.CycleUpdateInput): LinearFetch<CyclePayload>;
}
/**
 * CycleConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this CycleConnection model
 * @param data - CycleConnection response data
 */
export declare class CycleConnection extends Connection<Cycle> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Cycle> | undefined>, data: L.CycleConnectionFragment);
}
/**
 * CyclePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.CyclePayloadFragment response data
 */
export declare class CyclePayload extends Request {
    private _cycle?;
    constructor(request: LinearRequest, data: L.CyclePayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The Cycle that was created or updated. */
    get cycle(): LinearFetch<Cycle> | undefined;
}
/**
 * DebugPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.DebugPayloadFragment response data
 */
export declare class DebugPayload extends Request {
    constructor(request: LinearRequest, data: L.DebugPayloadFragment);
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * Contains the requested dependencies.
 *
 * @param request - function to call the graphql client
 * @param data - L.DependencyResponseFragment response data
 */
export declare class DependencyResponse extends Request {
    constructor(request: LinearRequest, data: L.DependencyResponseFragment);
    /** A JSON serialized collection of dependencies. */
    dependencies: string;
}
/**
 * A document for a project.
 *
 * @param request - function to call the graphql client
 * @param data - L.DocumentFragment response data
 */
export declare class Document extends Request {
    private _creator;
    private _project;
    private _updatedBy;
    constructor(request: LinearRequest, data: L.DocumentFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The color of the icon. */
    color?: string;
    /** The document content in markdown format. */
    content?: string;
    /** The document content as JSON. */
    contentData?: Record<string, unknown>;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The icon of the document. */
    icon?: string;
    /** The unique identifier of the entity. */
    id: string;
    /** The document's unique URL slug. */
    slugId: string;
    /** The document title. */
    title: string;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** The user who created the document. */
    get creator(): LinearFetch<User> | undefined;
    /** The project that the document is associated with. */
    get project(): LinearFetch<Project> | undefined;
    /** The user who last updated the document. */
    get updatedBy(): LinearFetch<User> | undefined;
    /** Deletes a document. */
    delete(): LinearFetch<ArchivePayload>;
    /** Updates a document. */
    update(input: L.DocumentUpdateInput): LinearFetch<DocumentPayload>;
}
/**
 * DocumentConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this DocumentConnection model
 * @param data - DocumentConnection response data
 */
export declare class DocumentConnection extends Connection<Document> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Document> | undefined>, data: L.DocumentConnectionFragment);
}
/**
 * DocumentPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.DocumentPayloadFragment response data
 */
export declare class DocumentPayload extends Request {
    private _document;
    constructor(request: LinearRequest, data: L.DocumentPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The document that was created or updated. */
    get document(): LinearFetch<Document> | undefined;
}
/**
 * Collaborative editing steps for documents.
 *
 * @param request - function to call the graphql client
 * @param data - L.DocumentStepFragment response data
 */
export declare class DocumentStep extends Request {
    constructor(request: LinearRequest, data: L.DocumentStepFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** Connected client ID. */
    clientId: string;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** Step data. */
    step: Record<string, unknown>;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** Step version. */
    version: number;
}
/**
 * A version of a document.
 *
 * @param request - function to call the graphql client
 * @param data - L.DocumentVersionFragment response data
 */
export declare class DocumentVersion extends Request {
    private _creator;
    private _project;
    constructor(request: LinearRequest, data: L.DocumentVersionFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The document's content in markdown format. */
    content?: string;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** The version revision number. */
    revision: number;
    /** The document's title. */
    title: string;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** The user who created the version. */
    get creator(): LinearFetch<User> | undefined;
    /** The project that the document is associated with. */
    get project(): LinearFetch<Project> | undefined;
}
/**
 * DocumentVersionConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this DocumentVersionConnection model
 * @param data - DocumentVersionConnection response data
 */
export declare class DocumentVersionConnection extends Connection<DocumentVersion> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<DocumentVersion> | undefined>, data: L.DocumentVersionConnectionFragment);
}
/**
 * EmailSubscribePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.EmailSubscribePayloadFragment response data
 */
export declare class EmailSubscribePayload extends Request {
    constructor(request: LinearRequest, data: L.EmailSubscribePayloadFragment);
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * EmailUnsubscribePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.EmailUnsubscribePayloadFragment response data
 */
export declare class EmailUnsubscribePayload extends Request {
    constructor(request: LinearRequest, data: L.EmailUnsubscribePayloadFragment);
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * EmailUserAccountAuthChallengeResponse model
 *
 * @param request - function to call the graphql client
 * @param data - L.EmailUserAccountAuthChallengeResponseFragment response data
 */
export declare class EmailUserAccountAuthChallengeResponse extends Request {
    constructor(request: LinearRequest, data: L.EmailUserAccountAuthChallengeResponseFragment);
    /** Supported challenge for this user account. Can be either verificationCode or password. */
    authType: string;
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * A custom emoji.
 *
 * @param request - function to call the graphql client
 * @param data - L.EmojiFragment response data
 */
export declare class Emoji extends Request {
    private _creator;
    constructor(request: LinearRequest, data: L.EmojiFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** The emoji's name. */
    name: string;
    /** The source of the emoji. */
    source: string;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** The emoji image URL. */
    url: string;
    /** The user who created the emoji. */
    get creator(): LinearFetch<User> | undefined;
    /** The organization that the emoji belongs to. */
    get organization(): LinearFetch<Organization>;
    /** Deletes an emoji. */
    delete(): LinearFetch<ArchivePayload>;
}
/**
 * EmojiConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this EmojiConnection model
 * @param data - EmojiConnection response data
 */
export declare class EmojiConnection extends Connection<Emoji> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Emoji> | undefined>, data: L.EmojiConnectionFragment);
}
/**
 * EmojiPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.EmojiPayloadFragment response data
 */
export declare class EmojiPayload extends Request {
    private _emoji;
    constructor(request: LinearRequest, data: L.EmojiPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The emoji that was created. */
    get emoji(): LinearFetch<Emoji> | undefined;
}
/**
 * EventPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.EventPayloadFragment response data
 */
export declare class EventPayload extends Request {
    constructor(request: LinearRequest, data: L.EventPayloadFragment);
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * User favorites presented in the sidebar.
 *
 * @param request - function to call the graphql client
 * @param data - L.FavoriteFragment response data
 */
export declare class Favorite extends Request {
    private _customView?;
    private _cycle?;
    private _document?;
    private _issue?;
    private _label?;
    private _parent?;
    private _project?;
    private _projectTeam?;
    private _user;
    constructor(request: LinearRequest, data: L.FavoriteFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The name of the folder. Only applies to favorites of type folder. */
    folderName?: string;
    /** The unique identifier of the entity. */
    id: string;
    /** The order of the item in the favorites list. */
    sortOrder: number;
    /** The type of the favorite. */
    type: string;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** The favorited custom view. */
    get customView(): LinearFetch<CustomView> | undefined;
    /** The favorited cycle. */
    get cycle(): LinearFetch<Cycle> | undefined;
    /** The favorited document. */
    get document(): LinearFetch<Document> | undefined;
    /** The favorited issue. */
    get issue(): LinearFetch<Issue> | undefined;
    /** The favorited label. */
    get label(): LinearFetch<IssueLabel> | undefined;
    /** The parent folder of the favorite. */
    get parent(): LinearFetch<Favorite> | undefined;
    /** The favorited project. */
    get project(): LinearFetch<Project> | undefined;
    /** The favorited team of the project. */
    get projectTeam(): LinearFetch<Team> | undefined;
    /** The owner of the favorite. */
    get user(): LinearFetch<User> | undefined;
    /** Children of the favorite. Only applies to favorites of type folder. */
    children(variables?: Omit<L.Favorite_ChildrenQueryVariables, "id">): LinearFetch<FavoriteConnection>;
    /** Deletes a favorite reference. */
    delete(): LinearFetch<ArchivePayload>;
    /** Updates a favorite. */
    update(input: L.FavoriteUpdateInput): LinearFetch<FavoritePayload>;
}
/**
 * FavoriteConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this FavoriteConnection model
 * @param data - FavoriteConnection response data
 */
export declare class FavoriteConnection extends Connection<Favorite> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Favorite> | undefined>, data: L.FavoriteConnectionFragment);
}
/**
 * FavoritePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.FavoritePayloadFragment response data
 */
export declare class FavoritePayload extends Request {
    private _favorite;
    constructor(request: LinearRequest, data: L.FavoritePayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The object that was added as a favorite. */
    get favorite(): LinearFetch<Favorite> | undefined;
}
/**
 * FeedbackPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.FeedbackPayloadFragment response data
 */
export declare class FeedbackPayload extends Request {
    constructor(request: LinearRequest, data: L.FeedbackPayloadFragment);
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * Object representing Figma preview information.
 *
 * @param request - function to call the graphql client
 * @param data - L.FigmaEmbedFragment response data
 */
export declare class FigmaEmbed extends Request {
    constructor(request: LinearRequest, data: L.FigmaEmbedFragment);
    /** Date when the file was updated at the time of embedding. */
    lastModified: Date;
    /** Figma file name. */
    name: string;
    /** Node name. */
    nodeName?: string;
    /** Figma screenshot URL. */
    url?: string;
}
/**
 * FigmaEmbedPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.FigmaEmbedPayloadFragment response data
 */
export declare class FigmaEmbedPayload extends Request {
    constructor(request: LinearRequest, data: L.FigmaEmbedPayloadFragment);
    /** Whether the operation was successful. */
    success: boolean;
    /** Figma embed information. */
    figmaEmbed?: FigmaEmbed;
}
/**
 * FrontAttachmentPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.FrontAttachmentPayloadFragment response data
 */
export declare class FrontAttachmentPayload extends Request {
    constructor(request: LinearRequest, data: L.FrontAttachmentPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * GitHubCommitIntegrationPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.GitHubCommitIntegrationPayloadFragment response data
 */
export declare class GitHubCommitIntegrationPayload extends Request {
    private _integration?;
    constructor(request: LinearRequest, data: L.GitHubCommitIntegrationPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The webhook secret to provide to GitHub. */
    webhookSecret: string;
    /** The integration that was created or updated. */
    get integration(): LinearFetch<Integration> | undefined;
}
/**
 * GitHub OAuth token, plus information about the organizations the user is a member of.
 *
 * @param request - function to call the graphql client
 * @param data - L.GithubOAuthTokenPayloadFragment response data
 */
export declare class GithubOAuthTokenPayload extends Request {
    constructor(request: LinearRequest, data: L.GithubOAuthTokenPayloadFragment);
    /** The OAuth token if the operation to fetch it was successful. */
    token?: string;
    /** A list of the GitHub organizations the user is a member of with attached repositories. */
    organizations?: GithubOrg[];
}
/**
 * Relevant information for the GitHub organization.
 *
 * @param request - function to call the graphql client
 * @param data - L.GithubOrgFragment response data
 */
export declare class GithubOrg extends Request {
    constructor(request: LinearRequest, data: L.GithubOrgFragment);
    /** GitHub organization id. */
    id: string;
    /** The login for the GitHub organization. */
    login: string;
    /** The name of the GitHub organization. */
    name: string;
    /** Repositories that the organization owns. */
    repositories: GithubRepo[];
}
/**
 * Relevant information for the GitHub repository.
 *
 * @param request - function to call the graphql client
 * @param data - L.GithubRepoFragment response data
 */
export declare class GithubRepo extends Request {
    constructor(request: LinearRequest, data: L.GithubRepoFragment);
    /** The id of the GitHub repository. */
    id: string;
    /** The name of the GitHub repository. */
    name: string;
}
/**
 * Google Sheets specific settings.
 *
 * @param request - function to call the graphql client
 * @param data - L.GoogleSheetsSettingsFragment response data
 */
export declare class GoogleSheetsSettings extends Request {
    constructor(request: LinearRequest, data: L.GoogleSheetsSettingsFragment);
    sheetId: number;
    spreadsheetId: string;
    spreadsheetUrl: string;
    updatedIssuesAt: Date;
}
/**
 * ImageUploadFromUrlPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ImageUploadFromUrlPayloadFragment response data
 */
export declare class ImageUploadFromUrlPayload extends Request {
    constructor(request: LinearRequest, data: L.ImageUploadFromUrlPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The URL containing the image. */
    url?: string;
}
/**
 * An integration with an external service.
 *
 * @param request - function to call the graphql client
 * @param data - L.IntegrationFragment response data
 */
export declare class Integration extends Request {
    private _creator;
    private _team?;
    constructor(request: LinearRequest, data: L.IntegrationFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** The integration's type. */
    service: string;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** The user that added the integration. */
    get creator(): LinearFetch<User> | undefined;
    /** The organization that the integration is associated with. */
    get organization(): LinearFetch<Organization>;
    /** The team that the integration is associated with. */
    get team(): LinearFetch<Team> | undefined;
    /** Deletes an integration. */
    delete(): LinearFetch<ArchivePayload>;
    /** Archives an integration resource. */
    resourceArchive(): LinearFetch<ArchivePayload>;
    /** [INTERNAL] Updates the integration. */
    settingsUpdate(input: L.IntegrationSettingsInput): LinearFetch<IntegrationPayload>;
}
/**
 * IntegrationConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this IntegrationConnection model
 * @param data - IntegrationConnection response data
 */
export declare class IntegrationConnection extends Connection<Integration> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Integration> | undefined>, data: L.IntegrationConnectionFragment);
}
/**
 * IntegrationPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IntegrationPayloadFragment response data
 */
export declare class IntegrationPayload extends Request {
    private _integration?;
    constructor(request: LinearRequest, data: L.IntegrationPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The integration that was created or updated. */
    get integration(): LinearFetch<Integration> | undefined;
}
/**
 * An integration resource created by an external service.
 *
 * @param request - function to call the graphql client
 * @param data - L.IntegrationResourceFragment response data
 */
export declare class IntegrationResource extends Request {
    private _integration;
    private _issue;
    constructor(request: LinearRequest, data: L.IntegrationResourceFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** The external service resource ID. */
    resourceId: string;
    /** The integration's type. */
    resourceType: string;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** Detailed information about the external resource. */
    data: IntegrationResourceData;
    /** Pull request information for GitHub pull requests and GitLab merge requests. */
    pullRequest: PullRequestPayload;
    /** The integration that the resource is associated with. */
    get integration(): LinearFetch<Integration> | undefined;
    /** The issue that the resource is associated with. */
    get issue(): LinearFetch<Issue> | undefined;
    /** Archives an integration resource. */
    archive(): LinearFetch<ArchivePayload>;
}
/**
 * IntegrationResourceConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this IntegrationResourceConnection model
 * @param data - IntegrationResourceConnection response data
 */
export declare class IntegrationResourceConnection extends Connection<IntegrationResource> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<IntegrationResource> | undefined>, data: L.IntegrationResourceConnectionFragment);
}
/**
 * Integration resource's payload
 *
 * @param request - function to call the graphql client
 * @param data - L.IntegrationResourceDataFragment response data
 */
export declare class IntegrationResourceData extends Request {
    constructor(request: LinearRequest, data: L.IntegrationResourceDataFragment);
    /** The payload for an IntegrationResource of type 'githubCommit' */
    githubCommit?: CommitPayload;
    /** The payload for an IntegrationResource of type 'githubPullRequest' */
    githubPullRequest?: PullRequestPayload;
    /** The payload for an IntegrationResource of type 'gitlabMergeRequest' */
    gitlabMergeRequest?: PullRequestPayload;
    /** The payload for an IntegrationResource of type 'sentryIssue' */
    sentryIssue?: SentryIssuePayload;
}
/**
 * The integration resource's settings
 *
 * @param request - function to call the graphql client
 * @param data - L.IntegrationSettingsFragment response data
 */
export declare class IntegrationSettings extends Request {
    constructor(request: LinearRequest, data: L.IntegrationSettingsFragment);
    googleSheets?: GoogleSheetsSettings;
    intercom?: IntercomSettings;
    jira?: JiraSettings;
    sentry?: SentrySettings;
    slackPost?: SlackPostSettings;
    slackProjectPost?: SlackPostSettings;
    zendesk?: ZendeskSettings;
    /** [INTERNAL] Updates the integration. */
    update(id: string, input: L.IntegrationSettingsInput): LinearFetch<IntegrationPayload>;
}
/**
 * Intercom specific settings.
 *
 * @param request - function to call the graphql client
 * @param data - L.IntercomSettingsFragment response data
 */
export declare class IntercomSettings extends Request {
    constructor(request: LinearRequest, data: L.IntercomSettingsFragment);
    /** Whether an internal message should be added when someone comments on an issue. */
    sendNoteOnComment?: boolean;
    /** Whether an internal message should be added when a Linear issue changes status (for status types except completed or canceled). */
    sendNoteOnStatusChange?: boolean;
}
/**
 * Invoice model
 *
 * @param request - function to call the graphql client
 * @param data - L.InvoiceFragment response data
 */
export declare class Invoice extends Request {
    constructor(request: LinearRequest, data: L.InvoiceFragment);
    /** The creation date of the invoice. */
    created: Date;
    /** The due date of the invoice. */
    dueDate?: L.Scalars["TimelessDate"];
    /** The status of the invoice. */
    status: string;
    /** The invoice total, in cents. */
    total: number;
    /** The URL at which the invoice can be viewed or paid. */
    url?: string;
}
/**
 * An issue.
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueFragment response data
 */
export declare class Issue extends Request {
    private _assignee?;
    private _creator?;
    private _cycle?;
    private _parent?;
    private _project?;
    private _snoozedBy?;
    private _state;
    private _team;
    constructor(request: LinearRequest, data: L.IssueFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the issue was automatically archived by the auto pruning process. */
    autoArchivedAt?: Date;
    /** The time at which the issue was automatically closed by the auto pruning process. */
    autoClosedAt?: Date;
    /** The order of the item in its column on the board. */
    boardOrder: number;
    /** Suggested branch name for the issue. */
    branchName: string;
    /** The time at which the issue was moved into canceled state. */
    canceledAt?: Date;
    /** The time at which the issue was moved into completed state. */
    completedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** Returns the number of Attachment resources which are created by customer support ticketing systems (e.g. Zendesk). */
    customerTicketCount: number;
    /** The issue's description in markdown format. */
    description?: string;
    /** The date at which the issue is due. */
    dueDate?: L.Scalars["TimelessDate"];
    /** The estimate of the complexity of the issue.. */
    estimate?: number;
    /** The unique identifier of the entity. */
    id: string;
    /** Issue's human readable identifier (e.g. ENG-123). */
    identifier: string;
    /** The issue's unique number. */
    number: number;
    /** Previous identifiers of the issue if it has been moved between teams. */
    previousIdentifiers: string[];
    /** The priority of the issue. */
    priority: number;
    /** Label for the priority. */
    priorityLabel: string;
    /** The time until an issue will be snoozed in Triage view. */
    snoozedUntilAt?: Date;
    /** The order of the item in relation to other items in the organization. */
    sortOrder: number;
    /** The time at which the issue was moved into started state. */
    startedAt?: Date;
    /** The order of the item in the sub-issue list. Only set if the issue has a parent. */
    subIssueSortOrder?: number;
    /** The issue's title. */
    title: string;
    /** A flag that indicates whether the issue is in the trash bin. */
    trashed?: boolean;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** Issue URL. */
    url: string;
    /** The user to whom the issue is assigned to. */
    get assignee(): LinearFetch<User> | undefined;
    /** The user who created the issue. */
    get creator(): LinearFetch<User> | undefined;
    /** The cycle that the issue is associated with. */
    get cycle(): LinearFetch<Cycle> | undefined;
    /** The parent of the issue. */
    get parent(): LinearFetch<Issue> | undefined;
    /** The project that the issue is associated with. */
    get project(): LinearFetch<Project> | undefined;
    /** The user who snoozed the issue. */
    get snoozedBy(): LinearFetch<User> | undefined;
    /** The workflow state that the issue is associated with. */
    get state(): LinearFetch<WorkflowState> | undefined;
    /** The team that the issue is associated with. */
    get team(): LinearFetch<Team> | undefined;
    /** Attachments associated with the issue. */
    attachments(variables?: Omit<L.Issue_AttachmentsQueryVariables, "id">): LinearFetch<AttachmentConnection>;
    /** Children of the issue. */
    children(variables?: Omit<L.Issue_ChildrenQueryVariables, "id">): LinearFetch<IssueConnection>;
    /** Comments associated with the issue. */
    comments(variables?: Omit<L.Issue_CommentsQueryVariables, "id">): LinearFetch<CommentConnection>;
    /** History entries associated with the issue. */
    history(variables?: Omit<L.Issue_HistoryQueryVariables, "id">): LinearFetch<IssueHistoryConnection>;
    /** Inverse relations associated with this issue. */
    inverseRelations(variables?: Omit<L.Issue_InverseRelationsQueryVariables, "id">): LinearFetch<IssueRelationConnection>;
    /** Labels associated with this issue. */
    labels(variables?: Omit<L.Issue_LabelsQueryVariables, "id">): LinearFetch<IssueLabelConnection>;
    /** Relations associated with this issue. */
    relations(variables?: Omit<L.Issue_RelationsQueryVariables, "id">): LinearFetch<IssueRelationConnection>;
    /** Users who are subscribed to the issue. */
    subscribers(variables?: Omit<L.Issue_SubscribersQueryVariables, "id">): LinearFetch<UserConnection>;
    /** Archives an issue. */
    archive(variables?: Omit<L.IssueArchiveMutationVariables, "id">): LinearFetch<ArchivePayload>;
    /** Deletes (trashes) an issue. */
    delete(): LinearFetch<ArchivePayload>;
    /** Unarchives an issue. */
    unarchive(): LinearFetch<ArchivePayload>;
    /** Updates an issue. */
    update(input: L.IssueUpdateInput): LinearFetch<IssuePayload>;
}
/**
 * IssueBatchPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueBatchPayloadFragment response data
 */
export declare class IssueBatchPayload extends Request {
    constructor(request: LinearRequest, data: L.IssueBatchPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The issues that were updated. */
    issues: Issue[];
}
/**
 * IssueConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this IssueConnection model
 * @param data - IssueConnection response data
 */
export declare class IssueConnection extends Connection<Issue> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Issue> | undefined>, data: L.IssueConnectionFragment);
}
/**
 * IssueDescriptionHistory model
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueDescriptionHistoryFragment response data
 */
export declare class IssueDescriptionHistory extends Request {
    constructor(request: LinearRequest, data: L.IssueDescriptionHistoryFragment);
    /** The ID of the author of the change. */
    actorId?: string;
    /** The description data of the issue as a JSON serialized string. */
    descriptionData: string;
    /** The UUID of the change. */
    id: string;
    /** The type of the revision, whether it was the creation or update of the issue. */
    type: string;
    /** The date when the description was updated. */
    updatedAt: Date;
}
/**
 * IssueDescriptionHistoryPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueDescriptionHistoryPayloadFragment response data
 */
export declare class IssueDescriptionHistoryPayload extends Request {
    constructor(request: LinearRequest, data: L.IssueDescriptionHistoryPayloadFragment);
    /** Whether the operation was successful. */
    success: boolean;
    /** The issue that was created or updated. */
    history?: IssueDescriptionHistory[];
}
/**
 * A record of changes to an issue.
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueHistoryFragment response data
 */
export declare class IssueHistory extends Request {
    private _actor?;
    private _fromAssignee?;
    private _fromCycle?;
    private _fromParent?;
    private _fromProject?;
    private _fromState?;
    private _fromTeam?;
    private _issue;
    private _toAssignee?;
    private _toCycle?;
    private _toParent?;
    private _toProject?;
    private _toState?;
    private _toTeam?;
    constructor(request: LinearRequest, data: L.IssueHistoryFragment);
    /** ID's of labels that were added. */
    addedLabelIds?: string[];
    /** Whether the issue was archived or un-archived. */
    archived?: boolean;
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    autoArchived?: boolean;
    autoClosed?: boolean;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** What the due date was changed from */
    fromDueDate?: L.Scalars["TimelessDate"];
    /** What the estimate was changed from. */
    fromEstimate?: number;
    /** What the priority was changed from. */
    fromPriority?: number;
    /** What the title was changed from. */
    fromTitle?: string;
    /** The unique identifier of the entity. */
    id: string;
    /** ID's of labels that were removed. */
    removedLabelIds?: string[];
    /** Information about the integration or application which created this history entry. */
    source?: Record<string, unknown>;
    /** What the due date was changed to */
    toDueDate?: L.Scalars["TimelessDate"];
    /** What the estimate was changed to. */
    toEstimate?: number;
    /** What the priority was changed to. */
    toPriority?: number;
    /** What the title was changed to. */
    toTitle?: string;
    /** Whether the issue was trashed or un-trashed. */
    trashed?: boolean;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** Whether the issue's description was updated. */
    updatedDescription?: boolean;
    /** Changed issue relationships. */
    relationChanges?: IssueRelationHistoryPayload[];
    /** The import record. */
    issueImport?: IssueImport;
    /** The user who made these changes. If null, possibly means that the change made by an integration. */
    get actor(): LinearFetch<User> | undefined;
    /** The user from whom the issue was re-assigned from. */
    get fromAssignee(): LinearFetch<User> | undefined;
    /** The previous cycle of the issue. */
    get fromCycle(): LinearFetch<Cycle> | undefined;
    /** The previous parent of the issue. */
    get fromParent(): LinearFetch<Issue> | undefined;
    /** The previous project of the issue. */
    get fromProject(): LinearFetch<Project> | undefined;
    /** The previous workflow state of the issue. */
    get fromState(): LinearFetch<WorkflowState> | undefined;
    /** The team from which the issue was moved from. */
    get fromTeam(): LinearFetch<Team> | undefined;
    /** The issue that was changed. */
    get issue(): LinearFetch<Issue> | undefined;
    /** The user to whom the issue was assigned to. */
    get toAssignee(): LinearFetch<User> | undefined;
    /** The new cycle of the issue. */
    get toCycle(): LinearFetch<Cycle> | undefined;
    /** The new parent of the issue. */
    get toParent(): LinearFetch<Issue> | undefined;
    /** The new project of the issue. */
    get toProject(): LinearFetch<Project> | undefined;
    /** The new workflow state of the issue. */
    get toState(): LinearFetch<WorkflowState> | undefined;
    /** The team to which the issue was moved to. */
    get toTeam(): LinearFetch<Team> | undefined;
}
/**
 * IssueHistoryConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this IssueHistoryConnection model
 * @param data - IssueHistoryConnection response data
 */
export declare class IssueHistoryConnection extends Connection<IssueHistory> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<IssueHistory> | undefined>, data: L.IssueHistoryConnectionFragment);
}
/**
 * An import job for data from an external service
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueImportFragment response data
 */
export declare class IssueImport extends Request {
    constructor(request: LinearRequest, data: L.IssueImportFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The id for the user that started the job. */
    creatorId: string;
    /** User readable error message, if one has occurred during the import. */
    error?: string;
    /** The unique identifier of the entity. */
    id: string;
    /** The data mapping configuration for the import job. */
    mapping?: Record<string, unknown>;
    /** The service from which data will be imported. */
    service: string;
    /** The status for the import job. */
    status: string;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** Deletes an import job. */
    delete(issueImportId: string): LinearFetch<IssueImportDeletePayload>;
    /** Updates the mapping for the issue import. */
    update(input: L.IssueImportUpdateInput): LinearFetch<IssueImportPayload>;
}
/**
 * IssueImportDeletePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueImportDeletePayloadFragment response data
 */
export declare class IssueImportDeletePayload extends Request {
    constructor(request: LinearRequest, data: L.IssueImportDeletePayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The import job that was deleted. */
    issueImport?: IssueImport;
}
/**
 * IssueImportPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueImportPayloadFragment response data
 */
export declare class IssueImportPayload extends Request {
    constructor(request: LinearRequest, data: L.IssueImportPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The import job that was created or updated. */
    issueImport?: IssueImport;
}
/**
 * Labels that can be associated with issues.
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueLabelFragment response data
 */
export declare class IssueLabel extends Request {
    private _creator?;
    private _team?;
    constructor(request: LinearRequest, data: L.IssueLabelFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The label's color as a HEX string. */
    color: string;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The label's description. */
    description?: string;
    /** The unique identifier of the entity. */
    id: string;
    /** The label's name. */
    name: string;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** The user who created the label. */
    get creator(): LinearFetch<User> | undefined;
    get organization(): LinearFetch<Organization>;
    /** The team that the label is associated with. If null, the label is associated with the global workspace.. */
    get team(): LinearFetch<Team> | undefined;
    /** Issues associated with the label. */
    issues(variables?: Omit<L.IssueLabel_IssuesQueryVariables, "id">): LinearFetch<IssueConnection>;
    /** Archives an issue label. */
    archive(): LinearFetch<ArchivePayload>;
    /** Updates an label. */
    update(input: L.IssueLabelUpdateInput): LinearFetch<IssueLabelPayload>;
}
/**
 * IssueLabelConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this IssueLabelConnection model
 * @param data - IssueLabelConnection response data
 */
export declare class IssueLabelConnection extends Connection<IssueLabel> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<IssueLabel> | undefined>, data: L.IssueLabelConnectionFragment);
}
/**
 * IssueLabelPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueLabelPayloadFragment response data
 */
export declare class IssueLabelPayload extends Request {
    private _issueLabel;
    constructor(request: LinearRequest, data: L.IssueLabelPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The label that was created or updated. */
    get issueLabel(): LinearFetch<IssueLabel> | undefined;
}
/**
 * IssuePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IssuePayloadFragment response data
 */
export declare class IssuePayload extends Request {
    private _issue?;
    constructor(request: LinearRequest, data: L.IssuePayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The issue that was created or updated. */
    get issue(): LinearFetch<Issue> | undefined;
}
/**
 * IssuePriorityValue model
 *
 * @param request - function to call the graphql client
 * @param data - L.IssuePriorityValueFragment response data
 */
export declare class IssuePriorityValue extends Request {
    constructor(request: LinearRequest, data: L.IssuePriorityValueFragment);
    /** Priority's label. */
    label: string;
    /** Priority's number value. */
    priority: number;
}
/**
 * A relation between two issues.
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueRelationFragment response data
 */
export declare class IssueRelation extends Request {
    private _issue;
    private _relatedIssue;
    constructor(request: LinearRequest, data: L.IssueRelationFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** The relationship of the issue with the related issue. */
    type: string;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** The issue whose relationship is being described. */
    get issue(): LinearFetch<Issue> | undefined;
    /** The related issue. */
    get relatedIssue(): LinearFetch<Issue> | undefined;
    /** Deletes an issue relation. */
    delete(): LinearFetch<ArchivePayload>;
    /** Updates an issue relation. */
    update(input: L.IssueRelationUpdateInput): LinearFetch<IssueRelationPayload>;
}
/**
 * IssueRelationConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this IssueRelationConnection model
 * @param data - IssueRelationConnection response data
 */
export declare class IssueRelationConnection extends Connection<IssueRelation> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<IssueRelation> | undefined>, data: L.IssueRelationConnectionFragment);
}
/**
 * Issue relation history's payload
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueRelationHistoryPayloadFragment response data
 */
export declare class IssueRelationHistoryPayload extends Request {
    constructor(request: LinearRequest, data: L.IssueRelationHistoryPayloadFragment);
    /** The identifier of the related issue. */
    identifier: string;
    /** The type of the change. */
    type: string;
}
/**
 * IssueRelationPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueRelationPayloadFragment response data
 */
export declare class IssueRelationPayload extends Request {
    private _issueRelation;
    constructor(request: LinearRequest, data: L.IssueRelationPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The issue relation that was created or updated. */
    get issueRelation(): LinearFetch<IssueRelation> | undefined;
}
/**
 * Tuple for mapping Jira projects to Linear teams.
 *
 * @param request - function to call the graphql client
 * @param data - L.JiraLinearMappingFragment response data
 */
export declare class JiraLinearMapping extends Request {
    constructor(request: LinearRequest, data: L.JiraLinearMappingFragment);
    /** The Jira id for this project. */
    jiraProjectId: string;
    /** The Linear team id to map to the given project. */
    linearTeamId: string;
}
/**
 * Metadata about a Jira project.
 *
 * @param request - function to call the graphql client
 * @param data - L.JiraProjectDataFragment response data
 */
export declare class JiraProjectData extends Request {
    constructor(request: LinearRequest, data: L.JiraProjectDataFragment);
    /** The Jira id for this project. */
    id: string;
    /** The Jira key for this project, such as ENG. */
    key: string;
    /** The Jira name for this project, such as Engineering. */
    name: string;
}
/**
 * Jira specific settings.
 *
 * @param request - function to call the graphql client
 * @param data - L.JiraSettingsFragment response data
 */
export declare class JiraSettings extends Request {
    constructor(request: LinearRequest, data: L.JiraSettingsFragment);
    /** The mapping of Jira project id => Linear team id. */
    projectMapping?: JiraLinearMapping[];
    /** The Jira projects for the organization. */
    projects: JiraProjectData[];
}
/**
 * A milestone that contains projects.
 *
 * @param request - function to call the graphql client
 * @param data - L.MilestoneFragment response data
 */
export declare class Milestone extends Request {
    constructor(request: LinearRequest, data: L.MilestoneFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** The name of the milestone. */
    name: string;
    /** The sort order for the milestone. */
    sortOrder: number;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** The organization that the milestone belongs to. */
    get organization(): LinearFetch<Organization>;
    /** Projects associated with the milestone. */
    projects(variables?: Omit<L.Milestone_ProjectsQueryVariables, "id">): LinearFetch<ProjectConnection>;
    /** Deletes a milestone. */
    delete(): LinearFetch<ArchivePayload>;
    /** Updates a milestone. */
    update(input: L.MilestoneUpdateInput): LinearFetch<MilestonePayload>;
}
/**
 * MilestoneConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this MilestoneConnection model
 * @param data - MilestoneConnection response data
 */
export declare class MilestoneConnection extends Connection<Milestone> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Milestone> | undefined>, data: L.MilestoneConnectionFragment);
}
/**
 * MilestonePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.MilestonePayloadFragment response data
 */
export declare class MilestonePayload extends Request {
    private _milestone?;
    constructor(request: LinearRequest, data: L.MilestonePayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The milesteone that was created or updated. */
    get milestone(): LinearFetch<Milestone> | undefined;
}
/**
 * A notification sent to a user.
 *
 * @param request - function to call the graphql client
 * @param data - L.NotificationFragment response data
 */
export declare class Notification extends Request {
    private _comment?;
    private _issue;
    private _team;
    private _user;
    constructor(request: LinearRequest, data: L.NotificationFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /**
     * The time at when an email reminder for this notification was sent to the user. Null, if no email
     *     reminder has been sent.
     */
    emailedAt?: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** Name of the reaction emoji associated with the notification. */
    reactionEmoji?: string;
    /** The time at when the user marked the notification as read. Null, if the the user hasn't read the notification */
    readAt?: Date;
    /** The time until a notification will be snoozed. After that it will appear in the inbox again. */
    snoozedUntilAt?: Date;
    /** Notification type */
    type: string;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** The comment which the notification is associated with. */
    get comment(): LinearFetch<Comment> | undefined;
    /** The issue that the notification is associated with. */
    get issue(): LinearFetch<Issue> | undefined;
    /** The team which the notification is associated with. */
    get team(): LinearFetch<Team> | undefined;
    /** The recipient of the notification. */
    get user(): LinearFetch<User> | undefined;
    /** Archives a notification. */
    archive(): LinearFetch<ArchivePayload>;
    /** Unarchives a notification. */
    unarchive(): LinearFetch<ArchivePayload>;
    /** Updates a notification. */
    update(input: L.NotificationUpdateInput): LinearFetch<NotificationPayload>;
}
/**
 * NotificationConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this NotificationConnection model
 * @param data - NotificationConnection response data
 */
export declare class NotificationConnection extends Connection<Notification> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Notification> | undefined>, data: L.NotificationConnectionFragment);
}
/**
 * NotificationPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.NotificationPayloadFragment response data
 */
export declare class NotificationPayload extends Request {
    private _notification;
    constructor(request: LinearRequest, data: L.NotificationPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The notification that was created or updated. */
    get notification(): LinearFetch<Notification> | undefined;
}
/**
 * Notification subscriptions for models.
 *
 * @param request - function to call the graphql client
 * @param data - L.NotificationSubscriptionFragment response data
 */
export declare class NotificationSubscription extends Request {
    private _project?;
    private _team?;
    private _user;
    constructor(request: LinearRequest, data: L.NotificationSubscriptionFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** The type of the subscription. */
    type: string;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** Subscribed project. */
    get project(): LinearFetch<Project> | undefined;
    /** Subscribed team. */
    get team(): LinearFetch<Team> | undefined;
    /** The user associated with notification subscriptions. */
    get user(): LinearFetch<User> | undefined;
    /** Deletes a notification subscription reference. */
    delete(): LinearFetch<ArchivePayload>;
}
/**
 * NotificationSubscriptionConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this NotificationSubscriptionConnection model
 * @param data - NotificationSubscriptionConnection response data
 */
export declare class NotificationSubscriptionConnection extends Connection<NotificationSubscription> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<NotificationSubscription> | undefined>, data: L.NotificationSubscriptionConnectionFragment);
}
/**
 * NotificationSubscriptionPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.NotificationSubscriptionPayloadFragment response data
 */
export declare class NotificationSubscriptionPayload extends Request {
    private _notificationSubscription;
    constructor(request: LinearRequest, data: L.NotificationSubscriptionPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The notification subscription that was created or updated. */
    get notificationSubscription(): LinearFetch<NotificationSubscription> | undefined;
}
/**
 * OauthAuthStringAuthorizePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.OauthAuthStringAuthorizePayloadFragment response data
 */
export declare class OauthAuthStringAuthorizePayload extends Request {
    constructor(request: LinearRequest, data: L.OauthAuthStringAuthorizePayloadFragment);
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * OauthAuthStringChallengePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.OauthAuthStringChallengePayloadFragment response data
 */
export declare class OauthAuthStringChallengePayload extends Request {
    constructor(request: LinearRequest, data: L.OauthAuthStringChallengePayloadFragment);
    /** The created authentication string. */
    authString: string;
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * OauthAuthStringCheckPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.OauthAuthStringCheckPayloadFragment response data
 */
export declare class OauthAuthStringCheckPayload extends Request {
    constructor(request: LinearRequest, data: L.OauthAuthStringCheckPayloadFragment);
    /** Whether the operation was successful. */
    success: boolean;
    /** Access token for use. */
    token?: string;
}
/**
 * OAuth2 client application
 *
 * @param request - function to call the graphql client
 * @param data - L.OauthClientFragment response data
 */
export declare class OauthClient extends Request {
    constructor(request: LinearRequest, data: L.OauthClientFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** OAuth application's client ID. */
    clientId: string;
    /** OAuth application's client secret. */
    clientSecret: string;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** Information about the application. */
    description: string;
    /** Name of the developer. */
    developer: string;
    /** Url of the developer. */
    developerUrl: string;
    /** The unique identifier of the entity. */
    id: string;
    /** Image of the application. */
    imageUrl: string;
    /** OAuth application's client name. */
    name: string;
    /** Whether the OAuth application is publicly visible, or only visible to the creating workspace. */
    publicEnabled: boolean;
    /** List of allowed redirect URIs for the application. */
    redirectUris: string[];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** The resource types to request when creating new webhooks. */
    webhookResourceTypes: string[];
    /** Webhook URL */
    webhookUrl?: string;
    /** Archives an OAuth client. */
    archive(): LinearFetch<ArchivePayload>;
    /** Updates an OAuth client. */
    rotateSecret(): LinearFetch<RotateSecretPayload>;
    /** Updates an OAuth client. */
    update(input: L.OauthClientUpdateInput): LinearFetch<OauthClientPayload>;
}
/**
 * OauthClientPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.OauthClientPayloadFragment response data
 */
export declare class OauthClientPayload extends Request {
    constructor(request: LinearRequest, data: L.OauthClientPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The OAuth client application that was created or updated. */
    oauthClient: OauthClient;
}
/**
 * OauthTokenRevokePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.OauthTokenRevokePayloadFragment response data
 */
export declare class OauthTokenRevokePayload extends Request {
    constructor(request: LinearRequest, data: L.OauthTokenRevokePayloadFragment);
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * An organization. Organizations are root-level objects that contain user accounts and teams.
 *
 * @param request - function to call the graphql client
 * @param data - L.OrganizationFragment response data
 */
export declare class Organization extends Request {
    constructor(request: LinearRequest, data: L.OrganizationFragment);
    /** Allowed authentication providers, empty array means all are allowed */
    allowedAuthServices: string[];
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** Number of issues in the organization. */
    createdIssueCount: number;
    /** The time at which deletion of the organization was requested. */
    deletionRequestedAt?: Date;
    /** How git branches are formatted. If null, default formatting will be used. */
    gitBranchFormat?: string;
    /** Whether the Git integration linkback messages should be sent to private repositories. */
    gitLinkbackMessagesEnabled: boolean;
    /** Whether the Git integration linkback messages should be sent to public repositories. */
    gitPublicLinkbackMessagesEnabled: boolean;
    /** The unique identifier of the entity. */
    id: string;
    /** The organization's logo URL. */
    logoUrl?: string;
    /** The organization's name. */
    name: string;
    /** Rolling 30-day total upload volume for the organization, in megabytes. */
    periodUploadVolume: number;
    /** Whether the organization is using a roadmap. */
    roadmapEnabled: boolean;
    /** Whether SAML authentication is enabled for organization. */
    samlEnabled: boolean;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** The organization's unique URL key. */
    urlKey: string;
    /** Number of active users in the organization. */
    userCount: number;
    /** The organization's subscription to a paid plan. */
    get subscription(): LinearFetch<Subscription | undefined>;
    /** Integrations associated with the organization. */
    integrations(variables?: L.Organization_IntegrationsQueryVariables): LinearFetch<IntegrationConnection>;
    /** Labels associated with the organization. */
    labels(variables?: L.Organization_LabelsQueryVariables): LinearFetch<IssueLabelConnection>;
    /** Milestones associated with the organization. */
    milestones(variables?: L.Organization_MilestonesQueryVariables): LinearFetch<MilestoneConnection>;
    /** Teams associated with the organization. */
    teams(variables?: L.Organization_TeamsQueryVariables): LinearFetch<TeamConnection>;
    /** Templates associated with the organization. */
    templates(variables?: L.Organization_TemplatesQueryVariables): LinearFetch<TemplateConnection>;
    /** Users associated with the organization. */
    users(variables?: L.Organization_UsersQueryVariables): LinearFetch<UserConnection>;
    /** Delete's an organization. Administrator privileges required. */
    delete(input: L.DeleteOrganizationInput): LinearFetch<OrganizationDeletePayload>;
    /** Updates the user's organization. */
    update(input: L.UpdateOrganizationInput): LinearFetch<OrganizationPayload>;
}
/**
 * OrganizationCancelDeletePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.OrganizationCancelDeletePayloadFragment response data
 */
export declare class OrganizationCancelDeletePayload extends Request {
    constructor(request: LinearRequest, data: L.OrganizationCancelDeletePayloadFragment);
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * OrganizationDeletePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.OrganizationDeletePayloadFragment response data
 */
export declare class OrganizationDeletePayload extends Request {
    constructor(request: LinearRequest, data: L.OrganizationDeletePayloadFragment);
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * Defines the use of a domain by an organization.
 *
 * @param request - function to call the graphql client
 * @param data - L.OrganizationDomainFragment response data
 */
export declare class OrganizationDomain extends Request {
    private _creator?;
    constructor(request: LinearRequest, data: L.OrganizationDomainFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** Domain name */
    name: string;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** E-mail used to verify this domain */
    verificationEmail?: string;
    /** Is this domain verified */
    verified: boolean;
    /** The user who added the domain. */
    get creator(): LinearFetch<User> | undefined;
    /** Deletes a domain. */
    delete(): LinearFetch<ArchivePayload>;
}
/**
 * OrganizationDomainPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.OrganizationDomainPayloadFragment response data
 */
export declare class OrganizationDomainPayload extends Request {
    constructor(request: LinearRequest, data: L.OrganizationDomainPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The organization domain that was created or updated. */
    organizationDomain: OrganizationDomain;
}
/**
 * OrganizationDomainSimplePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.OrganizationDomainSimplePayloadFragment response data
 */
export declare class OrganizationDomainSimplePayload extends Request {
    constructor(request: LinearRequest, data: L.OrganizationDomainSimplePayloadFragment);
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * OrganizationExistsPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.OrganizationExistsPayloadFragment response data
 */
export declare class OrganizationExistsPayload extends Request {
    constructor(request: LinearRequest, data: L.OrganizationExistsPayloadFragment);
    /** Whether the organization exists. */
    exists: boolean;
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * An invitation to the organization that has been sent via email.
 *
 * @param request - function to call the graphql client
 * @param data - L.OrganizationInviteFragment response data
 */
export declare class OrganizationInvite extends Request {
    private _invitee?;
    private _inviter;
    constructor(request: LinearRequest, data: L.OrganizationInviteFragment);
    /** The time at which the invite was accepted. Null, if the invite hasn't been accepted */
    acceptedAt?: Date;
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The invitees email address. */
    email: string;
    /** The time at which the invite will be expiring. Null, if the invite shouldn't expire */
    expiresAt?: Date;
    /** The invite was sent to external address. */
    external: boolean;
    /** The unique identifier of the entity. */
    id: string;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** The user who has accepted the invite. Null, if the invite hasn't been accepted. */
    get invitee(): LinearFetch<User> | undefined;
    /** The user who created the invitation. */
    get inviter(): LinearFetch<User> | undefined;
    /** The organization that the invite is associated with. */
    get organization(): LinearFetch<Organization>;
    /** Deletes an organization invite. */
    delete(): LinearFetch<ArchivePayload>;
}
/**
 * OrganizationInviteConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this OrganizationInviteConnection model
 * @param data - OrganizationInviteConnection response data
 */
export declare class OrganizationInviteConnection extends Connection<OrganizationInvite> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<OrganizationInvite> | undefined>, data: L.OrganizationInviteConnectionFragment);
}
/**
 * OrganizationInviteDetailsPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.OrganizationInviteDetailsPayloadFragment response data
 */
export declare class OrganizationInviteDetailsPayload extends Request {
    constructor(request: LinearRequest, data: L.OrganizationInviteDetailsPayloadFragment);
    /** Whether the invite has already been accepted. */
    accepted: boolean;
    /** When the invite was created. */
    createdAt: Date;
    /** The email of the invitee */
    email: string;
    /** Whether the invite has expired. */
    expired: boolean;
    /** The name of the inviter */
    inviter: string;
    /** ID of the workspace the invite is for. */
    organizationId: string;
    /** URL of the workspace logo the invite is for. */
    organizationLogoUrl?: string;
    /** Name of the workspace the invite is for. */
    organizationName: string;
}
/**
 * OrganizationInvitePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.OrganizationInvitePayloadFragment response data
 */
export declare class OrganizationInvitePayload extends Request {
    private _organizationInvite;
    constructor(request: LinearRequest, data: L.OrganizationInvitePayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The organization invite that was created or updated. */
    get organizationInvite(): LinearFetch<OrganizationInvite> | undefined;
}
/**
 * OrganizationPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.OrganizationPayloadFragment response data
 */
export declare class OrganizationPayload extends Request {
    constructor(request: LinearRequest, data: L.OrganizationPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The organization that was created or updated. */
    get organization(): LinearFetch<Organization>;
}
/**
 * PageInfo model
 *
 * @param request - function to call the graphql client
 * @param data - L.PageInfoFragment response data
 */
export declare class PageInfo extends Request {
    constructor(request: LinearRequest, data: L.PageInfoFragment);
    /** Cursor representing the last result in the paginated results. */
    endCursor?: string;
    /** Indicates if there are more results when paginating forward. */
    hasNextPage: boolean;
    /** Indicates if there are more results when paginating backward. */
    hasPreviousPage: boolean;
    /** Cursor representing the first result in the paginated results. */
    startCursor?: string;
}
/**
 * A project.
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectFragment response data
 */
export declare class Project extends Request {
    private _creator;
    private _lead?;
    private _milestone?;
    constructor(request: LinearRequest, data: L.ProjectFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the project was automatically archived by the auto pruning process. */
    autoArchivedAt?: Date;
    /** The time at which the project was moved into canceled state. */
    canceledAt?: Date;
    /** The project's color. */
    color: string;
    /** The time at which the project was moved into completed state. */
    completedAt?: Date;
    /** The number of completed issues in the project after each week. */
    completedIssueCountHistory: number[];
    /** The number of completed estimation points after each week. */
    completedScopeHistory: number[];
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The project's description. */
    description: string;
    /** The icon of the project. */
    icon?: string;
    /** The unique identifier of the entity. */
    id: string;
    /** The total number of issues in the project after each week. */
    issueCountHistory: number[];
    /** The project's name. */
    name: string;
    /** The overall progress of the project. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points. */
    progress: number;
    /** The total number of estimation points after each week. */
    scopeHistory: number[];
    /** Whether to send new issue comment notifications to Slack. */
    slackIssueComments: boolean;
    /** Whether to send new issue status updates to Slack. */
    slackIssueStatuses: boolean;
    /** Whether to send new issue notifications to Slack. */
    slackNewIssue: boolean;
    /** The project's unique URL slug. */
    slugId: string;
    /** The sort order for the project within its milestone. */
    sortOrder: number;
    /** The time at which the project was moved into started state. */
    startedAt?: Date;
    /** The type of the state. */
    state: string;
    /** The estimated completion date of the project. */
    targetDate?: L.Scalars["TimelessDate"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** Project URL. */
    url: string;
    /** The user who created the project. */
    get creator(): LinearFetch<User> | undefined;
    /** The project lead. */
    get lead(): LinearFetch<User> | undefined;
    /** The milestone that this project is associated with. */
    get milestone(): LinearFetch<Milestone> | undefined;
    /** Documents associated with the project. */
    documents(variables?: Omit<L.Project_DocumentsQueryVariables, "id">): LinearFetch<DocumentConnection>;
    /** Issues associated with the project. */
    issues(variables?: Omit<L.Project_IssuesQueryVariables, "id">): LinearFetch<IssueConnection>;
    /** Links associated with the project. */
    links(variables?: Omit<L.Project_LinksQueryVariables, "id">): LinearFetch<ProjectLinkConnection>;
    /** Users that are members of the project. */
    members(variables?: Omit<L.Project_MembersQueryVariables, "id">): LinearFetch<UserConnection>;
    /** Teams associated with this project. */
    teams(variables?: Omit<L.Project_TeamsQueryVariables, "id">): LinearFetch<TeamConnection>;
    /** Archives a project. */
    archive(): LinearFetch<ArchivePayload>;
    /** Unarchives a project. */
    unarchive(): LinearFetch<ArchivePayload>;
    /** Updates a project. */
    update(input: L.ProjectUpdateInput): LinearFetch<ProjectPayload>;
}
/**
 * ProjectConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this ProjectConnection model
 * @param data - ProjectConnection response data
 */
export declare class ProjectConnection extends Connection<Project> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Project> | undefined>, data: L.ProjectConnectionFragment);
}
/**
 * An external link for a project.
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectLinkFragment response data
 */
export declare class ProjectLink extends Request {
    private _creator;
    private _project;
    constructor(request: LinearRequest, data: L.ProjectLinkFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** The link's label. */
    label: string;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** The link's URL. */
    url: string;
    /** The user who created the link. */
    get creator(): LinearFetch<User> | undefined;
    /** The project that the link is associated with. */
    get project(): LinearFetch<Project> | undefined;
    /** Deletes a project link. */
    delete(): LinearFetch<ArchivePayload>;
    /** Updates a project link. */
    update(input: L.ProjectLinkUpdateInput): LinearFetch<ProjectLinkPayload>;
}
/**
 * ProjectLinkConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this ProjectLinkConnection model
 * @param data - ProjectLinkConnection response data
 */
export declare class ProjectLinkConnection extends Connection<ProjectLink> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<ProjectLink> | undefined>, data: L.ProjectLinkConnectionFragment);
}
/**
 * ProjectLinkPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectLinkPayloadFragment response data
 */
export declare class ProjectLinkPayload extends Request {
    private _projectLink;
    constructor(request: LinearRequest, data: L.ProjectLinkPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The project that was created or updated. */
    get projectLink(): LinearFetch<ProjectLink> | undefined;
}
/**
 * ProjectPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectPayloadFragment response data
 */
export declare class ProjectPayload extends Request {
    private _project?;
    constructor(request: LinearRequest, data: L.ProjectPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The project that was created or updated. */
    get project(): LinearFetch<Project> | undefined;
}
/**
 * Pull request data
 *
 * @param request - function to call the graphql client
 * @param data - L.PullRequestPayloadFragment response data
 */
export declare class PullRequestPayload extends Request {
    constructor(request: LinearRequest, data: L.PullRequestPayloadFragment);
    branch: string;
    closedAt: string;
    createdAt: string;
    draft: boolean;
    id: string;
    mergedAt: string;
    number: number;
    repoLogin: string;
    repoName: string;
    status: string;
    title: string;
    updatedAt: string;
    url: string;
    userId: string;
    userLogin: string;
}
/**
 * A user's web browser push notification subscription.
 *
 * @param request - function to call the graphql client
 * @param data - L.PushSubscriptionFragment response data
 */
export declare class PushSubscription extends Request {
    constructor(request: LinearRequest, data: L.PushSubscriptionFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** Deletes a push subscription. */
    delete(): LinearFetch<PushSubscriptionPayload>;
}
/**
 * PushSubscriptionConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this PushSubscriptionConnection model
 * @param data - PushSubscriptionConnection response data
 */
export declare class PushSubscriptionConnection extends Connection<PushSubscription> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<PushSubscription> | undefined>, data: L.PushSubscriptionConnectionFragment);
}
/**
 * PushSubscriptionPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.PushSubscriptionPayloadFragment response data
 */
export declare class PushSubscriptionPayload extends Request {
    constructor(request: LinearRequest, data: L.PushSubscriptionPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * PushSubscriptionTestPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.PushSubscriptionTestPayloadFragment response data
 */
export declare class PushSubscriptionTestPayload extends Request {
    constructor(request: LinearRequest, data: L.PushSubscriptionTestPayloadFragment);
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * A reaction associated with a comment.
 *
 * @param request - function to call the graphql client
 * @param data - L.ReactionFragment response data
 */
export declare class Reaction extends Request {
    private _comment;
    private _user;
    constructor(request: LinearRequest, data: L.ReactionFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** Name of the reaction's emoji. */
    emoji: string;
    /** The unique identifier of the entity. */
    id: string;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** The comment that the reaction is associated with. */
    get comment(): LinearFetch<Comment> | undefined;
    /** The user who reacted. */
    get user(): LinearFetch<User> | undefined;
    /** Deletes a reaction. */
    delete(): LinearFetch<ArchivePayload>;
}
/**
 * ReactionConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this ReactionConnection model
 * @param data - ReactionConnection response data
 */
export declare class ReactionConnection extends Connection<Reaction> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Reaction> | undefined>, data: L.ReactionConnectionFragment);
}
/**
 * ReactionPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ReactionPayloadFragment response data
 */
export declare class ReactionPayload extends Request {
    private _reaction;
    constructor(request: LinearRequest, data: L.ReactionPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    success: boolean;
    get reaction(): LinearFetch<Reaction> | undefined;
}
/**
 * RotateSecretPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.RotateSecretPayloadFragment response data
 */
export declare class RotateSecretPayload extends Request {
    constructor(request: LinearRequest, data: L.RotateSecretPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * The integration resource's settings
 *
 * @param request - function to call the graphql client
 * @param data - L.SamlConfigurationFragment response data
 */
export declare class SamlConfiguration extends Request {
    constructor(request: LinearRequest, data: L.SamlConfigurationFragment);
    /** List of allowed email domains for SAML authentication. */
    allowedDomains?: string[];
    /** The issuer's custom entity ID. */
    issuerEntityId?: string;
    /** Binding method for authentication call. Can be either `post` (default) or `redirect`. */
    ssoBinding?: string;
    /** Sign in endpoint URL for the identity provider. */
    ssoEndpoint?: string;
    /** The algorithm of the Signing Certificate. Can be one of `sha1`, `sha256` (default), or `sha512`. */
    ssoSignAlgo?: string;
    /** X.509 Signing Certificate in string form. */
    ssoSigningCert?: string;
}
/**
 * Sentry issue data
 *
 * @param request - function to call the graphql client
 * @param data - L.SentryIssuePayloadFragment response data
 */
export declare class SentryIssuePayload extends Request {
    constructor(request: LinearRequest, data: L.SentryIssuePayloadFragment);
    /** The Sentry identifier of the actor who created the issue. */
    actorId: number;
    /** The name of the Sentry actor who created this issue. */
    actorName: string;
    /** The type of the actor who created the issue. */
    actorType: string;
    /** The date this issue was first seen. */
    firstSeen: string;
    /** The name of the first release version this issue appeared on, if available. */
    firstVersion?: string;
    /** The Sentry identifier for the issue. */
    issueId: string;
    /** The title of the issue. */
    issueTitle: string;
    /** The Sentry identifier of the project this issue belongs to. */
    projectId: number;
    /** The slug of the project this issue belongs to. */
    projectSlug: string;
    /** The shortId of the issue. */
    shortId: string;
    /** The description of the issue. */
    webUrl: string;
}
/**
 * Sentry specific settings.
 *
 * @param request - function to call the graphql client
 * @param data - L.SentrySettingsFragment response data
 */
export declare class SentrySettings extends Request {
    constructor(request: LinearRequest, data: L.SentrySettingsFragment);
    /** The slug of the Sentry organization being connected. */
    organizationSlug: string;
}
/**
 * Slack notification specific settings.
 *
 * @param request - function to call the graphql client
 * @param data - L.SlackPostSettingsFragment response data
 */
export declare class SlackPostSettings extends Request {
    constructor(request: LinearRequest, data: L.SlackPostSettingsFragment);
    channel: string;
    channelId: string;
    configurationUrl: string;
}
/**
 * SsoUrlFromEmailResponse model
 *
 * @param request - function to call the graphql client
 * @param data - L.SsoUrlFromEmailResponseFragment response data
 */
export declare class SsoUrlFromEmailResponse extends Request {
    constructor(request: LinearRequest, data: L.SsoUrlFromEmailResponseFragment);
    /** SAML SSO sign-in URL. */
    samlSsoUrl: string;
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * StepsResponse model
 *
 * @param request - function to call the graphql client
 * @param data - L.StepsResponseFragment response data
 */
export declare class StepsResponse extends Request {
    constructor(request: LinearRequest, data: L.StepsResponseFragment);
    /** List of client IDs for the document steps. */
    clientIds: string[];
    /** New document steps from the client. */
    steps?: Record<string, unknown>[];
    /** Client's document version. */
    version: number;
}
/**
 * The subscription of an organization.
 *
 * @param request - function to call the graphql client
 * @param data - L.SubscriptionFragment response data
 */
export declare class Subscription extends Request {
    private _creator?;
    constructor(request: LinearRequest, data: L.SubscriptionFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The date the subscription was canceled, if any. */
    canceledAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** The date the subscription will be billed next. */
    nextBillingAt?: Date;
    /** The subscription type of a pending change. Null if no change pending. */
    pendingChangeType?: string;
    /** The number of seats in the subscription. */
    seats: number;
    /** The subscription type. */
    type: string;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** The creator of the subscription. */
    get creator(): LinearFetch<User> | undefined;
    /** The organization that the subscription is associated with. */
    get organization(): LinearFetch<Organization>;
}
/**
 * SubscriptionPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.SubscriptionPayloadFragment response data
 */
export declare class SubscriptionPayload extends Request {
    constructor(request: LinearRequest, data: L.SubscriptionPayloadFragment);
    /** The date the subscription was set to cancel at the end of the billing period, if any. */
    canceledAt?: Date;
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The subscription entity being mutated. */
    get subscription(): LinearFetch<Subscription | undefined>;
}
/**
 * SubscriptionSessionPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.SubscriptionSessionPayloadFragment response data
 */
export declare class SubscriptionSessionPayload extends Request {
    constructor(request: LinearRequest, data: L.SubscriptionSessionPayloadFragment);
    /** The subscription session that was created or updated. */
    session?: string;
}
/**
 * Contains the requested relations.
 *
 * @param request - function to call the graphql client
 * @param data - L.SyncBatchResponseFragment response data
 */
export declare class SyncBatchResponse extends Request {
    constructor(request: LinearRequest, data: L.SyncBatchResponseFragment);
    /** A JSON serialized collection of relations model object. */
    models: string;
}
/**
 * Contains a delta sync.
 *
 * @param request - function to call the graphql client
 * @param data - L.SyncDeltaResponseFragment response data
 */
export declare class SyncDeltaResponse extends Request {
    constructor(request: LinearRequest, data: L.SyncDeltaResponseFragment);
    /** Whether the client should try loading more. */
    loadMore: boolean;
    /** Whether loading the delta was successful. In case it wasn't, the client is instructed to do a full bootstrap. */
    success: boolean;
    /** A JSON serialized collection of delta packets. */
    updates?: string;
}
/**
 * Contains either the full serialized state of the application or delta packets that the requester can
 *   apply to the local data set in order to be up-to-date.
 *
 * @param request - function to call the graphql client
 * @param data - L.SyncResponseFragment response data
 */
export declare class SyncResponse extends Request {
    constructor(request: LinearRequest, data: L.SyncResponseFragment);
    /** The version of the remote database. Incremented by 1 for each migration run on the database. */
    databaseVersion: number;
    /**
     * JSON serialized delta changes that the client can apply to its local state
     *     in order to catch up with the state of the world.
     */
    delta?: string;
    /** The last sync id covered by the response. */
    lastSyncId: number;
    /**
     * The full state of the organization as a serialized JSON object.
     *     Mutually exclusive with the delta property
     */
    state?: string;
    /** The sync groups that the user is subscribed to. */
    subscribedSyncGroups: string[];
}
/**
 * SynchronizedPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.SynchronizedPayloadFragment response data
 */
export declare class SynchronizedPayload extends Request {
    constructor(request: LinearRequest, data: L.SynchronizedPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
}
/**
 * An organizational unit that contains issues.
 *
 * @param request - function to call the graphql client
 * @param data - L.TeamFragment response data
 */
export declare class Team extends Request {
    private _activeCycle?;
    private _defaultIssueState?;
    private _defaultTemplateForMembers?;
    private _defaultTemplateForNonMembers?;
    private _draftWorkflowState?;
    private _markedAsDuplicateWorkflowState?;
    private _mergeWorkflowState?;
    private _reviewWorkflowState?;
    private _startWorkflowState?;
    private _triageIssueState?;
    constructor(request: LinearRequest, data: L.TeamFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** Period after which automatically closed and completed issues are automatically archived in months. */
    autoArchivePeriod: number;
    /** Period after which issues are automatically closed in months. Null/undefined means disabled. */
    autoClosePeriod?: number;
    /** The canceled workflow state which auto closed issues will be set to. Defaults to the first canceled state. */
    autoCloseStateId?: string;
    /** The team's color. */
    color?: string;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** Calendar feed URL (iCal) for cycles. */
    cycleCalenderUrl: string;
    /** The cooldown time after each cycle in weeks. */
    cycleCooldownTime: number;
    /** The duration of a cycle in weeks. */
    cycleDuration: number;
    /** Auto assign completed issues to current cycle. */
    cycleIssueAutoAssignCompleted: boolean;
    /** Auto assign started issues to current cycle. */
    cycleIssueAutoAssignStarted: boolean;
    /** Only allow issues issues with cycles in Active Issues. */
    cycleLockToActive: boolean;
    /** The day of the week that a new cycle starts. */
    cycleStartDay: number;
    /** Whether the team uses cycles. */
    cyclesEnabled: boolean;
    /** What to use as an default estimate for unestimated issues. */
    defaultIssueEstimate: number;
    /** The id of the default template to use for new issues created by members of the team. */
    defaultTemplateForMembersId?: string;
    /** The id of the default template to use for new issues created by non-members of the team. */
    defaultTemplateForNonMembersId?: string;
    /** The team's description. */
    description?: string;
    /** Whether to group recent issue history entries. */
    groupIssueHistory: boolean;
    /** The icon of the team. */
    icon?: string;
    /** The unique identifier of the entity. */
    id: string;
    /** Unique hash for the team to be used in invite URLs. */
    inviteHash: string;
    /** Whether to allow zeros in issues estimates. */
    issueEstimationAllowZero: boolean;
    /** Whether to add additional points to the estimate scale. */
    issueEstimationExtended: boolean;
    /** The issue estimation type to use. */
    issueEstimationType: string;
    /** Whether issues without priority should be sorted first. */
    issueOrderingNoPriorityFirst: boolean;
    /** The team's unique key. The key is used in URLs. */
    key: string;
    /** The team's name. */
    name: string;
    /** Whether the team is private or not. */
    private: boolean;
    /** Whether to send new issue comment notifications to Slack. */
    slackIssueComments: boolean;
    /** Whether to send new issue status updates to Slack. */
    slackIssueStatuses: boolean;
    /** Whether to send new issue notifications to Slack. */
    slackNewIssue: boolean;
    /** The timezone of the team. Defaults to "America/Los_Angeles" */
    timezone: string;
    /** Whether triage mode is enabled for the team or not. */
    triageEnabled: boolean;
    /** How many upcoming cycles to create. */
    upcomingCycleCount: number;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** Team's currently active cycle. */
    get activeCycle(): LinearFetch<Cycle> | undefined;
    /** The default workflow state into which issues are set when they are opened by team members. */
    get defaultIssueState(): LinearFetch<WorkflowState> | undefined;
    /** The default template to use for new issues created by members of the team. */
    get defaultTemplateForMembers(): LinearFetch<Template> | undefined;
    /** The default template to use for new issues created by non-members of the team. */
    get defaultTemplateForNonMembers(): LinearFetch<Template> | undefined;
    /** The workflow state into which issues are moved when a PR has been opened as draft. */
    get draftWorkflowState(): LinearFetch<WorkflowState> | undefined;
    /** The workflow state into which issues are moved when they are marked as a duplicate of another issue. Defaults to the first canceled state. */
    get markedAsDuplicateWorkflowState(): LinearFetch<WorkflowState> | undefined;
    /** The workflow state into which issues are moved when a PR has been merged. */
    get mergeWorkflowState(): LinearFetch<WorkflowState> | undefined;
    /** The organization that the team is associated with. */
    get organization(): LinearFetch<Organization>;
    /** The workflow state into which issues are moved when a review has been requested for the PR. */
    get reviewWorkflowState(): LinearFetch<WorkflowState> | undefined;
    /** The workflow state into which issues are moved when a PR has been opened. */
    get startWorkflowState(): LinearFetch<WorkflowState> | undefined;
    /** The workflow state into which issues are set when they are opened by non-team members or integrations if triage is enabled. */
    get triageIssueState(): LinearFetch<WorkflowState> | undefined;
    /** Cycles associated with the team. */
    cycles(variables?: Omit<L.Team_CyclesQueryVariables, "id">): LinearFetch<CycleConnection>;
    /** Issues associated with the team. */
    issues(variables?: Omit<L.Team_IssuesQueryVariables, "id">): LinearFetch<IssueConnection>;
    /** Labels associated with the team. */
    labels(variables?: Omit<L.Team_LabelsQueryVariables, "id">): LinearFetch<IssueLabelConnection>;
    /** Users who are members of this team. */
    members(variables?: Omit<L.Team_MembersQueryVariables, "id">): LinearFetch<UserConnection>;
    /** Memberships associated with the team. For easier access of the same data, use `members` query. */
    memberships(variables?: Omit<L.Team_MembershipsQueryVariables, "id">): LinearFetch<TeamMembershipConnection>;
    /** Projects associated with the team. */
    projects(variables?: Omit<L.Team_ProjectsQueryVariables, "id">): LinearFetch<ProjectConnection>;
    /** The states that define the workflow associated with the team. */
    states(variables?: Omit<L.Team_StatesQueryVariables, "id">): LinearFetch<WorkflowStateConnection>;
    /** Templates associated with the team. */
    templates(variables?: Omit<L.Team_TemplatesQueryVariables, "id">): LinearFetch<TemplateConnection>;
    /** Webhooks associated with the team. */
    webhooks(variables?: Omit<L.Team_WebhooksQueryVariables, "id">): LinearFetch<WebhookConnection>;
    /** Deletes a team. */
    delete(): LinearFetch<ArchivePayload>;
    /** Updates a team. */
    update(input: L.TeamUpdateInput): LinearFetch<TeamPayload>;
}
/**
 * TeamConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this TeamConnection model
 * @param data - TeamConnection response data
 */
export declare class TeamConnection extends Connection<Team> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Team> | undefined>, data: L.TeamConnectionFragment);
}
/**
 * Defines the membership of a user to a team.
 *
 * @param request - function to call the graphql client
 * @param data - L.TeamMembershipFragment response data
 */
export declare class TeamMembership extends Request {
    private _team;
    private _user;
    constructor(request: LinearRequest, data: L.TeamMembershipFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** Whether the user is the owner of the team */
    owner?: boolean;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** The team that the membership is associated with. */
    get team(): LinearFetch<Team> | undefined;
    /** The user that the membership is associated with. */
    get user(): LinearFetch<User> | undefined;
    /** Deletes a team membership. */
    delete(): LinearFetch<ArchivePayload>;
    /** Updates a team membership. */
    update(input: L.TeamMembershipUpdateInput): LinearFetch<TeamMembershipPayload>;
}
/**
 * TeamMembershipConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this TeamMembershipConnection model
 * @param data - TeamMembershipConnection response data
 */
export declare class TeamMembershipConnection extends Connection<TeamMembership> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<TeamMembership> | undefined>, data: L.TeamMembershipConnectionFragment);
}
/**
 * TeamMembershipPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.TeamMembershipPayloadFragment response data
 */
export declare class TeamMembershipPayload extends Request {
    private _teamMembership?;
    constructor(request: LinearRequest, data: L.TeamMembershipPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The team membership that was created or updated. */
    get teamMembership(): LinearFetch<TeamMembership> | undefined;
}
/**
 * TeamPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.TeamPayloadFragment response data
 */
export declare class TeamPayload extends Request {
    private _team?;
    constructor(request: LinearRequest, data: L.TeamPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The team that was created or updated. */
    get team(): LinearFetch<Team> | undefined;
}
/**
 * A template object used for creating entities faster.
 *
 * @param request - function to call the graphql client
 * @param data - L.TemplateFragment response data
 */
export declare class Template extends Request {
    private _creator?;
    private _team?;
    constructor(request: LinearRequest, data: L.TemplateFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** Template description. */
    description?: string;
    /** The unique identifier of the entity. */
    id: string;
    /** The name of the template. */
    name: string;
    /** Template data. */
    templateData: Record<string, unknown>;
    /** The entity type this template is for. */
    type: string;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** The user who created the template. */
    get creator(): LinearFetch<User> | undefined;
    /** The organization that the template is associated with. If null, the template is associated with a particular team. */
    get organization(): LinearFetch<Organization>;
    /** The team that the template is associated with. If null, the template is global to the workspace. */
    get team(): LinearFetch<Team> | undefined;
    /** Deletes a template. */
    delete(): LinearFetch<ArchivePayload>;
    /** Updates an existing template. */
    update(input: L.TemplateUpdateInput): LinearFetch<TemplatePayload>;
}
/**
 * TemplateConnection model
 *
 * @param request - function to call the graphql client
 * @param data - L.TemplateConnectionFragment response data
 */
export declare class TemplateConnection extends Request {
    constructor(request: LinearRequest, data: L.TemplateConnectionFragment);
    pageInfo: PageInfo;
    get nodes(): LinearFetch<Template[]>;
}
/**
 * TemplatePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.TemplatePayloadFragment response data
 */
export declare class TemplatePayload extends Request {
    private _template;
    constructor(request: LinearRequest, data: L.TemplatePayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The template that was created or updated. */
    get template(): LinearFetch<Template> | undefined;
}
/**
 * Object representing Google Cloud upload policy, plus additional data.
 *
 * @param request - function to call the graphql client
 * @param data - L.UploadFileFragment response data
 */
export declare class UploadFile extends Request {
    constructor(request: LinearRequest, data: L.UploadFileFragment);
    /** The asset URL for the uploaded file. (assigned automatically) */
    assetUrl: string;
    /** The content type. */
    contentType: string;
    /** The filename. */
    filename: string;
    metaData?: Record<string, unknown>;
    /** The size of the uploaded file. */
    size: number;
    /** The signed URL the for the uploaded file. (assigned automatically) */
    uploadUrl: string;
    headers: UploadFileHeader[];
}
/**
 * UploadFileHeader model
 *
 * @param request - function to call the graphql client
 * @param data - L.UploadFileHeaderFragment response data
 */
export declare class UploadFileHeader extends Request {
    constructor(request: LinearRequest, data: L.UploadFileHeaderFragment);
    /** Upload file header key. */
    key: string;
    /** Upload file header value. */
    value: string;
}
/**
 * UploadPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.UploadPayloadFragment response data
 */
export declare class UploadPayload extends Request {
    constructor(request: LinearRequest, data: L.UploadPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** Object describing the file to be uploaded. */
    uploadFile?: UploadFile;
}
/**
 * A user that has access to the the resources of an organization.
 *
 * @param request - function to call the graphql client
 * @param data - L.UserFragment response data
 */
export declare class User extends Request {
    constructor(request: LinearRequest, data: L.UserFragment);
    /** Whether the user account is active or disabled (suspended). */
    active: boolean;
    /** Whether the user is an organization administrator. */
    admin: boolean;
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** An URL to the user's avatar image. */
    avatarUrl?: string;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** Number of issues created. */
    createdIssueCount: number;
    /** A short description of the user, either its title or bio. */
    description?: string;
    /** Reason why is the account disabled. */
    disableReason?: string;
    /** The user's display (nick) name. Unique within each organization. */
    displayName: string;
    /** The user's email address. */
    email: string;
    /** The unique identifier of the entity. */
    id: string;
    /** Unique hash for the user to be used in invite URLs. */
    inviteHash: string;
    /** Whether the user is the currently authenticated user. */
    isMe: boolean;
    /** The last time the user was seen online. If null, the user is currently online. */
    lastSeen?: Date;
    /** The user's full name. */
    name: string;
    /** The emoji to represent the user current status. */
    statusEmoji?: string;
    /** The label of the user current status. */
    statusLabel?: string;
    /** A date at which the user current status should be cleared. */
    statusUntilAt?: Date;
    /** The local timezone of the user. */
    timezone?: string;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** User's profile URL. */
    url: string;
    /** Organization the user belongs to. */
    get organization(): LinearFetch<Organization>;
    /** Issues assigned to the user. */
    assignedIssues(variables?: Omit<L.User_AssignedIssuesQueryVariables, "id">): LinearFetch<IssueConnection>;
    /** Issues created by the user. */
    createdIssues(variables?: Omit<L.User_CreatedIssuesQueryVariables, "id">): LinearFetch<IssueConnection>;
    /** Memberships associated with the user. For easier access of the same data, use `teams` query. */
    teamMemberships(variables?: Omit<L.User_TeamMembershipsQueryVariables, "id">): LinearFetch<TeamMembershipConnection>;
    /** Teams the user is part of. */
    teams(variables?: Omit<L.User_TeamsQueryVariables, "id">): LinearFetch<TeamConnection>;
    /** Updates the user's settings. */
    settingsUpdate(input: L.UserSettingsUpdateInput): LinearFetch<UserSettingsPayload>;
    /** Suspends a user. Can only be called by an admin. */
    suspend(): LinearFetch<UserAdminPayload>;
    /** Un-suspends a user. Can only be called by an admin. */
    unsuspend(): LinearFetch<UserAdminPayload>;
    /** Updates a user. Only available to organization admins and the user themselves. */
    update(input: L.UpdateUserInput): LinearFetch<UserPayload>;
}
/**
 * A user account.
 *
 * @param request - function to call the graphql client
 * @param data - L.UserAccountFragment response data
 */
export declare class UserAccount extends Request {
    constructor(request: LinearRequest, data: L.UserAccountFragment);
    /** The time at which the model was archived. */
    archivedAt?: Date;
    /** The time at which the model was created. */
    createdAt: Date;
    /** The user's email address. */
    email: string;
    /** The models identifier. */
    id: string;
    /** The user's name. */
    name?: string;
    /** The authentication service used to create the account. */
    service: string;
    /** The time at which the model was updated. */
    updatedAt: Date;
    /** Users belonging to the account. */
    users: User[];
}
/**
 * UserAdminPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.UserAdminPayloadFragment response data
 */
export declare class UserAdminPayload extends Request {
    constructor(request: LinearRequest, data: L.UserAdminPayloadFragment);
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * Public information of the OAuth application, plus whether the application has been authorized for the given scopes.
 *
 * @param request - function to call the graphql client
 * @param data - L.UserAuthorizedApplicationFragment response data
 */
export declare class UserAuthorizedApplication extends Request {
    constructor(request: LinearRequest, data: L.UserAuthorizedApplicationFragment);
    /** OAuth application's client ID. */
    clientId: string;
    /** Whether the application was created by Linear. */
    createdByLinear: boolean;
    /** Information about the application. */
    description?: string;
    /** Name of the developer. */
    developer: string;
    /** Url of the developer (homepage or docs). */
    developerUrl: string;
    /** Image of the application. */
    imageUrl?: string;
    /** Whether the user has authorized the application for the given scopes. */
    isAuthorized: boolean;
    /** Application name. */
    name: string;
    /** Whether or not webhooks are enabled for the application. */
    webhooksEnabled: boolean;
}
/**
 * UserConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this UserConnection model
 * @param data - UserConnection response data
 */
export declare class UserConnection extends Connection<User> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<User> | undefined>, data: L.UserConnectionFragment);
}
/**
 * UserPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.UserPayloadFragment response data
 */
export declare class UserPayload extends Request {
    private _user?;
    constructor(request: LinearRequest, data: L.UserPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The user that was created or updated. */
    get user(): LinearFetch<User> | undefined;
}
/**
 * The settings of a user as a JSON object.
 *
 * @param request - function to call the graphql client
 * @param data - L.UserSettingsFragment response data
 */
export declare class UserSettings extends Request {
    private _user;
    constructor(request: LinearRequest, data: L.UserSettingsFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** The notification channel settings the user has selected. */
    notificationPreferences: Record<string, unknown>;
    /** The email types the user has unsubscribed from. */
    unsubscribedFrom: string[];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** The user associated with these settings. */
    get user(): LinearFetch<User> | undefined;
    /** Updates the user's settings. */
    update(input: L.UserSettingsUpdateInput): LinearFetch<UserSettingsPayload>;
}
/**
 * UserSettingsFlagPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.UserSettingsFlagPayloadFragment response data
 */
export declare class UserSettingsFlagPayload extends Request {
    constructor(request: LinearRequest, data: L.UserSettingsFlagPayloadFragment);
    /** The flag key which was updated. */
    flag: string;
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The flag value after update. */
    value: number;
}
/**
 * UserSettingsFlagsResetPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.UserSettingsFlagsResetPayloadFragment response data
 */
export declare class UserSettingsFlagsResetPayload extends Request {
    constructor(request: LinearRequest, data: L.UserSettingsFlagsResetPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * UserSettingsPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.UserSettingsPayloadFragment response data
 */
export declare class UserSettingsPayload extends Request {
    constructor(request: LinearRequest, data: L.UserSettingsPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The user's settings. */
    get userSettings(): LinearFetch<UserSettings>;
}
/**
 * UserSubscribeToNewsletterPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.UserSubscribeToNewsletterPayloadFragment response data
 */
export declare class UserSubscribeToNewsletterPayload extends Request {
    constructor(request: LinearRequest, data: L.UserSubscribeToNewsletterPayloadFragment);
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * View preferences.
 *
 * @param request - function to call the graphql client
 * @param data - L.ViewPreferencesFragment response data
 */
export declare class ViewPreferences extends Request {
    constructor(request: LinearRequest, data: L.ViewPreferencesFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** The view preference type. */
    type: string;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** The view type. */
    viewType: string;
    /** Deletes a ViewPreferences. */
    delete(): LinearFetch<ArchivePayload>;
    /** Updates an existing ViewPreferences object. */
    update(input: L.ViewPreferencesUpdateInput): LinearFetch<ViewPreferencesPayload>;
}
/**
 * ViewPreferencesPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ViewPreferencesPayloadFragment response data
 */
export declare class ViewPreferencesPayload extends Request {
    constructor(request: LinearRequest, data: L.ViewPreferencesPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The view preferences entity being mutated. */
    viewPreferences: ViewPreferences;
}
/**
 * A webhook used to send HTTP notifications over data updates
 *
 * @param request - function to call the graphql client
 * @param data - L.WebhookFragment response data
 */
export declare class Webhook extends Request {
    private _creator?;
    private _team;
    constructor(request: LinearRequest, data: L.WebhookFragment);
    /** Whether the Webhook is enabled for all public teams, including teams created after the webhook was created. */
    allPublicTeams: boolean;
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** Whether the Webhook is enabled. */
    enabled: boolean;
    /** The unique identifier of the entity. */
    id: string;
    /** Webhook label */
    label: string;
    /** The resource types this webhook is subscribed to. */
    resourceTypes: string[];
    /** Secret token for verifying the origin on the recipient side. */
    secret?: string;
    /** The ids of teams that the webhook is associated with. */
    teamIds: string[];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** Webhook URL */
    url?: string;
    /** The user who created the webhook. */
    get creator(): LinearFetch<User> | undefined;
    /** The team that the webhook is associated with. */
    get team(): LinearFetch<Team> | undefined;
    /** Deletes a Webhook. */
    delete(): LinearFetch<ArchivePayload>;
    /** Updates an existing Webhook. */
    update(input: L.WebhookUpdateInput): LinearFetch<WebhookPayload>;
}
/**
 * WebhookConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this WebhookConnection model
 * @param data - WebhookConnection response data
 */
export declare class WebhookConnection extends Connection<Webhook> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Webhook> | undefined>, data: L.WebhookConnectionFragment);
}
/**
 * WebhookPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.WebhookPayloadFragment response data
 */
export declare class WebhookPayload extends Request {
    private _webhook;
    constructor(request: LinearRequest, data: L.WebhookPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The webhook entity being mutated. */
    get webhook(): LinearFetch<Webhook> | undefined;
}
/**
 * A state in a team workflow.
 *
 * @param request - function to call the graphql client
 * @param data - L.WorkflowStateFragment response data
 */
export declare class WorkflowState extends Request {
    private _team;
    constructor(request: LinearRequest, data: L.WorkflowStateFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The state's UI color as a HEX string. */
    color: string;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** Description of the state. */
    description?: string;
    /** The unique identifier of the entity. */
    id: string;
    /** The state's name. */
    name: string;
    /** The position of the state in the team flow. */
    position: number;
    /** The type of the state. */
    type: string;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Date;
    /** The team to which this state belongs to. */
    get team(): LinearFetch<Team> | undefined;
    /** Issues belonging in this state. */
    issues(variables?: Omit<L.WorkflowState_IssuesQueryVariables, "id">): LinearFetch<IssueConnection>;
    /** Archives a state. Only states with issues that have all been archived can be archived. */
    archive(): LinearFetch<ArchivePayload>;
    /** Updates a state. */
    update(input: L.WorkflowStateUpdateInput): LinearFetch<WorkflowStatePayload>;
}
/**
 * WorkflowStateConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this WorkflowStateConnection model
 * @param data - WorkflowStateConnection response data
 */
export declare class WorkflowStateConnection extends Connection<WorkflowState> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<WorkflowState> | undefined>, data: L.WorkflowStateConnectionFragment);
}
/**
 * WorkflowStatePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.WorkflowStatePayloadFragment response data
 */
export declare class WorkflowStatePayload extends Request {
    private _workflowState;
    constructor(request: LinearRequest, data: L.WorkflowStatePayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The state that was created or updated. */
    get workflowState(): LinearFetch<WorkflowState> | undefined;
}
/**
 * Zendesk specific settings.
 *
 * @param request - function to call the graphql client
 * @param data - L.ZendeskSettingsFragment response data
 */
export declare class ZendeskSettings extends Request {
    constructor(request: LinearRequest, data: L.ZendeskSettingsFragment);
    /** The ID of the Linear bot user. */
    botUserId: string;
    /** The subdomain of the Zendesk organization being connected. */
    subdomain: string;
    /** The URL of the connected Zendesk organization. */
    url: string;
}
/**
 * A fetchable AdministrableTeams Query
 *
 * @param request - function to call the graphql client
 */
export declare class AdministrableTeamsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the AdministrableTeams query and return a TeamConnection
     *
     * @param variables - variables to pass into the AdministrableTeamsQuery
     * @returns parsed response from AdministrableTeamsQuery
     */
    fetch(variables?: L.AdministrableTeamsQueryVariables): LinearFetch<TeamConnection>;
}
/**
 * A fetchable ApplicationWithAuthorization Query
 *
 * @param request - function to call the graphql client
 */
export declare class ApplicationWithAuthorizationQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ApplicationWithAuthorization query and return a UserAuthorizedApplication
     *
     * @param clientId - required clientId to pass to applicationWithAuthorization
     * @param scope - required scope to pass to applicationWithAuthorization
     * @param variables - variables without 'clientId', 'scope' to pass into the ApplicationWithAuthorizationQuery
     * @returns parsed response from ApplicationWithAuthorizationQuery
     */
    fetch(clientId: string, scope: string[], variables?: Omit<L.ApplicationWithAuthorizationQueryVariables, "clientId" | "scope">): LinearFetch<UserAuthorizedApplication>;
}
/**
 * A fetchable Attachment Query
 *
 * @param request - function to call the graphql client
 */
export declare class AttachmentQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Attachment query and return a Attachment
     *
     * @param id - required id to pass to attachment
     * @returns parsed response from AttachmentQuery
     */
    fetch(id: string): LinearFetch<Attachment>;
}
/**
 * A fetchable AttachmentIssue Query
 *
 * @param request - function to call the graphql client
 */
export declare class AttachmentIssueQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the AttachmentIssue query and return a Issue
     *
     * @param id - required id to pass to attachmentIssue
     * @returns parsed response from AttachmentIssueQuery
     */
    fetch(id: string): LinearFetch<Issue>;
}
/**
 * A fetchable Attachments Query
 *
 * @param request - function to call the graphql client
 */
export declare class AttachmentsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Attachments query and return a AttachmentConnection
     *
     * @param variables - variables to pass into the AttachmentsQuery
     * @returns parsed response from AttachmentsQuery
     */
    fetch(variables?: L.AttachmentsQueryVariables): LinearFetch<AttachmentConnection>;
}
/**
 * A fetchable AttachmentsForUrl Query
 *
 * @param request - function to call the graphql client
 */
export declare class AttachmentsForUrlQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the AttachmentsForUrl query and return a AttachmentConnection
     *
     * @param url - required url to pass to attachmentsForURL
     * @param variables - variables without 'url' to pass into the AttachmentsForUrlQuery
     * @returns parsed response from AttachmentsForUrlQuery
     */
    fetch(url: string, variables?: Omit<L.AttachmentsForUrlQueryVariables, "url">): LinearFetch<AttachmentConnection>;
}
/**
 * A fetchable AuditEntries Query
 *
 * @param request - function to call the graphql client
 */
export declare class AuditEntriesQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the AuditEntries query and return a AuditEntryConnection
     *
     * @param variables - variables to pass into the AuditEntriesQuery
     * @returns parsed response from AuditEntriesQuery
     */
    fetch(variables?: L.AuditEntriesQueryVariables): LinearFetch<AuditEntryConnection>;
}
/**
 * A fetchable AuditEntryTypes Query
 *
 * @param request - function to call the graphql client
 */
export declare class AuditEntryTypesQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the AuditEntryTypes query and return a AuditEntryType list
     *
     * @returns parsed response from AuditEntryTypesQuery
     */
    fetch(): LinearFetch<AuditEntryType[]>;
}
/**
 * A fetchable AuthorizedApplications Query
 *
 * @param request - function to call the graphql client
 */
export declare class AuthorizedApplicationsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the AuthorizedApplications query and return a AuthorizedApplication list
     *
     * @returns parsed response from AuthorizedApplicationsQuery
     */
    fetch(): LinearFetch<AuthorizedApplication[]>;
}
/**
 * A fetchable AvailableUsers Query
 *
 * @param request - function to call the graphql client
 */
export declare class AvailableUsersQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the AvailableUsers query and return a AuthResolverResponse
     *
     * @returns parsed response from AvailableUsersQuery
     */
    fetch(): LinearFetch<AuthResolverResponse>;
}
/**
 * A fetchable BillingDetails Query
 *
 * @param request - function to call the graphql client
 */
export declare class BillingDetailsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the BillingDetails query and return a BillingDetailsPayload
     *
     * @returns parsed response from BillingDetailsQuery
     */
    fetch(): LinearFetch<BillingDetailsPayload>;
}
/**
 * A fetchable CollaborativeDocumentJoin Query
 *
 * @param request - function to call the graphql client
 */
export declare class CollaborativeDocumentJoinQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CollaborativeDocumentJoin query and return a CollaborationDocumentUpdatePayload
     *
     * @param clientId - required clientId to pass to collaborativeDocumentJoin
     * @param issueId - required issueId to pass to collaborativeDocumentJoin
     * @param version - required version to pass to collaborativeDocumentJoin
     * @returns parsed response from CollaborativeDocumentJoinQuery
     */
    fetch(clientId: string, issueId: string, version: number): LinearFetch<CollaborationDocumentUpdatePayload>;
}
/**
 * A fetchable Comment Query
 *
 * @param request - function to call the graphql client
 */
export declare class CommentQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Comment query and return a Comment
     *
     * @param id - required id to pass to comment
     * @returns parsed response from CommentQuery
     */
    fetch(id: string): LinearFetch<Comment>;
}
/**
 * A fetchable Comments Query
 *
 * @param request - function to call the graphql client
 */
export declare class CommentsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Comments query and return a CommentConnection
     *
     * @param variables - variables to pass into the CommentsQuery
     * @returns parsed response from CommentsQuery
     */
    fetch(variables?: L.CommentsQueryVariables): LinearFetch<CommentConnection>;
}
/**
 * A fetchable CustomView Query
 *
 * @param request - function to call the graphql client
 */
export declare class CustomViewQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CustomView query and return a CustomView
     *
     * @param id - required id to pass to customView
     * @returns parsed response from CustomViewQuery
     */
    fetch(id: string): LinearFetch<CustomView>;
}
/**
 * A fetchable CustomViews Query
 *
 * @param request - function to call the graphql client
 */
export declare class CustomViewsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CustomViews query and return a CustomViewConnection
     *
     * @param variables - variables to pass into the CustomViewsQuery
     * @returns parsed response from CustomViewsQuery
     */
    fetch(variables?: L.CustomViewsQueryVariables): LinearFetch<CustomViewConnection>;
}
/**
 * A fetchable Cycle Query
 *
 * @param request - function to call the graphql client
 */
export declare class CycleQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Cycle query and return a Cycle
     *
     * @param id - required id to pass to cycle
     * @returns parsed response from CycleQuery
     */
    fetch(id: string): LinearFetch<Cycle>;
}
/**
 * A fetchable Cycles Query
 *
 * @param request - function to call the graphql client
 */
export declare class CyclesQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Cycles query and return a CycleConnection
     *
     * @param variables - variables to pass into the CyclesQuery
     * @returns parsed response from CyclesQuery
     */
    fetch(variables?: L.CyclesQueryVariables): LinearFetch<CycleConnection>;
}
/**
 * A fetchable Document Query
 *
 * @param request - function to call the graphql client
 */
export declare class DocumentQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Document query and return a Document
     *
     * @param id - required id to pass to document
     * @returns parsed response from DocumentQuery
     */
    fetch(id: string): LinearFetch<Document>;
}
/**
 * A fetchable Documents Query
 *
 * @param request - function to call the graphql client
 */
export declare class DocumentsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Documents query and return a DocumentConnection
     *
     * @param variables - variables to pass into the DocumentsQuery
     * @returns parsed response from DocumentsQuery
     */
    fetch(variables?: L.DocumentsQueryVariables): LinearFetch<DocumentConnection>;
}
/**
 * A fetchable Emoji Query
 *
 * @param request - function to call the graphql client
 */
export declare class EmojiQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Emoji query and return a Emoji
     *
     * @param id - required id to pass to emoji
     * @returns parsed response from EmojiQuery
     */
    fetch(id: string): LinearFetch<Emoji>;
}
/**
 * A fetchable Emojis Query
 *
 * @param request - function to call the graphql client
 */
export declare class EmojisQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Emojis query and return a EmojiConnection
     *
     * @param variables - variables to pass into the EmojisQuery
     * @returns parsed response from EmojisQuery
     */
    fetch(variables?: L.EmojisQueryVariables): LinearFetch<EmojiConnection>;
}
/**
 * A fetchable Favorite Query
 *
 * @param request - function to call the graphql client
 */
export declare class FavoriteQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Favorite query and return a Favorite
     *
     * @param id - required id to pass to favorite
     * @returns parsed response from FavoriteQuery
     */
    fetch(id: string): LinearFetch<Favorite>;
}
/**
 * A fetchable Favorites Query
 *
 * @param request - function to call the graphql client
 */
export declare class FavoritesQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Favorites query and return a FavoriteConnection
     *
     * @param variables - variables to pass into the FavoritesQuery
     * @returns parsed response from FavoritesQuery
     */
    fetch(variables?: L.FavoritesQueryVariables): LinearFetch<FavoriteConnection>;
}
/**
 * A fetchable FigmaEmbedInfo Query
 *
 * @param request - function to call the graphql client
 */
export declare class FigmaEmbedInfoQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the FigmaEmbedInfo query and return a FigmaEmbedPayload
     *
     * @param fileId - required fileId to pass to figmaEmbedInfo
     * @param variables - variables without 'fileId' to pass into the FigmaEmbedInfoQuery
     * @returns parsed response from FigmaEmbedInfoQuery
     */
    fetch(fileId: string, variables?: Omit<L.FigmaEmbedInfoQueryVariables, "fileId">): LinearFetch<FigmaEmbedPayload>;
}
/**
 * A fetchable Integration Query
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Integration query and return a Integration
     *
     * @param id - required id to pass to integration
     * @returns parsed response from IntegrationQuery
     */
    fetch(id: string): LinearFetch<Integration>;
}
/**
 * A fetchable Integrations Query
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Integrations query and return a IntegrationConnection
     *
     * @param variables - variables to pass into the IntegrationsQuery
     * @returns parsed response from IntegrationsQuery
     */
    fetch(variables?: L.IntegrationsQueryVariables): LinearFetch<IntegrationConnection>;
}
/**
 * A fetchable Issue Query
 *
 * @param request - function to call the graphql client
 */
export declare class IssueQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Issue query and return a Issue
     *
     * @param id - required id to pass to issue
     * @returns parsed response from IssueQuery
     */
    fetch(id: string): LinearFetch<Issue>;
}
/**
 * A fetchable IssueImportFinishGithubOAuth Query
 *
 * @param request - function to call the graphql client
 */
export declare class IssueImportFinishGithubOAuthQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueImportFinishGithubOAuth query and return a GithubOAuthTokenPayload
     *
     * @param code - required code to pass to issueImportFinishGithubOAuth
     * @returns parsed response from IssueImportFinishGithubOAuthQuery
     */
    fetch(code: string): LinearFetch<GithubOAuthTokenPayload>;
}
/**
 * A fetchable IssueLabel Query
 *
 * @param request - function to call the graphql client
 */
export declare class IssueLabelQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueLabel query and return a IssueLabel
     *
     * @param id - required id to pass to issueLabel
     * @returns parsed response from IssueLabelQuery
     */
    fetch(id: string): LinearFetch<IssueLabel>;
}
/**
 * A fetchable IssueLabels Query
 *
 * @param request - function to call the graphql client
 */
export declare class IssueLabelsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueLabels query and return a IssueLabelConnection
     *
     * @param variables - variables to pass into the IssueLabelsQuery
     * @returns parsed response from IssueLabelsQuery
     */
    fetch(variables?: L.IssueLabelsQueryVariables): LinearFetch<IssueLabelConnection>;
}
/**
 * A fetchable IssuePriorityValues Query
 *
 * @param request - function to call the graphql client
 */
export declare class IssuePriorityValuesQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssuePriorityValues query and return a IssuePriorityValue list
     *
     * @returns parsed response from IssuePriorityValuesQuery
     */
    fetch(): LinearFetch<IssuePriorityValue[]>;
}
/**
 * A fetchable IssueRelation Query
 *
 * @param request - function to call the graphql client
 */
export declare class IssueRelationQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueRelation query and return a IssueRelation
     *
     * @param id - required id to pass to issueRelation
     * @returns parsed response from IssueRelationQuery
     */
    fetch(id: string): LinearFetch<IssueRelation>;
}
/**
 * A fetchable IssueRelations Query
 *
 * @param request - function to call the graphql client
 */
export declare class IssueRelationsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueRelations query and return a IssueRelationConnection
     *
     * @param variables - variables to pass into the IssueRelationsQuery
     * @returns parsed response from IssueRelationsQuery
     */
    fetch(variables?: L.IssueRelationsQueryVariables): LinearFetch<IssueRelationConnection>;
}
/**
 * A fetchable IssueSearch Query
 *
 * @param request - function to call the graphql client
 */
export declare class IssueSearchQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueSearch query and return a IssueConnection
     *
     * @param query - required query to pass to issueSearch
     * @param variables - variables without 'query' to pass into the IssueSearchQuery
     * @returns parsed response from IssueSearchQuery
     */
    fetch(query: string, variables?: Omit<L.IssueSearchQueryVariables, "query">): LinearFetch<IssueConnection>;
}
/**
 * A fetchable Issues Query
 *
 * @param request - function to call the graphql client
 */
export declare class IssuesQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Issues query and return a IssueConnection
     *
     * @param variables - variables to pass into the IssuesQuery
     * @returns parsed response from IssuesQuery
     */
    fetch(variables?: L.IssuesQueryVariables): LinearFetch<IssueConnection>;
}
/**
 * A fetchable Milestone Query
 *
 * @param request - function to call the graphql client
 */
export declare class MilestoneQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Milestone query and return a Milestone
     *
     * @param id - required id to pass to milestone
     * @returns parsed response from MilestoneQuery
     */
    fetch(id: string): LinearFetch<Milestone>;
}
/**
 * A fetchable Milestones Query
 *
 * @param request - function to call the graphql client
 */
export declare class MilestonesQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Milestones query and return a MilestoneConnection
     *
     * @param variables - variables to pass into the MilestonesQuery
     * @returns parsed response from MilestonesQuery
     */
    fetch(variables?: L.MilestonesQueryVariables): LinearFetch<MilestoneConnection>;
}
/**
 * A fetchable Notification Query
 *
 * @param request - function to call the graphql client
 */
export declare class NotificationQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Notification query and return a Notification
     *
     * @param id - required id to pass to notification
     * @returns parsed response from NotificationQuery
     */
    fetch(id: string): LinearFetch<Notification>;
}
/**
 * A fetchable NotificationSubscription Query
 *
 * @param request - function to call the graphql client
 */
export declare class NotificationSubscriptionQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the NotificationSubscription query and return a NotificationSubscription
     *
     * @param id - required id to pass to notificationSubscription
     * @returns parsed response from NotificationSubscriptionQuery
     */
    fetch(id: string): LinearFetch<NotificationSubscription>;
}
/**
 * A fetchable NotificationSubscriptions Query
 *
 * @param request - function to call the graphql client
 */
export declare class NotificationSubscriptionsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the NotificationSubscriptions query and return a NotificationSubscriptionConnection
     *
     * @param variables - variables to pass into the NotificationSubscriptionsQuery
     * @returns parsed response from NotificationSubscriptionsQuery
     */
    fetch(variables?: L.NotificationSubscriptionsQueryVariables): LinearFetch<NotificationSubscriptionConnection>;
}
/**
 * A fetchable Notifications Query
 *
 * @param request - function to call the graphql client
 */
export declare class NotificationsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Notifications query and return a NotificationConnection
     *
     * @param variables - variables to pass into the NotificationsQuery
     * @returns parsed response from NotificationsQuery
     */
    fetch(variables?: L.NotificationsQueryVariables): LinearFetch<NotificationConnection>;
}
/**
 * A fetchable Organization Query
 *
 * @param request - function to call the graphql client
 */
export declare class OrganizationQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Organization query and return a Organization
     *
     * @returns parsed response from OrganizationQuery
     */
    fetch(): LinearFetch<Organization>;
}
/**
 * A fetchable OrganizationExists Query
 *
 * @param request - function to call the graphql client
 */
export declare class OrganizationExistsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the OrganizationExists query and return a OrganizationExistsPayload
     *
     * @param urlKey - required urlKey to pass to organizationExists
     * @returns parsed response from OrganizationExistsQuery
     */
    fetch(urlKey: string): LinearFetch<OrganizationExistsPayload>;
}
/**
 * A fetchable OrganizationInvite Query
 *
 * @param request - function to call the graphql client
 */
export declare class OrganizationInviteQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the OrganizationInvite query and return a OrganizationInvite
     *
     * @param id - required id to pass to organizationInvite
     * @returns parsed response from OrganizationInviteQuery
     */
    fetch(id: string): LinearFetch<OrganizationInvite>;
}
/**
 * A fetchable OrganizationInviteDetails Query
 *
 * @param request - function to call the graphql client
 */
export declare class OrganizationInviteDetailsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the OrganizationInviteDetails query and return a OrganizationInviteDetailsPayload
     *
     * @param id - required id to pass to organizationInviteDetails
     * @returns parsed response from OrganizationInviteDetailsQuery
     */
    fetch(id: string): LinearFetch<OrganizationInviteDetailsPayload>;
}
/**
 * A fetchable OrganizationInvites Query
 *
 * @param request - function to call the graphql client
 */
export declare class OrganizationInvitesQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the OrganizationInvites query and return a OrganizationInviteConnection
     *
     * @param variables - variables to pass into the OrganizationInvitesQuery
     * @returns parsed response from OrganizationInvitesQuery
     */
    fetch(variables?: L.OrganizationInvitesQueryVariables): LinearFetch<OrganizationInviteConnection>;
}
/**
 * A fetchable Project Query
 *
 * @param request - function to call the graphql client
 */
export declare class ProjectQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Project query and return a Project
     *
     * @param id - required id to pass to project
     * @returns parsed response from ProjectQuery
     */
    fetch(id: string): LinearFetch<Project>;
}
/**
 * A fetchable ProjectLink Query
 *
 * @param request - function to call the graphql client
 */
export declare class ProjectLinkQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ProjectLink query and return a ProjectLink
     *
     * @param id - required id to pass to projectLink
     * @returns parsed response from ProjectLinkQuery
     */
    fetch(id: string): LinearFetch<ProjectLink>;
}
/**
 * A fetchable ProjectLinks Query
 *
 * @param request - function to call the graphql client
 */
export declare class ProjectLinksQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ProjectLinks query and return a ProjectLinkConnection
     *
     * @param variables - variables to pass into the ProjectLinksQuery
     * @returns parsed response from ProjectLinksQuery
     */
    fetch(variables?: L.ProjectLinksQueryVariables): LinearFetch<ProjectLinkConnection>;
}
/**
 * A fetchable Projects Query
 *
 * @param request - function to call the graphql client
 */
export declare class ProjectsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Projects query and return a ProjectConnection
     *
     * @param variables - variables to pass into the ProjectsQuery
     * @returns parsed response from ProjectsQuery
     */
    fetch(variables?: L.ProjectsQueryVariables): LinearFetch<ProjectConnection>;
}
/**
 * A fetchable PushSubscriptionTest Query
 *
 * @param request - function to call the graphql client
 */
export declare class PushSubscriptionTestQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the PushSubscriptionTest query and return a PushSubscriptionTestPayload
     *
     * @returns parsed response from PushSubscriptionTestQuery
     */
    fetch(): LinearFetch<PushSubscriptionTestPayload>;
}
/**
 * A fetchable Reaction Query
 *
 * @param request - function to call the graphql client
 */
export declare class ReactionQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Reaction query and return a Reaction
     *
     * @param id - required id to pass to reaction
     * @returns parsed response from ReactionQuery
     */
    fetch(id: string): LinearFetch<Reaction>;
}
/**
 * A fetchable Reactions Query
 *
 * @param request - function to call the graphql client
 */
export declare class ReactionsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Reactions query and return a ReactionConnection
     *
     * @param variables - variables to pass into the ReactionsQuery
     * @returns parsed response from ReactionsQuery
     */
    fetch(variables?: L.ReactionsQueryVariables): LinearFetch<ReactionConnection>;
}
/**
 * A fetchable SsoUrlFromEmail Query
 *
 * @param request - function to call the graphql client
 */
export declare class SsoUrlFromEmailQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the SsoUrlFromEmail query and return a SsoUrlFromEmailResponse
     *
     * @param email - required email to pass to ssoUrlFromEmail
     * @param variables - variables without 'email' to pass into the SsoUrlFromEmailQuery
     * @returns parsed response from SsoUrlFromEmailQuery
     */
    fetch(email: string, variables?: Omit<L.SsoUrlFromEmailQueryVariables, "email">): LinearFetch<SsoUrlFromEmailResponse>;
}
/**
 * A fetchable Subscription Query
 *
 * @param request - function to call the graphql client
 */
export declare class SubscriptionQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Subscription query and return a Subscription
     *
     * @returns parsed response from SubscriptionQuery
     */
    fetch(): LinearFetch<Subscription | undefined>;
}
/**
 * A fetchable Team Query
 *
 * @param request - function to call the graphql client
 */
export declare class TeamQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Team query and return a Team
     *
     * @param id - required id to pass to team
     * @returns parsed response from TeamQuery
     */
    fetch(id: string): LinearFetch<Team>;
}
/**
 * A fetchable TeamMembership Query
 *
 * @param request - function to call the graphql client
 */
export declare class TeamMembershipQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the TeamMembership query and return a TeamMembership
     *
     * @param id - required id to pass to teamMembership
     * @returns parsed response from TeamMembershipQuery
     */
    fetch(id: string): LinearFetch<TeamMembership>;
}
/**
 * A fetchable TeamMemberships Query
 *
 * @param request - function to call the graphql client
 */
export declare class TeamMembershipsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the TeamMemberships query and return a TeamMembershipConnection
     *
     * @param variables - variables to pass into the TeamMembershipsQuery
     * @returns parsed response from TeamMembershipsQuery
     */
    fetch(variables?: L.TeamMembershipsQueryVariables): LinearFetch<TeamMembershipConnection>;
}
/**
 * A fetchable Teams Query
 *
 * @param request - function to call the graphql client
 */
export declare class TeamsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Teams query and return a TeamConnection
     *
     * @param variables - variables to pass into the TeamsQuery
     * @returns parsed response from TeamsQuery
     */
    fetch(variables?: L.TeamsQueryVariables): LinearFetch<TeamConnection>;
}
/**
 * A fetchable Template Query
 *
 * @param request - function to call the graphql client
 */
export declare class TemplateQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Template query and return a Template
     *
     * @param id - required id to pass to template
     * @returns parsed response from TemplateQuery
     */
    fetch(id: string): LinearFetch<Template>;
}
/**
 * A fetchable Templates Query
 *
 * @param request - function to call the graphql client
 */
export declare class TemplatesQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Templates query and return a Template list
     *
     * @returns parsed response from TemplatesQuery
     */
    fetch(): LinearFetch<Template[]>;
}
/**
 * A fetchable User Query
 *
 * @param request - function to call the graphql client
 */
export declare class UserQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the User query and return a User
     *
     * @param id - required id to pass to user
     * @returns parsed response from UserQuery
     */
    fetch(id: string): LinearFetch<User>;
}
/**
 * A fetchable UserSettings Query
 *
 * @param request - function to call the graphql client
 */
export declare class UserSettingsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UserSettings query and return a UserSettings
     *
     * @returns parsed response from UserSettingsQuery
     */
    fetch(): LinearFetch<UserSettings>;
}
/**
 * A fetchable Users Query
 *
 * @param request - function to call the graphql client
 */
export declare class UsersQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Users query and return a UserConnection
     *
     * @param variables - variables to pass into the UsersQuery
     * @returns parsed response from UsersQuery
     */
    fetch(variables?: L.UsersQueryVariables): LinearFetch<UserConnection>;
}
/**
 * A fetchable Viewer Query
 *
 * @param request - function to call the graphql client
 */
export declare class ViewerQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Viewer query and return a User
     *
     * @returns parsed response from ViewerQuery
     */
    fetch(): LinearFetch<User>;
}
/**
 * A fetchable Webhook Query
 *
 * @param request - function to call the graphql client
 */
export declare class WebhookQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Webhook query and return a Webhook
     *
     * @param id - required id to pass to webhook
     * @returns parsed response from WebhookQuery
     */
    fetch(id: string): LinearFetch<Webhook>;
}
/**
 * A fetchable Webhooks Query
 *
 * @param request - function to call the graphql client
 */
export declare class WebhooksQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Webhooks query and return a WebhookConnection
     *
     * @param variables - variables to pass into the WebhooksQuery
     * @returns parsed response from WebhooksQuery
     */
    fetch(variables?: L.WebhooksQueryVariables): LinearFetch<WebhookConnection>;
}
/**
 * A fetchable WorkflowState Query
 *
 * @param request - function to call the graphql client
 */
export declare class WorkflowStateQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the WorkflowState query and return a WorkflowState
     *
     * @param id - required id to pass to workflowState
     * @returns parsed response from WorkflowStateQuery
     */
    fetch(id: string): LinearFetch<WorkflowState>;
}
/**
 * A fetchable WorkflowStates Query
 *
 * @param request - function to call the graphql client
 */
export declare class WorkflowStatesQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the WorkflowStates query and return a WorkflowStateConnection
     *
     * @param variables - variables to pass into the WorkflowStatesQuery
     * @returns parsed response from WorkflowStatesQuery
     */
    fetch(variables?: L.WorkflowStatesQueryVariables): LinearFetch<WorkflowStateConnection>;
}
/**
 * A fetchable AttachmentArchive Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class AttachmentArchiveMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the AttachmentArchive mutation and return a ArchivePayload
     *
     * @param id - required id to pass to attachmentArchive
     * @returns parsed response from AttachmentArchiveMutation
     */
    fetch(id: string): LinearFetch<ArchivePayload>;
}
/**
 * A fetchable AttachmentCreate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class AttachmentCreateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the AttachmentCreate mutation and return a AttachmentPayload
     *
     * @param input - required input to pass to attachmentCreate
     * @returns parsed response from AttachmentCreateMutation
     */
    fetch(input: L.AttachmentCreateInput): LinearFetch<AttachmentPayload>;
}
/**
 * A fetchable AttachmentDelete Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class AttachmentDeleteMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the AttachmentDelete mutation and return a ArchivePayload
     *
     * @param id - required id to pass to attachmentDelete
     * @returns parsed response from AttachmentDeleteMutation
     */
    fetch(id: string): LinearFetch<ArchivePayload>;
}
/**
 * A fetchable AttachmentLinkFront Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class AttachmentLinkFrontMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the AttachmentLinkFront mutation and return a FrontAttachmentPayload
     *
     * @param conversationId - required conversationId to pass to attachmentLinkFront
     * @param issueId - required issueId to pass to attachmentLinkFront
     * @returns parsed response from AttachmentLinkFrontMutation
     */
    fetch(conversationId: string, issueId: string): LinearFetch<FrontAttachmentPayload>;
}
/**
 * A fetchable AttachmentLinkIntercom Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class AttachmentLinkIntercomMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the AttachmentLinkIntercom mutation and return a AttachmentPayload
     *
     * @param conversationId - required conversationId to pass to attachmentLinkIntercom
     * @param issueId - required issueId to pass to attachmentLinkIntercom
     * @returns parsed response from AttachmentLinkIntercomMutation
     */
    fetch(conversationId: string, issueId: string): LinearFetch<AttachmentPayload>;
}
/**
 * A fetchable AttachmentLinkJiraIssue Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class AttachmentLinkJiraIssueMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the AttachmentLinkJiraIssue mutation and return a AttachmentPayload
     *
     * @param issueId - required issueId to pass to attachmentLinkJiraIssue
     * @param jiraIssueId - required jiraIssueId to pass to attachmentLinkJiraIssue
     * @returns parsed response from AttachmentLinkJiraIssueMutation
     */
    fetch(issueId: string, jiraIssueId: string): LinearFetch<AttachmentPayload>;
}
/**
 * A fetchable AttachmentLinkUrl Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class AttachmentLinkUrlMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the AttachmentLinkUrl mutation and return a AttachmentPayload
     *
     * @param issueId - required issueId to pass to attachmentLinkURL
     * @param url - required url to pass to attachmentLinkURL
     * @param variables - variables without 'issueId', 'url' to pass into the AttachmentLinkUrlMutation
     * @returns parsed response from AttachmentLinkUrlMutation
     */
    fetch(issueId: string, url: string, variables?: Omit<L.AttachmentLinkUrlMutationVariables, "issueId" | "url">): LinearFetch<AttachmentPayload>;
}
/**
 * A fetchable AttachmentLinkZendesk Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class AttachmentLinkZendeskMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the AttachmentLinkZendesk mutation and return a AttachmentPayload
     *
     * @param issueId - required issueId to pass to attachmentLinkZendesk
     * @param ticketId - required ticketId to pass to attachmentLinkZendesk
     * @returns parsed response from AttachmentLinkZendeskMutation
     */
    fetch(issueId: string, ticketId: string): LinearFetch<AttachmentPayload>;
}
/**
 * A fetchable AttachmentUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class AttachmentUpdateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the AttachmentUpdate mutation and return a AttachmentPayload
     *
     * @param id - required id to pass to attachmentUpdate
     * @param input - required input to pass to attachmentUpdate
     * @returns parsed response from AttachmentUpdateMutation
     */
    fetch(id: string, input: L.AttachmentUpdateInput): LinearFetch<AttachmentPayload>;
}
/**
 * A fetchable BillingEmailUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class BillingEmailUpdateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the BillingEmailUpdate mutation and return a BillingEmailPayload
     *
     * @param input - required input to pass to billingEmailUpdate
     * @returns parsed response from BillingEmailUpdateMutation
     */
    fetch(input: L.BillingEmailUpdateInput): LinearFetch<BillingEmailPayload>;
}
/**
 * A fetchable CollaborativeDocumentUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CollaborativeDocumentUpdateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CollaborativeDocumentUpdate mutation and return a CollaborationDocumentUpdatePayload
     *
     * @param input - required input to pass to collaborativeDocumentUpdate
     * @returns parsed response from CollaborativeDocumentUpdateMutation
     */
    fetch(input: L.CollaborationDocumentUpdateInput): LinearFetch<CollaborationDocumentUpdatePayload>;
}
/**
 * A fetchable CommentCreate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CommentCreateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CommentCreate mutation and return a CommentPayload
     *
     * @param input - required input to pass to commentCreate
     * @returns parsed response from CommentCreateMutation
     */
    fetch(input: L.CommentCreateInput): LinearFetch<CommentPayload>;
}
/**
 * A fetchable CommentDelete Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CommentDeleteMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CommentDelete mutation and return a ArchivePayload
     *
     * @param id - required id to pass to commentDelete
     * @returns parsed response from CommentDeleteMutation
     */
    fetch(id: string): LinearFetch<ArchivePayload>;
}
/**
 * A fetchable CommentUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CommentUpdateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CommentUpdate mutation and return a CommentPayload
     *
     * @param id - required id to pass to commentUpdate
     * @param input - required input to pass to commentUpdate
     * @returns parsed response from CommentUpdateMutation
     */
    fetch(id: string, input: L.CommentUpdateInput): LinearFetch<CommentPayload>;
}
/**
 * A fetchable ContactCreate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class ContactCreateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ContactCreate mutation and return a ContactPayload
     *
     * @param input - required input to pass to contactCreate
     * @returns parsed response from ContactCreateMutation
     */
    fetch(input: L.ContactCreateInput): LinearFetch<ContactPayload>;
}
/**
 * A fetchable CreateCsvExportReport Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateCsvExportReportMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateCsvExportReport mutation and return a CreateCsvExportReportPayload
     *
     * @param variables - variables to pass into the CreateCsvExportReportMutation
     * @returns parsed response from CreateCsvExportReportMutation
     */
    fetch(variables?: L.CreateCsvExportReportMutationVariables): LinearFetch<CreateCsvExportReportPayload>;
}
/**
 * A fetchable CreateOrganizationFromOnboarding Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateOrganizationFromOnboardingMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateOrganizationFromOnboarding mutation and return a CreateOrJoinOrganizationResponse
     *
     * @param input - required input to pass to createOrganizationFromOnboarding
     * @param variables - variables without 'input' to pass into the CreateOrganizationFromOnboardingMutation
     * @returns parsed response from CreateOrganizationFromOnboardingMutation
     */
    fetch(input: L.CreateOrganizationInput, variables?: Omit<L.CreateOrganizationFromOnboardingMutationVariables, "input">): LinearFetch<CreateOrJoinOrganizationResponse>;
}
/**
 * A fetchable CustomViewCreate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CustomViewCreateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CustomViewCreate mutation and return a CustomViewPayload
     *
     * @param input - required input to pass to customViewCreate
     * @returns parsed response from CustomViewCreateMutation
     */
    fetch(input: L.CustomViewCreateInput): LinearFetch<CustomViewPayload>;
}
/**
 * A fetchable CustomViewDelete Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CustomViewDeleteMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CustomViewDelete mutation and return a ArchivePayload
     *
     * @param id - required id to pass to customViewDelete
     * @returns parsed response from CustomViewDeleteMutation
     */
    fetch(id: string): LinearFetch<ArchivePayload>;
}
/**
 * A fetchable CustomViewUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CustomViewUpdateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CustomViewUpdate mutation and return a CustomViewPayload
     *
     * @param id - required id to pass to customViewUpdate
     * @param input - required input to pass to customViewUpdate
     * @returns parsed response from CustomViewUpdateMutation
     */
    fetch(id: string, input: L.CustomViewUpdateInput): LinearFetch<CustomViewPayload>;
}
/**
 * A fetchable CycleArchive Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CycleArchiveMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CycleArchive mutation and return a ArchivePayload
     *
     * @param id - required id to pass to cycleArchive
     * @returns parsed response from CycleArchiveMutation
     */
    fetch(id: string): LinearFetch<ArchivePayload>;
}
/**
 * A fetchable CycleCreate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CycleCreateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CycleCreate mutation and return a CyclePayload
     *
     * @param input - required input to pass to cycleCreate
     * @returns parsed response from CycleCreateMutation
     */
    fetch(input: L.CycleCreateInput): LinearFetch<CyclePayload>;
}
/**
 * A fetchable CycleUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CycleUpdateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CycleUpdate mutation and return a CyclePayload
     *
     * @param id - required id to pass to cycleUpdate
     * @param input - required input to pass to cycleUpdate
     * @returns parsed response from CycleUpdateMutation
     */
    fetch(id: string, input: L.CycleUpdateInput): LinearFetch<CyclePayload>;
}
/**
 * A fetchable DebugFailWithInternalError Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DebugFailWithInternalErrorMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DebugFailWithInternalError mutation and return a DebugPayload
     *
     * @returns parsed response from DebugFailWithInternalErrorMutation
     */
    fetch(): LinearFetch<DebugPayload>;
}
/**
 * A fetchable DocumentCreate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DocumentCreateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DocumentCreate mutation and return a DocumentPayload
     *
     * @param input - required input to pass to documentCreate
     * @returns parsed response from DocumentCreateMutation
     */
    fetch(input: L.DocumentCreateInput): LinearFetch<DocumentPayload>;
}
/**
 * A fetchable DocumentDelete Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DocumentDeleteMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DocumentDelete mutation and return a ArchivePayload
     *
     * @param id - required id to pass to documentDelete
     * @returns parsed response from DocumentDeleteMutation
     */
    fetch(id: string): LinearFetch<ArchivePayload>;
}
/**
 * A fetchable DocumentUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DocumentUpdateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DocumentUpdate mutation and return a DocumentPayload
     *
     * @param id - required id to pass to documentUpdate
     * @param input - required input to pass to documentUpdate
     * @returns parsed response from DocumentUpdateMutation
     */
    fetch(id: string, input: L.DocumentUpdateInput): LinearFetch<DocumentPayload>;
}
/**
 * A fetchable EmailSubscribe Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class EmailSubscribeMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the EmailSubscribe mutation and return a EmailSubscribePayload
     *
     * @param input - required input to pass to emailSubscribe
     * @returns parsed response from EmailSubscribeMutation
     */
    fetch(input: L.EmailSubscribeInput): LinearFetch<EmailSubscribePayload>;
}
/**
 * A fetchable EmailTokenUserAccountAuth Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class EmailTokenUserAccountAuthMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the EmailTokenUserAccountAuth mutation and return a AuthResolverResponse
     *
     * @param input - required input to pass to emailTokenUserAccountAuth
     * @returns parsed response from EmailTokenUserAccountAuthMutation
     */
    fetch(input: L.TokenUserAccountAuthInput): LinearFetch<AuthResolverResponse>;
}
/**
 * A fetchable EmailUnsubscribe Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class EmailUnsubscribeMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the EmailUnsubscribe mutation and return a EmailUnsubscribePayload
     *
     * @param input - required input to pass to emailUnsubscribe
     * @returns parsed response from EmailUnsubscribeMutation
     */
    fetch(input: L.EmailUnsubscribeInput): LinearFetch<EmailUnsubscribePayload>;
}
/**
 * A fetchable EmailUserAccountAuthChallenge Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class EmailUserAccountAuthChallengeMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the EmailUserAccountAuthChallenge mutation and return a EmailUserAccountAuthChallengeResponse
     *
     * @param input - required input to pass to emailUserAccountAuthChallenge
     * @returns parsed response from EmailUserAccountAuthChallengeMutation
     */
    fetch(input: L.EmailUserAccountAuthChallengeInput): LinearFetch<EmailUserAccountAuthChallengeResponse>;
}
/**
 * A fetchable EmojiCreate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class EmojiCreateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the EmojiCreate mutation and return a EmojiPayload
     *
     * @param input - required input to pass to emojiCreate
     * @returns parsed response from EmojiCreateMutation
     */
    fetch(input: L.EmojiCreateInput): LinearFetch<EmojiPayload>;
}
/**
 * A fetchable EmojiDelete Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class EmojiDeleteMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the EmojiDelete mutation and return a ArchivePayload
     *
     * @param id - required id to pass to emojiDelete
     * @returns parsed response from EmojiDeleteMutation
     */
    fetch(id: string): LinearFetch<ArchivePayload>;
}
/**
 * A fetchable EventCreate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class EventCreateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the EventCreate mutation and return a EventPayload
     *
     * @param input - required input to pass to eventCreate
     * @returns parsed response from EventCreateMutation
     */
    fetch(input: L.EventCreateInput): LinearFetch<EventPayload>;
}
/**
 * A fetchable FavoriteCreate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class FavoriteCreateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the FavoriteCreate mutation and return a FavoritePayload
     *
     * @param input - required input to pass to favoriteCreate
     * @returns parsed response from FavoriteCreateMutation
     */
    fetch(input: L.FavoriteCreateInput): LinearFetch<FavoritePayload>;
}
/**
 * A fetchable FavoriteDelete Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class FavoriteDeleteMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the FavoriteDelete mutation and return a ArchivePayload
     *
     * @param id - required id to pass to favoriteDelete
     * @returns parsed response from FavoriteDeleteMutation
     */
    fetch(id: string): LinearFetch<ArchivePayload>;
}
/**
 * A fetchable FavoriteUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class FavoriteUpdateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the FavoriteUpdate mutation and return a FavoritePayload
     *
     * @param id - required id to pass to favoriteUpdate
     * @param input - required input to pass to favoriteUpdate
     * @returns parsed response from FavoriteUpdateMutation
     */
    fetch(id: string, input: L.FavoriteUpdateInput): LinearFetch<FavoritePayload>;
}
/**
 * A fetchable FeedbackCreate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class FeedbackCreateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the FeedbackCreate mutation and return a FeedbackPayload
     *
     * @param input - required input to pass to feedbackCreate
     * @returns parsed response from FeedbackCreateMutation
     */
    fetch(input: L.FeedbackCreateInput): LinearFetch<FeedbackPayload>;
}
/**
 * A fetchable FileUpload Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class FileUploadMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the FileUpload mutation and return a UploadPayload
     *
     * @param contentType - required contentType to pass to fileUpload
     * @param filename - required filename to pass to fileUpload
     * @param size - required size to pass to fileUpload
     * @param variables - variables without 'contentType', 'filename', 'size' to pass into the FileUploadMutation
     * @returns parsed response from FileUploadMutation
     */
    fetch(contentType: string, filename: string, size: number, variables?: Omit<L.FileUploadMutationVariables, "contentType" | "filename" | "size">): LinearFetch<UploadPayload>;
}
/**
 * A fetchable GoogleUserAccountAuth Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class GoogleUserAccountAuthMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the GoogleUserAccountAuth mutation and return a AuthResolverResponse
     *
     * @param input - required input to pass to googleUserAccountAuth
     * @returns parsed response from GoogleUserAccountAuthMutation
     */
    fetch(input: L.GoogleUserAccountAuthInput): LinearFetch<AuthResolverResponse>;
}
/**
 * A fetchable ImageUploadFromUrl Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class ImageUploadFromUrlMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ImageUploadFromUrl mutation and return a ImageUploadFromUrlPayload
     *
     * @param url - required url to pass to imageUploadFromUrl
     * @returns parsed response from ImageUploadFromUrlMutation
     */
    fetch(url: string): LinearFetch<ImageUploadFromUrlPayload>;
}
/**
 * A fetchable IntegrationDelete Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationDeleteMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationDelete mutation and return a ArchivePayload
     *
     * @param id - required id to pass to integrationDelete
     * @returns parsed response from IntegrationDeleteMutation
     */
    fetch(id: string): LinearFetch<ArchivePayload>;
}
/**
 * A fetchable IntegrationFigma Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationFigmaMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationFigma mutation and return a IntegrationPayload
     *
     * @param code - required code to pass to integrationFigma
     * @param redirectUri - required redirectUri to pass to integrationFigma
     * @returns parsed response from IntegrationFigmaMutation
     */
    fetch(code: string, redirectUri: string): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable IntegrationFront Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationFrontMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationFront mutation and return a IntegrationPayload
     *
     * @param code - required code to pass to integrationFront
     * @param redirectUri - required redirectUri to pass to integrationFront
     * @returns parsed response from IntegrationFrontMutation
     */
    fetch(code: string, redirectUri: string): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable IntegrationGithubCommitCreate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationGithubCommitCreateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationGithubCommitCreate mutation and return a GitHubCommitIntegrationPayload
     *
     * @returns parsed response from IntegrationGithubCommitCreateMutation
     */
    fetch(): LinearFetch<GitHubCommitIntegrationPayload>;
}
/**
 * A fetchable IntegrationGithubConnect Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationGithubConnectMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationGithubConnect mutation and return a IntegrationPayload
     *
     * @param installationId - required installationId to pass to integrationGithubConnect
     * @returns parsed response from IntegrationGithubConnectMutation
     */
    fetch(installationId: string): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable IntegrationGitlabConnect Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationGitlabConnectMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationGitlabConnect mutation and return a IntegrationPayload
     *
     * @param accessToken - required accessToken to pass to integrationGitlabConnect
     * @param gitlabUrl - required gitlabUrl to pass to integrationGitlabConnect
     * @returns parsed response from IntegrationGitlabConnectMutation
     */
    fetch(accessToken: string, gitlabUrl: string): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable IntegrationGoogleSheets Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationGoogleSheetsMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationGoogleSheets mutation and return a IntegrationPayload
     *
     * @param code - required code to pass to integrationGoogleSheets
     * @returns parsed response from IntegrationGoogleSheetsMutation
     */
    fetch(code: string): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable IntegrationIntercom Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationIntercomMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationIntercom mutation and return a IntegrationPayload
     *
     * @param code - required code to pass to integrationIntercom
     * @param redirectUri - required redirectUri to pass to integrationIntercom
     * @returns parsed response from IntegrationIntercomMutation
     */
    fetch(code: string, redirectUri: string): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable IntegrationIntercomDelete Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationIntercomDeleteMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationIntercomDelete mutation and return a IntegrationPayload
     *
     * @returns parsed response from IntegrationIntercomDeleteMutation
     */
    fetch(): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable IntegrationIntercomSettingsUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationIntercomSettingsUpdateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationIntercomSettingsUpdate mutation and return a IntegrationPayload
     *
     * @param input - required input to pass to integrationIntercomSettingsUpdate
     * @returns parsed response from IntegrationIntercomSettingsUpdateMutation
     */
    fetch(input: L.IntercomSettingsInput): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable IntegrationLoom Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationLoomMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationLoom mutation and return a IntegrationPayload
     *
     * @returns parsed response from IntegrationLoomMutation
     */
    fetch(): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable IntegrationResourceArchive Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationResourceArchiveMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationResourceArchive mutation and return a ArchivePayload
     *
     * @param id - required id to pass to integrationResourceArchive
     * @returns parsed response from IntegrationResourceArchiveMutation
     */
    fetch(id: string): LinearFetch<ArchivePayload>;
}
/**
 * A fetchable IntegrationSentryConnect Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationSentryConnectMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationSentryConnect mutation and return a IntegrationPayload
     *
     * @param code - required code to pass to integrationSentryConnect
     * @param installationId - required installationId to pass to integrationSentryConnect
     * @param organizationSlug - required organizationSlug to pass to integrationSentryConnect
     * @returns parsed response from IntegrationSentryConnectMutation
     */
    fetch(code: string, installationId: string, organizationSlug: string): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable IntegrationSettingsUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationSettingsUpdateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationSettingsUpdate mutation and return a IntegrationPayload
     *
     * @param id - required id to pass to integrationSettingsUpdate
     * @param input - required input to pass to integrationSettingsUpdate
     * @returns parsed response from IntegrationSettingsUpdateMutation
     */
    fetch(id: string, input: L.IntegrationSettingsInput): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable IntegrationSlack Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationSlackMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationSlack mutation and return a IntegrationPayload
     *
     * @param code - required code to pass to integrationSlack
     * @param redirectUri - required redirectUri to pass to integrationSlack
     * @param variables - variables without 'code', 'redirectUri' to pass into the IntegrationSlackMutation
     * @returns parsed response from IntegrationSlackMutation
     */
    fetch(code: string, redirectUri: string, variables?: Omit<L.IntegrationSlackMutationVariables, "code" | "redirectUri">): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable IntegrationSlackImportEmojis Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationSlackImportEmojisMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationSlackImportEmojis mutation and return a IntegrationPayload
     *
     * @param code - required code to pass to integrationSlackImportEmojis
     * @param redirectUri - required redirectUri to pass to integrationSlackImportEmojis
     * @returns parsed response from IntegrationSlackImportEmojisMutation
     */
    fetch(code: string, redirectUri: string): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable IntegrationSlackPersonal Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationSlackPersonalMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationSlackPersonal mutation and return a IntegrationPayload
     *
     * @param code - required code to pass to integrationSlackPersonal
     * @param redirectUri - required redirectUri to pass to integrationSlackPersonal
     * @returns parsed response from IntegrationSlackPersonalMutation
     */
    fetch(code: string, redirectUri: string): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable IntegrationSlackPost Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationSlackPostMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationSlackPost mutation and return a IntegrationPayload
     *
     * @param code - required code to pass to integrationSlackPost
     * @param redirectUri - required redirectUri to pass to integrationSlackPost
     * @param teamId - required teamId to pass to integrationSlackPost
     * @param variables - variables without 'code', 'redirectUri', 'teamId' to pass into the IntegrationSlackPostMutation
     * @returns parsed response from IntegrationSlackPostMutation
     */
    fetch(code: string, redirectUri: string, teamId: string, variables?: Omit<L.IntegrationSlackPostMutationVariables, "code" | "redirectUri" | "teamId">): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable IntegrationSlackProjectPost Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationSlackProjectPostMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationSlackProjectPost mutation and return a IntegrationPayload
     *
     * @param code - required code to pass to integrationSlackProjectPost
     * @param projectId - required projectId to pass to integrationSlackProjectPost
     * @param redirectUri - required redirectUri to pass to integrationSlackProjectPost
     * @returns parsed response from IntegrationSlackProjectPostMutation
     */
    fetch(code: string, projectId: string, redirectUri: string): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable IntegrationZendesk Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationZendeskMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationZendesk mutation and return a IntegrationPayload
     *
     * @param code - required code to pass to integrationZendesk
     * @param redirectUri - required redirectUri to pass to integrationZendesk
     * @param scope - required scope to pass to integrationZendesk
     * @param subdomain - required subdomain to pass to integrationZendesk
     * @returns parsed response from IntegrationZendeskMutation
     */
    fetch(code: string, redirectUri: string, scope: string, subdomain: string): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable IssueArchive Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IssueArchiveMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueArchive mutation and return a ArchivePayload
     *
     * @param id - required id to pass to issueArchive
     * @param variables - variables without 'id' to pass into the IssueArchiveMutation
     * @returns parsed response from IssueArchiveMutation
     */
    fetch(id: string, variables?: Omit<L.IssueArchiveMutationVariables, "id">): LinearFetch<ArchivePayload>;
}
/**
 * A fetchable IssueBatchUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IssueBatchUpdateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueBatchUpdate mutation and return a IssueBatchPayload
     *
     * @param ids - required ids to pass to issueBatchUpdate
     * @param input - required input to pass to issueBatchUpdate
     * @returns parsed response from IssueBatchUpdateMutation
     */
    fetch(ids: L.Scalars["UUID"][], input: L.IssueUpdateInput): LinearFetch<IssueBatchPayload>;
}
/**
 * A fetchable IssueCreate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IssueCreateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueCreate mutation and return a IssuePayload
     *
     * @param input - required input to pass to issueCreate
     * @returns parsed response from IssueCreateMutation
     */
    fetch(input: L.IssueCreateInput): LinearFetch<IssuePayload>;
}
/**
 * A fetchable IssueDelete Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IssueDeleteMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueDelete mutation and return a ArchivePayload
     *
     * @param id - required id to pass to issueDelete
     * @returns parsed response from IssueDeleteMutation
     */
    fetch(id: string): LinearFetch<ArchivePayload>;
}
/**
 * A fetchable IssueImportCreateAsana Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IssueImportCreateAsanaMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueImportCreateAsana mutation and return a IssueImportPayload
     *
     * @param asanaTeamName - required asanaTeamName to pass to issueImportCreateAsana
     * @param asanaToken - required asanaToken to pass to issueImportCreateAsana
     * @param teamId - required teamId to pass to issueImportCreateAsana
     * @param variables - variables without 'asanaTeamName', 'asanaToken', 'teamId' to pass into the IssueImportCreateAsanaMutation
     * @returns parsed response from IssueImportCreateAsanaMutation
     */
    fetch(asanaTeamName: string, asanaToken: string, teamId: string, variables?: Omit<L.IssueImportCreateAsanaMutationVariables, "asanaTeamName" | "asanaToken" | "teamId">): LinearFetch<IssueImportPayload>;
}
/**
 * A fetchable IssueImportCreateClubhouse Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IssueImportCreateClubhouseMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueImportCreateClubhouse mutation and return a IssueImportPayload
     *
     * @param clubhouseTeamName - required clubhouseTeamName to pass to issueImportCreateClubhouse
     * @param clubhouseToken - required clubhouseToken to pass to issueImportCreateClubhouse
     * @param teamId - required teamId to pass to issueImportCreateClubhouse
     * @param variables - variables without 'clubhouseTeamName', 'clubhouseToken', 'teamId' to pass into the IssueImportCreateClubhouseMutation
     * @returns parsed response from IssueImportCreateClubhouseMutation
     */
    fetch(clubhouseTeamName: string, clubhouseToken: string, teamId: string, variables?: Omit<L.IssueImportCreateClubhouseMutationVariables, "clubhouseTeamName" | "clubhouseToken" | "teamId">): LinearFetch<IssueImportPayload>;
}
/**
 * A fetchable IssueImportCreateGithub Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IssueImportCreateGithubMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueImportCreateGithub mutation and return a IssueImportPayload
     *
     * @param githubRepoName - required githubRepoName to pass to issueImportCreateGithub
     * @param githubRepoOwner - required githubRepoOwner to pass to issueImportCreateGithub
     * @param githubToken - required githubToken to pass to issueImportCreateGithub
     * @param teamId - required teamId to pass to issueImportCreateGithub
     * @param variables - variables without 'githubRepoName', 'githubRepoOwner', 'githubToken', 'teamId' to pass into the IssueImportCreateGithubMutation
     * @returns parsed response from IssueImportCreateGithubMutation
     */
    fetch(githubRepoName: string, githubRepoOwner: string, githubToken: string, teamId: string, variables?: Omit<L.IssueImportCreateGithubMutationVariables, "githubRepoName" | "githubRepoOwner" | "githubToken" | "teamId">): LinearFetch<IssueImportPayload>;
}
/**
 * A fetchable IssueImportCreateJira Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IssueImportCreateJiraMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueImportCreateJira mutation and return a IssueImportPayload
     *
     * @param jiraEmail - required jiraEmail to pass to issueImportCreateJira
     * @param jiraHostname - required jiraHostname to pass to issueImportCreateJira
     * @param jiraProject - required jiraProject to pass to issueImportCreateJira
     * @param jiraToken - required jiraToken to pass to issueImportCreateJira
     * @param teamId - required teamId to pass to issueImportCreateJira
     * @param variables - variables without 'jiraEmail', 'jiraHostname', 'jiraProject', 'jiraToken', 'teamId' to pass into the IssueImportCreateJiraMutation
     * @returns parsed response from IssueImportCreateJiraMutation
     */
    fetch(jiraEmail: string, jiraHostname: string, jiraProject: string, jiraToken: string, teamId: string, variables?: Omit<L.IssueImportCreateJiraMutationVariables, "jiraEmail" | "jiraHostname" | "jiraProject" | "jiraToken" | "teamId">): LinearFetch<IssueImportPayload>;
}
/**
 * A fetchable IssueImportDelete Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IssueImportDeleteMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueImportDelete mutation and return a IssueImportDeletePayload
     *
     * @param issueImportId - required issueImportId to pass to issueImportDelete
     * @returns parsed response from IssueImportDeleteMutation
     */
    fetch(issueImportId: string): LinearFetch<IssueImportDeletePayload>;
}
/**
 * A fetchable IssueImportProcess Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IssueImportProcessMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueImportProcess mutation and return a IssueImportPayload
     *
     * @param issueImportId - required issueImportId to pass to issueImportProcess
     * @param mapping - required mapping to pass to issueImportProcess
     * @returns parsed response from IssueImportProcessMutation
     */
    fetch(issueImportId: string, mapping: Record<string, unknown>): LinearFetch<IssueImportPayload>;
}
/**
 * A fetchable IssueImportUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IssueImportUpdateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueImportUpdate mutation and return a IssueImportPayload
     *
     * @param id - required id to pass to issueImportUpdate
     * @param input - required input to pass to issueImportUpdate
     * @returns parsed response from IssueImportUpdateMutation
     */
    fetch(id: string, input: L.IssueImportUpdateInput): LinearFetch<IssueImportPayload>;
}
/**
 * A fetchable IssueLabelArchive Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IssueLabelArchiveMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueLabelArchive mutation and return a ArchivePayload
     *
     * @param id - required id to pass to issueLabelArchive
     * @returns parsed response from IssueLabelArchiveMutation
     */
    fetch(id: string): LinearFetch<ArchivePayload>;
}
/**
 * A fetchable IssueLabelCreate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IssueLabelCreateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueLabelCreate mutation and return a IssueLabelPayload
     *
     * @param input - required input to pass to issueLabelCreate
     * @param variables - variables without 'input' to pass into the IssueLabelCreateMutation
     * @returns parsed response from IssueLabelCreateMutation
     */
    fetch(input: L.IssueLabelCreateInput, variables?: Omit<L.IssueLabelCreateMutationVariables, "input">): LinearFetch<IssueLabelPayload>;
}
/**
 * A fetchable IssueLabelUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IssueLabelUpdateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueLabelUpdate mutation and return a IssueLabelPayload
     *
     * @param id - required id to pass to issueLabelUpdate
     * @param input - required input to pass to issueLabelUpdate
     * @returns parsed response from IssueLabelUpdateMutation
     */
    fetch(id: string, input: L.IssueLabelUpdateInput): LinearFetch<IssueLabelPayload>;
}
/**
 * A fetchable IssueRelationCreate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IssueRelationCreateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueRelationCreate mutation and return a IssueRelationPayload
     *
     * @param input - required input to pass to issueRelationCreate
     * @returns parsed response from IssueRelationCreateMutation
     */
    fetch(input: L.IssueRelationCreateInput): LinearFetch<IssueRelationPayload>;
}
/**
 * A fetchable IssueRelationDelete Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IssueRelationDeleteMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueRelationDelete mutation and return a ArchivePayload
     *
     * @param id - required id to pass to issueRelationDelete
     * @returns parsed response from IssueRelationDeleteMutation
     */
    fetch(id: string): LinearFetch<ArchivePayload>;
}
/**
 * A fetchable IssueRelationUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IssueRelationUpdateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueRelationUpdate mutation and return a IssueRelationPayload
     *
     * @param id - required id to pass to issueRelationUpdate
     * @param input - required input to pass to issueRelationUpdate
     * @returns parsed response from IssueRelationUpdateMutation
     */
    fetch(id: string, input: L.IssueRelationUpdateInput): LinearFetch<IssueRelationPayload>;
}
/**
 * A fetchable IssueUnarchive Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IssueUnarchiveMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueUnarchive mutation and return a ArchivePayload
     *
     * @param id - required id to pass to issueUnarchive
     * @returns parsed response from IssueUnarchiveMutation
     */
    fetch(id: string): LinearFetch<ArchivePayload>;
}
/**
 * A fetchable IssueUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IssueUpdateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueUpdate mutation and return a IssuePayload
     *
     * @param id - required id to pass to issueUpdate
     * @param input - required input to pass to issueUpdate
     * @returns parsed response from IssueUpdateMutation
     */
    fetch(id: string, input: L.IssueUpdateInput): LinearFetch<IssuePayload>;
}
/**
 * A fetchable JiraIntegrationConnect Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class JiraIntegrationConnectMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the JiraIntegrationConnect mutation and return a IntegrationPayload
     *
     * @param input - required input to pass to jiraIntegrationConnect
     * @returns parsed response from JiraIntegrationConnectMutation
     */
    fetch(input: L.JiraConfigurationInput): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable JoinOrganizationFromOnboarding Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class JoinOrganizationFromOnboardingMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the JoinOrganizationFromOnboarding mutation and return a CreateOrJoinOrganizationResponse
     *
     * @param input - required input to pass to joinOrganizationFromOnboarding
     * @returns parsed response from JoinOrganizationFromOnboardingMutation
     */
    fetch(input: L.JoinOrganizationInput): LinearFetch<CreateOrJoinOrganizationResponse>;
}
/**
 * A fetchable LeaveOrganization Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class LeaveOrganizationMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the LeaveOrganization mutation and return a CreateOrJoinOrganizationResponse
     *
     * @param organizationId - required organizationId to pass to leaveOrganization
     * @returns parsed response from LeaveOrganizationMutation
     */
    fetch(organizationId: string): LinearFetch<CreateOrJoinOrganizationResponse>;
}
/**
 * A fetchable MilestoneCreate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class MilestoneCreateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the MilestoneCreate mutation and return a MilestonePayload
     *
     * @param input - required input to pass to milestoneCreate
     * @returns parsed response from MilestoneCreateMutation
     */
    fetch(input: L.MilestoneCreateInput): LinearFetch<MilestonePayload>;
}
/**
 * A fetchable MilestoneDelete Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class MilestoneDeleteMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the MilestoneDelete mutation and return a ArchivePayload
     *
     * @param id - required id to pass to milestoneDelete
     * @returns parsed response from MilestoneDeleteMutation
     */
    fetch(id: string): LinearFetch<ArchivePayload>;
}
/**
 * A fetchable MilestoneUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class MilestoneUpdateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the MilestoneUpdate mutation and return a MilestonePayload
     *
     * @param id - required id to pass to milestoneUpdate
     * @param input - required input to pass to milestoneUpdate
     * @returns parsed response from MilestoneUpdateMutation
     */
    fetch(id: string, input: L.MilestoneUpdateInput): LinearFetch<MilestonePayload>;
}
/**
 * A fetchable NotificationArchive Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class NotificationArchiveMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the NotificationArchive mutation and return a ArchivePayload
     *
     * @param id - required id to pass to notificationArchive
     * @returns parsed response from NotificationArchiveMutation
     */
    fetch(id: string): LinearFetch<ArchivePayload>;
}
/**
 * A fetchable NotificationCreate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class NotificationCreateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the NotificationCreate mutation and return a NotificationPayload
     *
     * @param id - required id to pass to notificationCreate
     * @param input - required input to pass to notificationCreate
     * @returns parsed response from NotificationCreateMutation
     */
    fetch(id: string, input: L.NotificationUpdateInput): LinearFetch<NotificationPayload>;
}
/**
 * A fetchable NotificationSubscriptionCreate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class NotificationSubscriptionCreateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the NotificationSubscriptionCreate mutation and return a NotificationSubscriptionPayload
     *
     * @param input - required input to pass to notificationSubscriptionCreate
     * @returns parsed response from NotificationSubscriptionCreateMutation
     */
    fetch(input: L.NotificationSubscriptionCreateInput): LinearFetch<NotificationSubscriptionPayload>;
}
/**
 * A fetchable NotificationSubscriptionDelete Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class NotificationSubscriptionDeleteMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the NotificationSubscriptionDelete mutation and return a ArchivePayload
     *
     * @param id - required id to pass to notificationSubscriptionDelete
     * @returns parsed response from NotificationSubscriptionDeleteMutation
     */
    fetch(id: string): LinearFetch<ArchivePayload>;
}
/**
 * A fetchable NotificationUnarchive Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class NotificationUnarchiveMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the NotificationUnarchive mutation and return a ArchivePayload
     *
     * @param id - required id to pass to notificationUnarchive
     * @returns parsed response from NotificationUnarchiveMutation
     */
    fetch(id: string): LinearFetch<ArchivePayload>;
}
/**
 * A fetchable NotificationUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class NotificationUpdateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the NotificationUpdate mutation and return a NotificationPayload
     *
     * @param id - required id to pass to notificationUpdate
     * @param input - required input to pass to notificationUpdate
     * @returns parsed response from NotificationUpdateMutation
     */
    fetch(id: string, input: L.NotificationUpdateInput): LinearFetch<NotificationPayload>;
}
/**
 * A fetchable OauthClientArchive Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class OauthClientArchiveMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the OauthClientArchive mutation and return a ArchivePayload
     *
     * @param id - required id to pass to oauthClientArchive
     * @returns parsed response from OauthClientArchiveMutation
     */
    fetch(id: string): LinearFetch<ArchivePayload>;
}
/**
 * A fetchable OauthClientCreate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class OauthClientCreateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the OauthClientCreate mutation and return a OauthClientPayload
     *
     * @param input - required input to pass to oauthClientCreate
     * @returns parsed response from OauthClientCreateMutation
     */
    fetch(input: L.OauthClientCreateInput): LinearFetch<OauthClientPayload>;
}
/**
 * A fetchable OauthClientRotateSecret Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class OauthClientRotateSecretMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the OauthClientRotateSecret mutation and return a RotateSecretPayload
     *
     * @param id - required id to pass to oauthClientRotateSecret
     * @returns parsed response from OauthClientRotateSecretMutation
     */
    fetch(id: string): LinearFetch<RotateSecretPayload>;
}
/**
 * A fetchable OauthClientUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class OauthClientUpdateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the OauthClientUpdate mutation and return a OauthClientPayload
     *
     * @param id - required id to pass to oauthClientUpdate
     * @param input - required input to pass to oauthClientUpdate
     * @returns parsed response from OauthClientUpdateMutation
     */
    fetch(id: string, input: L.OauthClientUpdateInput): LinearFetch<OauthClientPayload>;
}
/**
 * A fetchable OauthTokenRevoke Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class OauthTokenRevokeMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the OauthTokenRevoke mutation and return a OauthTokenRevokePayload
     *
     * @param appId - required appId to pass to oauthTokenRevoke
     * @param scope - required scope to pass to oauthTokenRevoke
     * @returns parsed response from OauthTokenRevokeMutation
     */
    fetch(appId: string, scope: string[]): LinearFetch<OauthTokenRevokePayload>;
}
/**
 * A fetchable OrganizationCancelDelete Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class OrganizationCancelDeleteMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the OrganizationCancelDelete mutation and return a OrganizationCancelDeletePayload
     *
     * @returns parsed response from OrganizationCancelDeleteMutation
     */
    fetch(): LinearFetch<OrganizationCancelDeletePayload>;
}
/**
 * A fetchable OrganizationDelete Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class OrganizationDeleteMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the OrganizationDelete mutation and return a OrganizationDeletePayload
     *
     * @param input - required input to pass to organizationDelete
     * @returns parsed response from OrganizationDeleteMutation
     */
    fetch(input: L.DeleteOrganizationInput): LinearFetch<OrganizationDeletePayload>;
}
/**
 * A fetchable OrganizationDeleteChallenge Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class OrganizationDeleteChallengeMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the OrganizationDeleteChallenge mutation and return a OrganizationDeletePayload
     *
     * @returns parsed response from OrganizationDeleteChallengeMutation
     */
    fetch(): LinearFetch<OrganizationDeletePayload>;
}
/**
 * A fetchable OrganizationDomainCreate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class OrganizationDomainCreateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the OrganizationDomainCreate mutation and return a OrganizationDomainPayload
     *
     * @param input - required input to pass to organizationDomainCreate
     * @returns parsed response from OrganizationDomainCreateMutation
     */
    fetch(input: L.OrganizationDomainCreateInput): LinearFetch<OrganizationDomainPayload>;
}
/**
 * A fetchable OrganizationDomainDelete Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class OrganizationDomainDeleteMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the OrganizationDomainDelete mutation and return a ArchivePayload
     *
     * @param id - required id to pass to organizationDomainDelete
     * @returns parsed response from OrganizationDomainDeleteMutation
     */
    fetch(id: string): LinearFetch<ArchivePayload>;
}
/**
 * A fetchable OrganizationDomainVerify Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class OrganizationDomainVerifyMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the OrganizationDomainVerify mutation and return a OrganizationDomainPayload
     *
     * @param input - required input to pass to organizationDomainVerify
     * @returns parsed response from OrganizationDomainVerifyMutation
     */
    fetch(input: L.OrganizationDomainVerificationInput): LinearFetch<OrganizationDomainPayload>;
}
/**
 * A fetchable OrganizationInviteCreate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class OrganizationInviteCreateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the OrganizationInviteCreate mutation and return a OrganizationInvitePayload
     *
     * @param input - required input to pass to organizationInviteCreate
     * @returns parsed response from OrganizationInviteCreateMutation
     */
    fetch(input: L.OrganizationInviteCreateInput): LinearFetch<OrganizationInvitePayload>;
}
/**
 * A fetchable OrganizationInviteDelete Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class OrganizationInviteDeleteMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the OrganizationInviteDelete mutation and return a ArchivePayload
     *
     * @param id - required id to pass to organizationInviteDelete
     * @returns parsed response from OrganizationInviteDeleteMutation
     */
    fetch(id: string): LinearFetch<ArchivePayload>;
}
/**
 * A fetchable OrganizationUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class OrganizationUpdateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the OrganizationUpdate mutation and return a OrganizationPayload
     *
     * @param input - required input to pass to organizationUpdate
     * @returns parsed response from OrganizationUpdateMutation
     */
    fetch(input: L.UpdateOrganizationInput): LinearFetch<OrganizationPayload>;
}
/**
 * A fetchable ProjectArchive Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class ProjectArchiveMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ProjectArchive mutation and return a ArchivePayload
     *
     * @param id - required id to pass to projectArchive
     * @returns parsed response from ProjectArchiveMutation
     */
    fetch(id: string): LinearFetch<ArchivePayload>;
}
/**
 * A fetchable ProjectCreate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class ProjectCreateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ProjectCreate mutation and return a ProjectPayload
     *
     * @param input - required input to pass to projectCreate
     * @returns parsed response from ProjectCreateMutation
     */
    fetch(input: L.ProjectCreateInput): LinearFetch<ProjectPayload>;
}
/**
 * A fetchable ProjectLinkCreate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class ProjectLinkCreateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ProjectLinkCreate mutation and return a ProjectLinkPayload
     *
     * @param input - required input to pass to projectLinkCreate
     * @returns parsed response from ProjectLinkCreateMutation
     */
    fetch(input: L.ProjectLinkCreateInput): LinearFetch<ProjectLinkPayload>;
}
/**
 * A fetchable ProjectLinkDelete Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class ProjectLinkDeleteMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ProjectLinkDelete mutation and return a ArchivePayload
     *
     * @param id - required id to pass to projectLinkDelete
     * @returns parsed response from ProjectLinkDeleteMutation
     */
    fetch(id: string): LinearFetch<ArchivePayload>;
}
/**
 * A fetchable ProjectLinkUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class ProjectLinkUpdateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ProjectLinkUpdate mutation and return a ProjectLinkPayload
     *
     * @param id - required id to pass to projectLinkUpdate
     * @param input - required input to pass to projectLinkUpdate
     * @returns parsed response from ProjectLinkUpdateMutation
     */
    fetch(id: string, input: L.ProjectLinkUpdateInput): LinearFetch<ProjectLinkPayload>;
}
/**
 * A fetchable ProjectUnarchive Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class ProjectUnarchiveMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ProjectUnarchive mutation and return a ArchivePayload
     *
     * @param id - required id to pass to projectUnarchive
     * @returns parsed response from ProjectUnarchiveMutation
     */
    fetch(id: string): LinearFetch<ArchivePayload>;
}
/**
 * A fetchable ProjectUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class ProjectUpdateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ProjectUpdate mutation and return a ProjectPayload
     *
     * @param id - required id to pass to projectUpdate
     * @param input - required input to pass to projectUpdate
     * @returns parsed response from ProjectUpdateMutation
     */
    fetch(id: string, input: L.ProjectUpdateInput): LinearFetch<ProjectPayload>;
}
/**
 * A fetchable PushSubscriptionCreate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class PushSubscriptionCreateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the PushSubscriptionCreate mutation and return a PushSubscriptionPayload
     *
     * @param input - required input to pass to pushSubscriptionCreate
     * @returns parsed response from PushSubscriptionCreateMutation
     */
    fetch(input: L.PushSubscriptionCreateInput): LinearFetch<PushSubscriptionPayload>;
}
/**
 * A fetchable PushSubscriptionDelete Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class PushSubscriptionDeleteMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the PushSubscriptionDelete mutation and return a PushSubscriptionPayload
     *
     * @param id - required id to pass to pushSubscriptionDelete
     * @returns parsed response from PushSubscriptionDeleteMutation
     */
    fetch(id: string): LinearFetch<PushSubscriptionPayload>;
}
/**
 * A fetchable ReactionCreate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class ReactionCreateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ReactionCreate mutation and return a ReactionPayload
     *
     * @param input - required input to pass to reactionCreate
     * @returns parsed response from ReactionCreateMutation
     */
    fetch(input: L.ReactionCreateInput): LinearFetch<ReactionPayload>;
}
/**
 * A fetchable ReactionDelete Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class ReactionDeleteMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ReactionDelete mutation and return a ArchivePayload
     *
     * @param id - required id to pass to reactionDelete
     * @returns parsed response from ReactionDeleteMutation
     */
    fetch(id: string): LinearFetch<ArchivePayload>;
}
/**
 * A fetchable RefreshGoogleSheetsData Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class RefreshGoogleSheetsDataMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the RefreshGoogleSheetsData mutation and return a IntegrationPayload
     *
     * @param id - required id to pass to refreshGoogleSheetsData
     * @returns parsed response from RefreshGoogleSheetsDataMutation
     */
    fetch(id: string): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable ResendOrganizationInvite Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class ResendOrganizationInviteMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ResendOrganizationInvite mutation and return a ArchivePayload
     *
     * @param id - required id to pass to resendOrganizationInvite
     * @returns parsed response from ResendOrganizationInviteMutation
     */
    fetch(id: string): LinearFetch<ArchivePayload>;
}
/**
 * A fetchable SamlTokenUserAccountAuth Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class SamlTokenUserAccountAuthMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the SamlTokenUserAccountAuth mutation and return a AuthResolverResponse
     *
     * @param input - required input to pass to samlTokenUserAccountAuth
     * @returns parsed response from SamlTokenUserAccountAuthMutation
     */
    fetch(input: L.TokenUserAccountAuthInput): LinearFetch<AuthResolverResponse>;
}
/**
 * A fetchable TeamCreate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class TeamCreateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the TeamCreate mutation and return a TeamPayload
     *
     * @param input - required input to pass to teamCreate
     * @param variables - variables without 'input' to pass into the TeamCreateMutation
     * @returns parsed response from TeamCreateMutation
     */
    fetch(input: L.TeamCreateInput, variables?: Omit<L.TeamCreateMutationVariables, "input">): LinearFetch<TeamPayload>;
}
/**
 * A fetchable TeamDelete Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class TeamDeleteMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the TeamDelete mutation and return a ArchivePayload
     *
     * @param id - required id to pass to teamDelete
     * @returns parsed response from TeamDeleteMutation
     */
    fetch(id: string): LinearFetch<ArchivePayload>;
}
/**
 * A fetchable TeamKeyDelete Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class TeamKeyDeleteMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the TeamKeyDelete mutation and return a ArchivePayload
     *
     * @param id - required id to pass to teamKeyDelete
     * @returns parsed response from TeamKeyDeleteMutation
     */
    fetch(id: string): LinearFetch<ArchivePayload>;
}
/**
 * A fetchable TeamMembershipCreate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class TeamMembershipCreateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the TeamMembershipCreate mutation and return a TeamMembershipPayload
     *
     * @param input - required input to pass to teamMembershipCreate
     * @returns parsed response from TeamMembershipCreateMutation
     */
    fetch(input: L.TeamMembershipCreateInput): LinearFetch<TeamMembershipPayload>;
}
/**
 * A fetchable TeamMembershipDelete Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class TeamMembershipDeleteMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the TeamMembershipDelete mutation and return a ArchivePayload
     *
     * @param id - required id to pass to teamMembershipDelete
     * @returns parsed response from TeamMembershipDeleteMutation
     */
    fetch(id: string): LinearFetch<ArchivePayload>;
}
/**
 * A fetchable TeamMembershipUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class TeamMembershipUpdateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the TeamMembershipUpdate mutation and return a TeamMembershipPayload
     *
     * @param id - required id to pass to teamMembershipUpdate
     * @param input - required input to pass to teamMembershipUpdate
     * @returns parsed response from TeamMembershipUpdateMutation
     */
    fetch(id: string, input: L.TeamMembershipUpdateInput): LinearFetch<TeamMembershipPayload>;
}
/**
 * A fetchable TeamUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class TeamUpdateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the TeamUpdate mutation and return a TeamPayload
     *
     * @param id - required id to pass to teamUpdate
     * @param input - required input to pass to teamUpdate
     * @returns parsed response from TeamUpdateMutation
     */
    fetch(id: string, input: L.TeamUpdateInput): LinearFetch<TeamPayload>;
}
/**
 * A fetchable TemplateCreate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class TemplateCreateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the TemplateCreate mutation and return a TemplatePayload
     *
     * @param input - required input to pass to templateCreate
     * @returns parsed response from TemplateCreateMutation
     */
    fetch(input: L.TemplateCreateInput): LinearFetch<TemplatePayload>;
}
/**
 * A fetchable TemplateDelete Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class TemplateDeleteMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the TemplateDelete mutation and return a ArchivePayload
     *
     * @param id - required id to pass to templateDelete
     * @returns parsed response from TemplateDeleteMutation
     */
    fetch(id: string): LinearFetch<ArchivePayload>;
}
/**
 * A fetchable TemplateUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class TemplateUpdateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the TemplateUpdate mutation and return a TemplatePayload
     *
     * @param id - required id to pass to templateUpdate
     * @param input - required input to pass to templateUpdate
     * @returns parsed response from TemplateUpdateMutation
     */
    fetch(id: string, input: L.TemplateUpdateInput): LinearFetch<TemplatePayload>;
}
/**
 * A fetchable UserDemoteAdmin Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UserDemoteAdminMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UserDemoteAdmin mutation and return a UserAdminPayload
     *
     * @param id - required id to pass to userDemoteAdmin
     * @returns parsed response from UserDemoteAdminMutation
     */
    fetch(id: string): LinearFetch<UserAdminPayload>;
}
/**
 * A fetchable UserFlagUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UserFlagUpdateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UserFlagUpdate mutation and return a UserSettingsFlagPayload
     *
     * @param flag - required flag to pass to userFlagUpdate
     * @param operation - required operation to pass to userFlagUpdate
     * @returns parsed response from UserFlagUpdateMutation
     */
    fetch(flag: L.UserFlagType, operation: L.UserFlagUpdateOperation): LinearFetch<UserSettingsFlagPayload>;
}
/**
 * A fetchable UserPromoteAdmin Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UserPromoteAdminMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UserPromoteAdmin mutation and return a UserAdminPayload
     *
     * @param id - required id to pass to userPromoteAdmin
     * @returns parsed response from UserPromoteAdminMutation
     */
    fetch(id: string): LinearFetch<UserAdminPayload>;
}
/**
 * A fetchable UserSettingsFlagIncrement Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UserSettingsFlagIncrementMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UserSettingsFlagIncrement mutation and return a UserSettingsFlagPayload
     *
     * @param flag - required flag to pass to userSettingsFlagIncrement
     * @returns parsed response from UserSettingsFlagIncrementMutation
     */
    fetch(flag: string): LinearFetch<UserSettingsFlagPayload>;
}
/**
 * A fetchable UserSettingsFlagsReset Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UserSettingsFlagsResetMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UserSettingsFlagsReset mutation and return a UserSettingsFlagsResetPayload
     *
     * @returns parsed response from UserSettingsFlagsResetMutation
     */
    fetch(): LinearFetch<UserSettingsFlagsResetPayload>;
}
/**
 * A fetchable UserSettingsUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UserSettingsUpdateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UserSettingsUpdate mutation and return a UserSettingsPayload
     *
     * @param id - required id to pass to userSettingsUpdate
     * @param input - required input to pass to userSettingsUpdate
     * @returns parsed response from UserSettingsUpdateMutation
     */
    fetch(id: string, input: L.UserSettingsUpdateInput): LinearFetch<UserSettingsPayload>;
}
/**
 * A fetchable UserSubscribeToNewsletter Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UserSubscribeToNewsletterMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UserSubscribeToNewsletter mutation and return a UserSubscribeToNewsletterPayload
     *
     * @returns parsed response from UserSubscribeToNewsletterMutation
     */
    fetch(): LinearFetch<UserSubscribeToNewsletterPayload>;
}
/**
 * A fetchable UserSuspend Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UserSuspendMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UserSuspend mutation and return a UserAdminPayload
     *
     * @param id - required id to pass to userSuspend
     * @returns parsed response from UserSuspendMutation
     */
    fetch(id: string): LinearFetch<UserAdminPayload>;
}
/**
 * A fetchable UserUnsuspend Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UserUnsuspendMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UserUnsuspend mutation and return a UserAdminPayload
     *
     * @param id - required id to pass to userUnsuspend
     * @returns parsed response from UserUnsuspendMutation
     */
    fetch(id: string): LinearFetch<UserAdminPayload>;
}
/**
 * A fetchable UserUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UserUpdateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UserUpdate mutation and return a UserPayload
     *
     * @param id - required id to pass to userUpdate
     * @param input - required input to pass to userUpdate
     * @returns parsed response from UserUpdateMutation
     */
    fetch(id: string, input: L.UpdateUserInput): LinearFetch<UserPayload>;
}
/**
 * A fetchable ViewPreferencesCreate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class ViewPreferencesCreateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ViewPreferencesCreate mutation and return a ViewPreferencesPayload
     *
     * @param input - required input to pass to viewPreferencesCreate
     * @returns parsed response from ViewPreferencesCreateMutation
     */
    fetch(input: L.ViewPreferencesCreateInput): LinearFetch<ViewPreferencesPayload>;
}
/**
 * A fetchable ViewPreferencesDelete Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class ViewPreferencesDeleteMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ViewPreferencesDelete mutation and return a ArchivePayload
     *
     * @param id - required id to pass to viewPreferencesDelete
     * @returns parsed response from ViewPreferencesDeleteMutation
     */
    fetch(id: string): LinearFetch<ArchivePayload>;
}
/**
 * A fetchable ViewPreferencesUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class ViewPreferencesUpdateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ViewPreferencesUpdate mutation and return a ViewPreferencesPayload
     *
     * @param id - required id to pass to viewPreferencesUpdate
     * @param input - required input to pass to viewPreferencesUpdate
     * @returns parsed response from ViewPreferencesUpdateMutation
     */
    fetch(id: string, input: L.ViewPreferencesUpdateInput): LinearFetch<ViewPreferencesPayload>;
}
/**
 * A fetchable WebhookCreate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class WebhookCreateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the WebhookCreate mutation and return a WebhookPayload
     *
     * @param input - required input to pass to webhookCreate
     * @returns parsed response from WebhookCreateMutation
     */
    fetch(input: L.WebhookCreateInput): LinearFetch<WebhookPayload>;
}
/**
 * A fetchable WebhookDelete Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class WebhookDeleteMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the WebhookDelete mutation and return a ArchivePayload
     *
     * @param id - required id to pass to webhookDelete
     * @returns parsed response from WebhookDeleteMutation
     */
    fetch(id: string): LinearFetch<ArchivePayload>;
}
/**
 * A fetchable WebhookUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class WebhookUpdateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the WebhookUpdate mutation and return a WebhookPayload
     *
     * @param id - required id to pass to webhookUpdate
     * @param input - required input to pass to webhookUpdate
     * @returns parsed response from WebhookUpdateMutation
     */
    fetch(id: string, input: L.WebhookUpdateInput): LinearFetch<WebhookPayload>;
}
/**
 * A fetchable WorkflowStateArchive Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class WorkflowStateArchiveMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the WorkflowStateArchive mutation and return a ArchivePayload
     *
     * @param id - required id to pass to workflowStateArchive
     * @returns parsed response from WorkflowStateArchiveMutation
     */
    fetch(id: string): LinearFetch<ArchivePayload>;
}
/**
 * A fetchable WorkflowStateCreate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class WorkflowStateCreateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the WorkflowStateCreate mutation and return a WorkflowStatePayload
     *
     * @param input - required input to pass to workflowStateCreate
     * @returns parsed response from WorkflowStateCreateMutation
     */
    fetch(input: L.WorkflowStateCreateInput): LinearFetch<WorkflowStatePayload>;
}
/**
 * A fetchable WorkflowStateUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class WorkflowStateUpdateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the WorkflowStateUpdate mutation and return a WorkflowStatePayload
     *
     * @param id - required id to pass to workflowStateUpdate
     * @param input - required input to pass to workflowStateUpdate
     * @returns parsed response from WorkflowStateUpdateMutation
     */
    fetch(id: string, input: L.WorkflowStateUpdateInput): LinearFetch<WorkflowStatePayload>;
}
/**
 * A fetchable AttachmentIssue_Attachments Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to attachmentIssue
 * @param variables - variables without 'id' to pass into the AttachmentIssue_AttachmentsQuery
 */
export declare class AttachmentIssue_AttachmentsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.AttachmentIssue_AttachmentsQueryVariables, "id">);
    /**
     * Call the AttachmentIssue_Attachments query and return a AttachmentConnection
     *
     * @param variables - variables without 'id' to pass into the AttachmentIssue_AttachmentsQuery
     * @returns parsed response from AttachmentIssue_AttachmentsQuery
     */
    fetch(variables?: Omit<L.AttachmentIssue_AttachmentsQueryVariables, "id">): LinearFetch<AttachmentConnection>;
}
/**
 * A fetchable AttachmentIssue_Children Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to attachmentIssue
 * @param variables - variables without 'id' to pass into the AttachmentIssue_ChildrenQuery
 */
export declare class AttachmentIssue_ChildrenQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.AttachmentIssue_ChildrenQueryVariables, "id">);
    /**
     * Call the AttachmentIssue_Children query and return a IssueConnection
     *
     * @param variables - variables without 'id' to pass into the AttachmentIssue_ChildrenQuery
     * @returns parsed response from AttachmentIssue_ChildrenQuery
     */
    fetch(variables?: Omit<L.AttachmentIssue_ChildrenQueryVariables, "id">): LinearFetch<IssueConnection>;
}
/**
 * A fetchable AttachmentIssue_Comments Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to attachmentIssue
 * @param variables - variables without 'id' to pass into the AttachmentIssue_CommentsQuery
 */
export declare class AttachmentIssue_CommentsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.AttachmentIssue_CommentsQueryVariables, "id">);
    /**
     * Call the AttachmentIssue_Comments query and return a CommentConnection
     *
     * @param variables - variables without 'id' to pass into the AttachmentIssue_CommentsQuery
     * @returns parsed response from AttachmentIssue_CommentsQuery
     */
    fetch(variables?: Omit<L.AttachmentIssue_CommentsQueryVariables, "id">): LinearFetch<CommentConnection>;
}
/**
 * A fetchable AttachmentIssue_History Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to attachmentIssue
 * @param variables - variables without 'id' to pass into the AttachmentIssue_HistoryQuery
 */
export declare class AttachmentIssue_HistoryQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.AttachmentIssue_HistoryQueryVariables, "id">);
    /**
     * Call the AttachmentIssue_History query and return a IssueHistoryConnection
     *
     * @param variables - variables without 'id' to pass into the AttachmentIssue_HistoryQuery
     * @returns parsed response from AttachmentIssue_HistoryQuery
     */
    fetch(variables?: Omit<L.AttachmentIssue_HistoryQueryVariables, "id">): LinearFetch<IssueHistoryConnection>;
}
/**
 * A fetchable AttachmentIssue_InverseRelations Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to attachmentIssue
 * @param variables - variables without 'id' to pass into the AttachmentIssue_InverseRelationsQuery
 */
export declare class AttachmentIssue_InverseRelationsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.AttachmentIssue_InverseRelationsQueryVariables, "id">);
    /**
     * Call the AttachmentIssue_InverseRelations query and return a IssueRelationConnection
     *
     * @param variables - variables without 'id' to pass into the AttachmentIssue_InverseRelationsQuery
     * @returns parsed response from AttachmentIssue_InverseRelationsQuery
     */
    fetch(variables?: Omit<L.AttachmentIssue_InverseRelationsQueryVariables, "id">): LinearFetch<IssueRelationConnection>;
}
/**
 * A fetchable AttachmentIssue_Labels Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to attachmentIssue
 * @param variables - variables without 'id' to pass into the AttachmentIssue_LabelsQuery
 */
export declare class AttachmentIssue_LabelsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.AttachmentIssue_LabelsQueryVariables, "id">);
    /**
     * Call the AttachmentIssue_Labels query and return a IssueLabelConnection
     *
     * @param variables - variables without 'id' to pass into the AttachmentIssue_LabelsQuery
     * @returns parsed response from AttachmentIssue_LabelsQuery
     */
    fetch(variables?: Omit<L.AttachmentIssue_LabelsQueryVariables, "id">): LinearFetch<IssueLabelConnection>;
}
/**
 * A fetchable AttachmentIssue_Relations Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to attachmentIssue
 * @param variables - variables without 'id' to pass into the AttachmentIssue_RelationsQuery
 */
export declare class AttachmentIssue_RelationsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.AttachmentIssue_RelationsQueryVariables, "id">);
    /**
     * Call the AttachmentIssue_Relations query and return a IssueRelationConnection
     *
     * @param variables - variables without 'id' to pass into the AttachmentIssue_RelationsQuery
     * @returns parsed response from AttachmentIssue_RelationsQuery
     */
    fetch(variables?: Omit<L.AttachmentIssue_RelationsQueryVariables, "id">): LinearFetch<IssueRelationConnection>;
}
/**
 * A fetchable AttachmentIssue_Subscribers Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to attachmentIssue
 * @param variables - variables without 'id' to pass into the AttachmentIssue_SubscribersQuery
 */
export declare class AttachmentIssue_SubscribersQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.AttachmentIssue_SubscribersQueryVariables, "id">);
    /**
     * Call the AttachmentIssue_Subscribers query and return a UserConnection
     *
     * @param variables - variables without 'id' to pass into the AttachmentIssue_SubscribersQuery
     * @returns parsed response from AttachmentIssue_SubscribersQuery
     */
    fetch(variables?: Omit<L.AttachmentIssue_SubscribersQueryVariables, "id">): LinearFetch<UserConnection>;
}
/**
 * A fetchable BillingDetails_PaymentMethod Query
 *
 * @param request - function to call the graphql client
 */
export declare class BillingDetails_PaymentMethodQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the BillingDetails_PaymentMethod query and return a Card
     *
     * @returns parsed response from BillingDetails_PaymentMethodQuery
     */
    fetch(): LinearFetch<Card | undefined>;
}
/**
 * A fetchable CollaborativeDocumentJoin_Steps Query
 *
 * @param request - function to call the graphql client
 * @param clientId - required clientId to pass to collaborativeDocumentJoin
 * @param issueId - required issueId to pass to collaborativeDocumentJoin
 * @param version - required version to pass to collaborativeDocumentJoin
 */
export declare class CollaborativeDocumentJoin_StepsQuery extends Request {
    private _clientId;
    private _issueId;
    private _version;
    constructor(request: LinearRequest, clientId: string, issueId: string, version: number);
    /**
     * Call the CollaborativeDocumentJoin_Steps query and return a StepsResponse
     *
     * @returns parsed response from CollaborativeDocumentJoin_StepsQuery
     */
    fetch(): LinearFetch<StepsResponse | undefined>;
}
/**
 * A fetchable Cycle_Issues Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to cycle
 * @param variables - variables without 'id' to pass into the Cycle_IssuesQuery
 */
export declare class Cycle_IssuesQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Cycle_IssuesQueryVariables, "id">);
    /**
     * Call the Cycle_Issues query and return a IssueConnection
     *
     * @param variables - variables without 'id' to pass into the Cycle_IssuesQuery
     * @returns parsed response from Cycle_IssuesQuery
     */
    fetch(variables?: Omit<L.Cycle_IssuesQueryVariables, "id">): LinearFetch<IssueConnection>;
}
/**
 * A fetchable Cycle_UncompletedIssuesUponClose Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to cycle
 * @param variables - variables without 'id' to pass into the Cycle_UncompletedIssuesUponCloseQuery
 */
export declare class Cycle_UncompletedIssuesUponCloseQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Cycle_UncompletedIssuesUponCloseQueryVariables, "id">);
    /**
     * Call the Cycle_UncompletedIssuesUponClose query and return a IssueConnection
     *
     * @param variables - variables without 'id' to pass into the Cycle_UncompletedIssuesUponCloseQuery
     * @returns parsed response from Cycle_UncompletedIssuesUponCloseQuery
     */
    fetch(variables?: Omit<L.Cycle_UncompletedIssuesUponCloseQueryVariables, "id">): LinearFetch<IssueConnection>;
}
/**
 * A fetchable Favorite_Children Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to favorite
 * @param variables - variables without 'id' to pass into the Favorite_ChildrenQuery
 */
export declare class Favorite_ChildrenQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Favorite_ChildrenQueryVariables, "id">);
    /**
     * Call the Favorite_Children query and return a FavoriteConnection
     *
     * @param variables - variables without 'id' to pass into the Favorite_ChildrenQuery
     * @returns parsed response from Favorite_ChildrenQuery
     */
    fetch(variables?: Omit<L.Favorite_ChildrenQueryVariables, "id">): LinearFetch<FavoriteConnection>;
}
/**
 * A fetchable FigmaEmbedInfo_FigmaEmbed Query
 *
 * @param request - function to call the graphql client
 * @param fileId - required fileId to pass to figmaEmbedInfo
 * @param variables - variables without 'fileId' to pass into the FigmaEmbedInfo_FigmaEmbedQuery
 */
export declare class FigmaEmbedInfo_FigmaEmbedQuery extends Request {
    private _fileId;
    private _variables?;
    constructor(request: LinearRequest, fileId: string, variables?: Omit<L.FigmaEmbedInfo_FigmaEmbedQueryVariables, "fileId">);
    /**
     * Call the FigmaEmbedInfo_FigmaEmbed query and return a FigmaEmbed
     *
     * @param variables - variables without 'fileId' to pass into the FigmaEmbedInfo_FigmaEmbedQuery
     * @returns parsed response from FigmaEmbedInfo_FigmaEmbedQuery
     */
    fetch(variables?: Omit<L.FigmaEmbedInfo_FigmaEmbedQueryVariables, "fileId">): LinearFetch<FigmaEmbed | undefined>;
}
/**
 * A fetchable Issue_Attachments Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to issue
 * @param variables - variables without 'id' to pass into the Issue_AttachmentsQuery
 */
export declare class Issue_AttachmentsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Issue_AttachmentsQueryVariables, "id">);
    /**
     * Call the Issue_Attachments query and return a AttachmentConnection
     *
     * @param variables - variables without 'id' to pass into the Issue_AttachmentsQuery
     * @returns parsed response from Issue_AttachmentsQuery
     */
    fetch(variables?: Omit<L.Issue_AttachmentsQueryVariables, "id">): LinearFetch<AttachmentConnection>;
}
/**
 * A fetchable Issue_Children Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to issue
 * @param variables - variables without 'id' to pass into the Issue_ChildrenQuery
 */
export declare class Issue_ChildrenQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Issue_ChildrenQueryVariables, "id">);
    /**
     * Call the Issue_Children query and return a IssueConnection
     *
     * @param variables - variables without 'id' to pass into the Issue_ChildrenQuery
     * @returns parsed response from Issue_ChildrenQuery
     */
    fetch(variables?: Omit<L.Issue_ChildrenQueryVariables, "id">): LinearFetch<IssueConnection>;
}
/**
 * A fetchable Issue_Comments Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to issue
 * @param variables - variables without 'id' to pass into the Issue_CommentsQuery
 */
export declare class Issue_CommentsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Issue_CommentsQueryVariables, "id">);
    /**
     * Call the Issue_Comments query and return a CommentConnection
     *
     * @param variables - variables without 'id' to pass into the Issue_CommentsQuery
     * @returns parsed response from Issue_CommentsQuery
     */
    fetch(variables?: Omit<L.Issue_CommentsQueryVariables, "id">): LinearFetch<CommentConnection>;
}
/**
 * A fetchable Issue_History Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to issue
 * @param variables - variables without 'id' to pass into the Issue_HistoryQuery
 */
export declare class Issue_HistoryQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Issue_HistoryQueryVariables, "id">);
    /**
     * Call the Issue_History query and return a IssueHistoryConnection
     *
     * @param variables - variables without 'id' to pass into the Issue_HistoryQuery
     * @returns parsed response from Issue_HistoryQuery
     */
    fetch(variables?: Omit<L.Issue_HistoryQueryVariables, "id">): LinearFetch<IssueHistoryConnection>;
}
/**
 * A fetchable Issue_InverseRelations Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to issue
 * @param variables - variables without 'id' to pass into the Issue_InverseRelationsQuery
 */
export declare class Issue_InverseRelationsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Issue_InverseRelationsQueryVariables, "id">);
    /**
     * Call the Issue_InverseRelations query and return a IssueRelationConnection
     *
     * @param variables - variables without 'id' to pass into the Issue_InverseRelationsQuery
     * @returns parsed response from Issue_InverseRelationsQuery
     */
    fetch(variables?: Omit<L.Issue_InverseRelationsQueryVariables, "id">): LinearFetch<IssueRelationConnection>;
}
/**
 * A fetchable Issue_Labels Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to issue
 * @param variables - variables without 'id' to pass into the Issue_LabelsQuery
 */
export declare class Issue_LabelsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Issue_LabelsQueryVariables, "id">);
    /**
     * Call the Issue_Labels query and return a IssueLabelConnection
     *
     * @param variables - variables without 'id' to pass into the Issue_LabelsQuery
     * @returns parsed response from Issue_LabelsQuery
     */
    fetch(variables?: Omit<L.Issue_LabelsQueryVariables, "id">): LinearFetch<IssueLabelConnection>;
}
/**
 * A fetchable Issue_Relations Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to issue
 * @param variables - variables without 'id' to pass into the Issue_RelationsQuery
 */
export declare class Issue_RelationsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Issue_RelationsQueryVariables, "id">);
    /**
     * Call the Issue_Relations query and return a IssueRelationConnection
     *
     * @param variables - variables without 'id' to pass into the Issue_RelationsQuery
     * @returns parsed response from Issue_RelationsQuery
     */
    fetch(variables?: Omit<L.Issue_RelationsQueryVariables, "id">): LinearFetch<IssueRelationConnection>;
}
/**
 * A fetchable Issue_Subscribers Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to issue
 * @param variables - variables without 'id' to pass into the Issue_SubscribersQuery
 */
export declare class Issue_SubscribersQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Issue_SubscribersQueryVariables, "id">);
    /**
     * Call the Issue_Subscribers query and return a UserConnection
     *
     * @param variables - variables without 'id' to pass into the Issue_SubscribersQuery
     * @returns parsed response from Issue_SubscribersQuery
     */
    fetch(variables?: Omit<L.Issue_SubscribersQueryVariables, "id">): LinearFetch<UserConnection>;
}
/**
 * A fetchable IssueLabel_Issues Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to issueLabel
 * @param variables - variables without 'id' to pass into the IssueLabel_IssuesQuery
 */
export declare class IssueLabel_IssuesQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.IssueLabel_IssuesQueryVariables, "id">);
    /**
     * Call the IssueLabel_Issues query and return a IssueConnection
     *
     * @param variables - variables without 'id' to pass into the IssueLabel_IssuesQuery
     * @returns parsed response from IssueLabel_IssuesQuery
     */
    fetch(variables?: Omit<L.IssueLabel_IssuesQueryVariables, "id">): LinearFetch<IssueConnection>;
}
/**
 * A fetchable Milestone_Projects Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to milestone
 * @param variables - variables without 'id' to pass into the Milestone_ProjectsQuery
 */
export declare class Milestone_ProjectsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Milestone_ProjectsQueryVariables, "id">);
    /**
     * Call the Milestone_Projects query and return a ProjectConnection
     *
     * @param variables - variables without 'id' to pass into the Milestone_ProjectsQuery
     * @returns parsed response from Milestone_ProjectsQuery
     */
    fetch(variables?: Omit<L.Milestone_ProjectsQueryVariables, "id">): LinearFetch<ProjectConnection>;
}
/**
 * A fetchable Organization_Integrations Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Organization_IntegrationsQuery
 */
export declare class Organization_IntegrationsQuery extends Request {
    private _variables?;
    constructor(request: LinearRequest, variables?: L.Organization_IntegrationsQueryVariables);
    /**
     * Call the Organization_Integrations query and return a IntegrationConnection
     *
     * @param variables - variables to pass into the Organization_IntegrationsQuery
     * @returns parsed response from Organization_IntegrationsQuery
     */
    fetch(variables?: L.Organization_IntegrationsQueryVariables): LinearFetch<IntegrationConnection>;
}
/**
 * A fetchable Organization_Labels Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Organization_LabelsQuery
 */
export declare class Organization_LabelsQuery extends Request {
    private _variables?;
    constructor(request: LinearRequest, variables?: L.Organization_LabelsQueryVariables);
    /**
     * Call the Organization_Labels query and return a IssueLabelConnection
     *
     * @param variables - variables to pass into the Organization_LabelsQuery
     * @returns parsed response from Organization_LabelsQuery
     */
    fetch(variables?: L.Organization_LabelsQueryVariables): LinearFetch<IssueLabelConnection>;
}
/**
 * A fetchable Organization_Milestones Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Organization_MilestonesQuery
 */
export declare class Organization_MilestonesQuery extends Request {
    private _variables?;
    constructor(request: LinearRequest, variables?: L.Organization_MilestonesQueryVariables);
    /**
     * Call the Organization_Milestones query and return a MilestoneConnection
     *
     * @param variables - variables to pass into the Organization_MilestonesQuery
     * @returns parsed response from Organization_MilestonesQuery
     */
    fetch(variables?: L.Organization_MilestonesQueryVariables): LinearFetch<MilestoneConnection>;
}
/**
 * A fetchable Organization_Teams Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Organization_TeamsQuery
 */
export declare class Organization_TeamsQuery extends Request {
    private _variables?;
    constructor(request: LinearRequest, variables?: L.Organization_TeamsQueryVariables);
    /**
     * Call the Organization_Teams query and return a TeamConnection
     *
     * @param variables - variables to pass into the Organization_TeamsQuery
     * @returns parsed response from Organization_TeamsQuery
     */
    fetch(variables?: L.Organization_TeamsQueryVariables): LinearFetch<TeamConnection>;
}
/**
 * A fetchable Organization_Templates Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Organization_TemplatesQuery
 */
export declare class Organization_TemplatesQuery extends Request {
    private _variables?;
    constructor(request: LinearRequest, variables?: L.Organization_TemplatesQueryVariables);
    /**
     * Call the Organization_Templates query and return a TemplateConnection
     *
     * @param variables - variables to pass into the Organization_TemplatesQuery
     * @returns parsed response from Organization_TemplatesQuery
     */
    fetch(variables?: L.Organization_TemplatesQueryVariables): LinearFetch<TemplateConnection>;
}
/**
 * A fetchable Organization_Users Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Organization_UsersQuery
 */
export declare class Organization_UsersQuery extends Request {
    private _variables?;
    constructor(request: LinearRequest, variables?: L.Organization_UsersQueryVariables);
    /**
     * Call the Organization_Users query and return a UserConnection
     *
     * @param variables - variables to pass into the Organization_UsersQuery
     * @returns parsed response from Organization_UsersQuery
     */
    fetch(variables?: L.Organization_UsersQueryVariables): LinearFetch<UserConnection>;
}
/**
 * A fetchable Project_Documents Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to project
 * @param variables - variables without 'id' to pass into the Project_DocumentsQuery
 */
export declare class Project_DocumentsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Project_DocumentsQueryVariables, "id">);
    /**
     * Call the Project_Documents query and return a DocumentConnection
     *
     * @param variables - variables without 'id' to pass into the Project_DocumentsQuery
     * @returns parsed response from Project_DocumentsQuery
     */
    fetch(variables?: Omit<L.Project_DocumentsQueryVariables, "id">): LinearFetch<DocumentConnection>;
}
/**
 * A fetchable Project_Issues Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to project
 * @param variables - variables without 'id' to pass into the Project_IssuesQuery
 */
export declare class Project_IssuesQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Project_IssuesQueryVariables, "id">);
    /**
     * Call the Project_Issues query and return a IssueConnection
     *
     * @param variables - variables without 'id' to pass into the Project_IssuesQuery
     * @returns parsed response from Project_IssuesQuery
     */
    fetch(variables?: Omit<L.Project_IssuesQueryVariables, "id">): LinearFetch<IssueConnection>;
}
/**
 * A fetchable Project_Links Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to project
 * @param variables - variables without 'id' to pass into the Project_LinksQuery
 */
export declare class Project_LinksQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Project_LinksQueryVariables, "id">);
    /**
     * Call the Project_Links query and return a ProjectLinkConnection
     *
     * @param variables - variables without 'id' to pass into the Project_LinksQuery
     * @returns parsed response from Project_LinksQuery
     */
    fetch(variables?: Omit<L.Project_LinksQueryVariables, "id">): LinearFetch<ProjectLinkConnection>;
}
/**
 * A fetchable Project_Members Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to project
 * @param variables - variables without 'id' to pass into the Project_MembersQuery
 */
export declare class Project_MembersQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Project_MembersQueryVariables, "id">);
    /**
     * Call the Project_Members query and return a UserConnection
     *
     * @param variables - variables without 'id' to pass into the Project_MembersQuery
     * @returns parsed response from Project_MembersQuery
     */
    fetch(variables?: Omit<L.Project_MembersQueryVariables, "id">): LinearFetch<UserConnection>;
}
/**
 * A fetchable Project_Teams Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to project
 * @param variables - variables without 'id' to pass into the Project_TeamsQuery
 */
export declare class Project_TeamsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Project_TeamsQueryVariables, "id">);
    /**
     * Call the Project_Teams query and return a TeamConnection
     *
     * @param variables - variables without 'id' to pass into the Project_TeamsQuery
     * @returns parsed response from Project_TeamsQuery
     */
    fetch(variables?: Omit<L.Project_TeamsQueryVariables, "id">): LinearFetch<TeamConnection>;
}
/**
 * A fetchable Team_Cycles Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to team
 * @param variables - variables without 'id' to pass into the Team_CyclesQuery
 */
export declare class Team_CyclesQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Team_CyclesQueryVariables, "id">);
    /**
     * Call the Team_Cycles query and return a CycleConnection
     *
     * @param variables - variables without 'id' to pass into the Team_CyclesQuery
     * @returns parsed response from Team_CyclesQuery
     */
    fetch(variables?: Omit<L.Team_CyclesQueryVariables, "id">): LinearFetch<CycleConnection>;
}
/**
 * A fetchable Team_Issues Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to team
 * @param variables - variables without 'id' to pass into the Team_IssuesQuery
 */
export declare class Team_IssuesQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Team_IssuesQueryVariables, "id">);
    /**
     * Call the Team_Issues query and return a IssueConnection
     *
     * @param variables - variables without 'id' to pass into the Team_IssuesQuery
     * @returns parsed response from Team_IssuesQuery
     */
    fetch(variables?: Omit<L.Team_IssuesQueryVariables, "id">): LinearFetch<IssueConnection>;
}
/**
 * A fetchable Team_Labels Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to team
 * @param variables - variables without 'id' to pass into the Team_LabelsQuery
 */
export declare class Team_LabelsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Team_LabelsQueryVariables, "id">);
    /**
     * Call the Team_Labels query and return a IssueLabelConnection
     *
     * @param variables - variables without 'id' to pass into the Team_LabelsQuery
     * @returns parsed response from Team_LabelsQuery
     */
    fetch(variables?: Omit<L.Team_LabelsQueryVariables, "id">): LinearFetch<IssueLabelConnection>;
}
/**
 * A fetchable Team_Members Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to team
 * @param variables - variables without 'id' to pass into the Team_MembersQuery
 */
export declare class Team_MembersQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Team_MembersQueryVariables, "id">);
    /**
     * Call the Team_Members query and return a UserConnection
     *
     * @param variables - variables without 'id' to pass into the Team_MembersQuery
     * @returns parsed response from Team_MembersQuery
     */
    fetch(variables?: Omit<L.Team_MembersQueryVariables, "id">): LinearFetch<UserConnection>;
}
/**
 * A fetchable Team_Memberships Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to team
 * @param variables - variables without 'id' to pass into the Team_MembershipsQuery
 */
export declare class Team_MembershipsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Team_MembershipsQueryVariables, "id">);
    /**
     * Call the Team_Memberships query and return a TeamMembershipConnection
     *
     * @param variables - variables without 'id' to pass into the Team_MembershipsQuery
     * @returns parsed response from Team_MembershipsQuery
     */
    fetch(variables?: Omit<L.Team_MembershipsQueryVariables, "id">): LinearFetch<TeamMembershipConnection>;
}
/**
 * A fetchable Team_Projects Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to team
 * @param variables - variables without 'id' to pass into the Team_ProjectsQuery
 */
export declare class Team_ProjectsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Team_ProjectsQueryVariables, "id">);
    /**
     * Call the Team_Projects query and return a ProjectConnection
     *
     * @param variables - variables without 'id' to pass into the Team_ProjectsQuery
     * @returns parsed response from Team_ProjectsQuery
     */
    fetch(variables?: Omit<L.Team_ProjectsQueryVariables, "id">): LinearFetch<ProjectConnection>;
}
/**
 * A fetchable Team_States Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to team
 * @param variables - variables without 'id' to pass into the Team_StatesQuery
 */
export declare class Team_StatesQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Team_StatesQueryVariables, "id">);
    /**
     * Call the Team_States query and return a WorkflowStateConnection
     *
     * @param variables - variables without 'id' to pass into the Team_StatesQuery
     * @returns parsed response from Team_StatesQuery
     */
    fetch(variables?: Omit<L.Team_StatesQueryVariables, "id">): LinearFetch<WorkflowStateConnection>;
}
/**
 * A fetchable Team_Templates Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to team
 * @param variables - variables without 'id' to pass into the Team_TemplatesQuery
 */
export declare class Team_TemplatesQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Team_TemplatesQueryVariables, "id">);
    /**
     * Call the Team_Templates query and return a TemplateConnection
     *
     * @param variables - variables without 'id' to pass into the Team_TemplatesQuery
     * @returns parsed response from Team_TemplatesQuery
     */
    fetch(variables?: Omit<L.Team_TemplatesQueryVariables, "id">): LinearFetch<TemplateConnection>;
}
/**
 * A fetchable Team_Webhooks Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to team
 * @param variables - variables without 'id' to pass into the Team_WebhooksQuery
 */
export declare class Team_WebhooksQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Team_WebhooksQueryVariables, "id">);
    /**
     * Call the Team_Webhooks query and return a WebhookConnection
     *
     * @param variables - variables without 'id' to pass into the Team_WebhooksQuery
     * @returns parsed response from Team_WebhooksQuery
     */
    fetch(variables?: Omit<L.Team_WebhooksQueryVariables, "id">): LinearFetch<WebhookConnection>;
}
/**
 * A fetchable User_AssignedIssues Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to user
 * @param variables - variables without 'id' to pass into the User_AssignedIssuesQuery
 */
export declare class User_AssignedIssuesQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.User_AssignedIssuesQueryVariables, "id">);
    /**
     * Call the User_AssignedIssues query and return a IssueConnection
     *
     * @param variables - variables without 'id' to pass into the User_AssignedIssuesQuery
     * @returns parsed response from User_AssignedIssuesQuery
     */
    fetch(variables?: Omit<L.User_AssignedIssuesQueryVariables, "id">): LinearFetch<IssueConnection>;
}
/**
 * A fetchable User_CreatedIssues Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to user
 * @param variables - variables without 'id' to pass into the User_CreatedIssuesQuery
 */
export declare class User_CreatedIssuesQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.User_CreatedIssuesQueryVariables, "id">);
    /**
     * Call the User_CreatedIssues query and return a IssueConnection
     *
     * @param variables - variables without 'id' to pass into the User_CreatedIssuesQuery
     * @returns parsed response from User_CreatedIssuesQuery
     */
    fetch(variables?: Omit<L.User_CreatedIssuesQueryVariables, "id">): LinearFetch<IssueConnection>;
}
/**
 * A fetchable User_TeamMemberships Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to user
 * @param variables - variables without 'id' to pass into the User_TeamMembershipsQuery
 */
export declare class User_TeamMembershipsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.User_TeamMembershipsQueryVariables, "id">);
    /**
     * Call the User_TeamMemberships query and return a TeamMembershipConnection
     *
     * @param variables - variables without 'id' to pass into the User_TeamMembershipsQuery
     * @returns parsed response from User_TeamMembershipsQuery
     */
    fetch(variables?: Omit<L.User_TeamMembershipsQueryVariables, "id">): LinearFetch<TeamMembershipConnection>;
}
/**
 * A fetchable User_Teams Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to user
 * @param variables - variables without 'id' to pass into the User_TeamsQuery
 */
export declare class User_TeamsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.User_TeamsQueryVariables, "id">);
    /**
     * Call the User_Teams query and return a TeamConnection
     *
     * @param variables - variables without 'id' to pass into the User_TeamsQuery
     * @returns parsed response from User_TeamsQuery
     */
    fetch(variables?: Omit<L.User_TeamsQueryVariables, "id">): LinearFetch<TeamConnection>;
}
/**
 * A fetchable Viewer_AssignedIssues Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Viewer_AssignedIssuesQuery
 */
export declare class Viewer_AssignedIssuesQuery extends Request {
    private _variables?;
    constructor(request: LinearRequest, variables?: L.Viewer_AssignedIssuesQueryVariables);
    /**
     * Call the Viewer_AssignedIssues query and return a IssueConnection
     *
     * @param variables - variables to pass into the Viewer_AssignedIssuesQuery
     * @returns parsed response from Viewer_AssignedIssuesQuery
     */
    fetch(variables?: L.Viewer_AssignedIssuesQueryVariables): LinearFetch<IssueConnection>;
}
/**
 * A fetchable Viewer_CreatedIssues Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Viewer_CreatedIssuesQuery
 */
export declare class Viewer_CreatedIssuesQuery extends Request {
    private _variables?;
    constructor(request: LinearRequest, variables?: L.Viewer_CreatedIssuesQueryVariables);
    /**
     * Call the Viewer_CreatedIssues query and return a IssueConnection
     *
     * @param variables - variables to pass into the Viewer_CreatedIssuesQuery
     * @returns parsed response from Viewer_CreatedIssuesQuery
     */
    fetch(variables?: L.Viewer_CreatedIssuesQueryVariables): LinearFetch<IssueConnection>;
}
/**
 * A fetchable Viewer_TeamMemberships Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Viewer_TeamMembershipsQuery
 */
export declare class Viewer_TeamMembershipsQuery extends Request {
    private _variables?;
    constructor(request: LinearRequest, variables?: L.Viewer_TeamMembershipsQueryVariables);
    /**
     * Call the Viewer_TeamMemberships query and return a TeamMembershipConnection
     *
     * @param variables - variables to pass into the Viewer_TeamMembershipsQuery
     * @returns parsed response from Viewer_TeamMembershipsQuery
     */
    fetch(variables?: L.Viewer_TeamMembershipsQueryVariables): LinearFetch<TeamMembershipConnection>;
}
/**
 * A fetchable Viewer_Teams Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Viewer_TeamsQuery
 */
export declare class Viewer_TeamsQuery extends Request {
    private _variables?;
    constructor(request: LinearRequest, variables?: L.Viewer_TeamsQueryVariables);
    /**
     * Call the Viewer_Teams query and return a TeamConnection
     *
     * @param variables - variables to pass into the Viewer_TeamsQuery
     * @returns parsed response from Viewer_TeamsQuery
     */
    fetch(variables?: L.Viewer_TeamsQueryVariables): LinearFetch<TeamConnection>;
}
/**
 * A fetchable WorkflowState_Issues Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to workflowState
 * @param variables - variables without 'id' to pass into the WorkflowState_IssuesQuery
 */
export declare class WorkflowState_IssuesQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.WorkflowState_IssuesQueryVariables, "id">);
    /**
     * Call the WorkflowState_Issues query and return a IssueConnection
     *
     * @param variables - variables without 'id' to pass into the WorkflowState_IssuesQuery
     * @returns parsed response from WorkflowState_IssuesQuery
     */
    fetch(variables?: Omit<L.WorkflowState_IssuesQueryVariables, "id">): LinearFetch<IssueConnection>;
}
/**
 * The SDK class containing all root operations
 *
 * @param request - function to call the graphql client
 */
export declare class LinearSdk extends Request {
    constructor(request: LinearRequest);
    /**
     * All teams you the user can administrate. Administrable teams are teams whose settings the user can change, but to whose issues the user doesn't necessarily have access to.
     *
     * @param variables - variables to pass into the AdministrableTeamsQuery
     * @returns TeamConnection
     */
    administrableTeams(variables?: L.AdministrableTeamsQueryVariables): LinearFetch<TeamConnection>;
    /**
     * Get information for an application and whether a user has approved it for the given scopes.
     *
     * @param clientId - required clientId to pass to applicationWithAuthorization
     * @param scope - required scope to pass to applicationWithAuthorization
     * @param variables - variables without 'clientId', 'scope' to pass into the ApplicationWithAuthorizationQuery
     * @returns UserAuthorizedApplication
     */
    applicationWithAuthorization(clientId: string, scope: string[], variables?: Omit<L.ApplicationWithAuthorizationQueryVariables, "clientId" | "scope">): LinearFetch<UserAuthorizedApplication>;
    /**
     * [Alpha] One specific issue attachment.
     * [Deprecated] 'url' can no longer be used as the 'id' parameter. Use 'attachmentsForUrl' instead
     *
     * @param id - required id to pass to attachment
     * @returns Attachment
     */
    attachment(id: string): LinearFetch<Attachment>;
    /**
     * [Alpha] Query an issue by its associated attachment, and its id.
     *
     * @param id - required id to pass to attachmentIssue
     * @returns Issue
     */
    attachmentIssue(id: string): LinearFetch<Issue>;
    /**
     * [Alpha] All issue attachments.
     *
     * To get attachments for a given URL, use `attachmentsForURL` query.
     *
     * @param variables - variables to pass into the AttachmentsQuery
     * @returns AttachmentConnection
     */
    attachments(variables?: L.AttachmentsQueryVariables): LinearFetch<AttachmentConnection>;
    /**
     * [Alpha] Returns issue attachments for a given `url`.
     *
     * @param url - required url to pass to attachmentsForURL
     * @param variables - variables without 'url' to pass into the AttachmentsForUrlQuery
     * @returns AttachmentConnection
     */
    attachmentsForURL(url: string, variables?: Omit<L.AttachmentsForUrlQueryVariables, "url">): LinearFetch<AttachmentConnection>;
    /**
     * All audit log entries.
     *
     * @param variables - variables to pass into the AuditEntriesQuery
     * @returns AuditEntryConnection
     */
    auditEntries(variables?: L.AuditEntriesQueryVariables): LinearFetch<AuditEntryConnection>;
    /**
     * List of audit entry types.
     *
     * @returns AuditEntryType[]
     */
    get auditEntryTypes(): LinearFetch<AuditEntryType[]>;
    /**
     * Get all authorized applications for a user
     *
     * @returns AuthorizedApplication[]
     */
    get authorizedApplications(): LinearFetch<AuthorizedApplication[]>;
    /**
     * Fetch users belonging to this user account.
     *
     * @returns AuthResolverResponse
     */
    get availableUsers(): LinearFetch<AuthResolverResponse>;
    /**
     * Billing details for the customer.
     *
     * @returns BillingDetailsPayload
     */
    get billingDetails(): LinearFetch<BillingDetailsPayload>;
    /**
     * Join collaborative document and get missing steps.
     *
     * @param clientId - required clientId to pass to collaborativeDocumentJoin
     * @param issueId - required issueId to pass to collaborativeDocumentJoin
     * @param version - required version to pass to collaborativeDocumentJoin
     * @returns CollaborationDocumentUpdatePayload
     */
    collaborativeDocumentJoin(clientId: string, issueId: string, version: number): LinearFetch<CollaborationDocumentUpdatePayload>;
    /**
     * A specific comment.
     *
     * @param id - required id to pass to comment
     * @returns Comment
     */
    comment(id: string): LinearFetch<Comment>;
    /**
     * All comments.
     *
     * @param variables - variables to pass into the CommentsQuery
     * @returns CommentConnection
     */
    comments(variables?: L.CommentsQueryVariables): LinearFetch<CommentConnection>;
    /**
     * One specific custom view.
     *
     * @param id - required id to pass to customView
     * @returns CustomView
     */
    customView(id: string): LinearFetch<CustomView>;
    /**
     * Custom views for the user.
     *
     * @param variables - variables to pass into the CustomViewsQuery
     * @returns CustomViewConnection
     */
    customViews(variables?: L.CustomViewsQueryVariables): LinearFetch<CustomViewConnection>;
    /**
     * One specific cycle.
     *
     * @param id - required id to pass to cycle
     * @returns Cycle
     */
    cycle(id: string): LinearFetch<Cycle>;
    /**
     * All cycles.
     *
     * @param variables - variables to pass into the CyclesQuery
     * @returns CycleConnection
     */
    cycles(variables?: L.CyclesQueryVariables): LinearFetch<CycleConnection>;
    /**
     * One specific document.
     *
     * @param id - required id to pass to document
     * @returns Document
     */
    document(id: string): LinearFetch<Document>;
    /**
     * All documents for the project.
     *
     * @param variables - variables to pass into the DocumentsQuery
     * @returns DocumentConnection
     */
    documents(variables?: L.DocumentsQueryVariables): LinearFetch<DocumentConnection>;
    /**
     * A specific emoji.
     *
     * @param id - required id to pass to emoji
     * @returns Emoji
     */
    emoji(id: string): LinearFetch<Emoji>;
    /**
     * All custom emojis.
     *
     * @param variables - variables to pass into the EmojisQuery
     * @returns EmojiConnection
     */
    emojis(variables?: L.EmojisQueryVariables): LinearFetch<EmojiConnection>;
    /**
     * One specific favorite.
     *
     * @param id - required id to pass to favorite
     * @returns Favorite
     */
    favorite(id: string): LinearFetch<Favorite>;
    /**
     * The user's favorites.
     *
     * @param variables - variables to pass into the FavoritesQuery
     * @returns FavoriteConnection
     */
    favorites(variables?: L.FavoritesQueryVariables): LinearFetch<FavoriteConnection>;
    /**
     * Fetch Figma screenshot and other information with file and node identifiers.
     *
     * @param fileId - required fileId to pass to figmaEmbedInfo
     * @param variables - variables without 'fileId' to pass into the FigmaEmbedInfoQuery
     * @returns FigmaEmbedPayload
     */
    figmaEmbedInfo(fileId: string, variables?: Omit<L.FigmaEmbedInfoQueryVariables, "fileId">): LinearFetch<FigmaEmbedPayload>;
    /**
     * One specific integration.
     *
     * @param id - required id to pass to integration
     * @returns Integration
     */
    integration(id: string): LinearFetch<Integration>;
    /**
     * All integrations.
     *
     * @param variables - variables to pass into the IntegrationsQuery
     * @returns IntegrationConnection
     */
    integrations(variables?: L.IntegrationsQueryVariables): LinearFetch<IntegrationConnection>;
    /**
     * One specific issue.
     *
     * @param id - required id to pass to issue
     * @returns Issue
     */
    issue(id: string): LinearFetch<Issue>;
    /**
     * Fetches the GitHub token, completing the OAuth flow.
     *
     * @param code - required code to pass to issueImportFinishGithubOAuth
     * @returns GithubOAuthTokenPayload
     */
    issueImportFinishGithubOAuth(code: string): LinearFetch<GithubOAuthTokenPayload>;
    /**
     * One specific label.
     *
     * @param id - required id to pass to issueLabel
     * @returns IssueLabel
     */
    issueLabel(id: string): LinearFetch<IssueLabel>;
    /**
     * All issue labels.
     *
     * @param variables - variables to pass into the IssueLabelsQuery
     * @returns IssueLabelConnection
     */
    issueLabels(variables?: L.IssueLabelsQueryVariables): LinearFetch<IssueLabelConnection>;
    /**
     * Issue priority values and corresponding labels.
     *
     * @returns IssuePriorityValue[]
     */
    get issuePriorityValues(): LinearFetch<IssuePriorityValue[]>;
    /**
     * One specific issue relation.
     *
     * @param id - required id to pass to issueRelation
     * @returns IssueRelation
     */
    issueRelation(id: string): LinearFetch<IssueRelation>;
    /**
     * All issue relationships.
     *
     * @param variables - variables to pass into the IssueRelationsQuery
     * @returns IssueRelationConnection
     */
    issueRelations(variables?: L.IssueRelationsQueryVariables): LinearFetch<IssueRelationConnection>;
    /**
     * [ALPHA] Search issues. This query is experimental and is subject to change without notice.
     *
     * @param query - required query to pass to issueSearch
     * @param variables - variables without 'query' to pass into the IssueSearchQuery
     * @returns IssueConnection
     */
    issueSearch(query: string, variables?: Omit<L.IssueSearchQueryVariables, "query">): LinearFetch<IssueConnection>;
    /**
     * All issues.
     *
     * @param variables - variables to pass into the IssuesQuery
     * @returns IssueConnection
     */
    issues(variables?: L.IssuesQueryVariables): LinearFetch<IssueConnection>;
    /**
     * One specific milestone.
     *
     * @param id - required id to pass to milestone
     * @returns Milestone
     */
    milestone(id: string): LinearFetch<Milestone>;
    /**
     * All milestones.
     *
     * @param variables - variables to pass into the MilestonesQuery
     * @returns MilestoneConnection
     */
    milestones(variables?: L.MilestonesQueryVariables): LinearFetch<MilestoneConnection>;
    /**
     * One specific notification.
     *
     * @param id - required id to pass to notification
     * @returns Notification
     */
    notification(id: string): LinearFetch<Notification>;
    /**
     * One specific notification subscription.
     *
     * @param id - required id to pass to notificationSubscription
     * @returns NotificationSubscription
     */
    notificationSubscription(id: string): LinearFetch<NotificationSubscription>;
    /**
     * The user's notification subscriptions.
     *
     * @param variables - variables to pass into the NotificationSubscriptionsQuery
     * @returns NotificationSubscriptionConnection
     */
    notificationSubscriptions(variables?: L.NotificationSubscriptionsQueryVariables): LinearFetch<NotificationSubscriptionConnection>;
    /**
     * All notifications.
     *
     * @param variables - variables to pass into the NotificationsQuery
     * @returns NotificationConnection
     */
    notifications(variables?: L.NotificationsQueryVariables): LinearFetch<NotificationConnection>;
    /**
     * The user's organization.
     *
     * @returns Organization
     */
    get organization(): LinearFetch<Organization>;
    /**
     * Does the organization exist.
     *
     * @param urlKey - required urlKey to pass to organizationExists
     * @returns OrganizationExistsPayload
     */
    organizationExists(urlKey: string): LinearFetch<OrganizationExistsPayload>;
    /**
     * One specific organization invite.
     *
     * @param id - required id to pass to organizationInvite
     * @returns OrganizationInvite
     */
    organizationInvite(id: string): LinearFetch<OrganizationInvite>;
    /**
     * One specific organization invite.
     *
     * @param id - required id to pass to organizationInviteDetails
     * @returns OrganizationInviteDetailsPayload
     */
    organizationInviteDetails(id: string): LinearFetch<OrganizationInviteDetailsPayload>;
    /**
     * All invites for the organization.
     *
     * @param variables - variables to pass into the OrganizationInvitesQuery
     * @returns OrganizationInviteConnection
     */
    organizationInvites(variables?: L.OrganizationInvitesQueryVariables): LinearFetch<OrganizationInviteConnection>;
    /**
     * One specific project.
     *
     * @param id - required id to pass to project
     * @returns Project
     */
    project(id: string): LinearFetch<Project>;
    /**
     * One specific project link.
     *
     * @param id - required id to pass to projectLink
     * @returns ProjectLink
     */
    projectLink(id: string): LinearFetch<ProjectLink>;
    /**
     * All links for the project.
     *
     * @param variables - variables to pass into the ProjectLinksQuery
     * @returns ProjectLinkConnection
     */
    projectLinks(variables?: L.ProjectLinksQueryVariables): LinearFetch<ProjectLinkConnection>;
    /**
     * All projects.
     *
     * @param variables - variables to pass into the ProjectsQuery
     * @returns ProjectConnection
     */
    projects(variables?: L.ProjectsQueryVariables): LinearFetch<ProjectConnection>;
    /**
     * Sends a test push message.
     *
     * @returns PushSubscriptionTestPayload
     */
    get pushSubscriptionTest(): LinearFetch<PushSubscriptionTestPayload>;
    /**
     * A specific reaction.
     *
     * @param id - required id to pass to reaction
     * @returns Reaction
     */
    reaction(id: string): LinearFetch<Reaction>;
    /**
     * All comment emoji reactions.
     *
     * @param variables - variables to pass into the ReactionsQuery
     * @returns ReactionConnection
     */
    reactions(variables?: L.ReactionsQueryVariables): LinearFetch<ReactionConnection>;
    /**
     * Fetch SSO login URL for the email provided.
     *
     * @param email - required email to pass to ssoUrlFromEmail
     * @param variables - variables without 'email' to pass into the SsoUrlFromEmailQuery
     * @returns SsoUrlFromEmailResponse
     */
    ssoUrlFromEmail(email: string, variables?: Omit<L.SsoUrlFromEmailQueryVariables, "email">): LinearFetch<SsoUrlFromEmailResponse>;
    /**
     * The organization's subscription.
     *
     * @returns Subscription
     */
    get subscription(): LinearFetch<Subscription | undefined>;
    /**
     * One specific team.
     *
     * @param id - required id to pass to team
     * @returns Team
     */
    team(id: string): LinearFetch<Team>;
    /**
     * One specific team membership.
     *
     * @param id - required id to pass to teamMembership
     * @returns TeamMembership
     */
    teamMembership(id: string): LinearFetch<TeamMembership>;
    /**
     * All team memberships.
     *
     * @param variables - variables to pass into the TeamMembershipsQuery
     * @returns TeamMembershipConnection
     */
    teamMemberships(variables?: L.TeamMembershipsQueryVariables): LinearFetch<TeamMembershipConnection>;
    /**
     * All teams whose issues can be accessed by the user. This might be different from `administrableTeams`, which also includes teams whose settings can be changed by the user.
     *
     * @param variables - variables to pass into the TeamsQuery
     * @returns TeamConnection
     */
    teams(variables?: L.TeamsQueryVariables): LinearFetch<TeamConnection>;
    /**
     * A specific template.
     *
     * @param id - required id to pass to template
     * @returns Template
     */
    template(id: string): LinearFetch<Template>;
    /**
     * All templates from all users.
     *
     * @returns Template[]
     */
    get templates(): LinearFetch<Template[]>;
    /**
     * One specific user.
     *
     * @param id - required id to pass to user
     * @returns User
     */
    user(id: string): LinearFetch<User>;
    /**
     * The user's settings.
     *
     * @returns UserSettings
     */
    get userSettings(): LinearFetch<UserSettings>;
    /**
     * All users for the organization.
     *
     * @param variables - variables to pass into the UsersQuery
     * @returns UserConnection
     */
    users(variables?: L.UsersQueryVariables): LinearFetch<UserConnection>;
    /**
     * The currently authenticated user.
     *
     * @returns User
     */
    get viewer(): LinearFetch<User>;
    /**
     * A specific webhook.
     *
     * @param id - required id to pass to webhook
     * @returns Webhook
     */
    webhook(id: string): LinearFetch<Webhook>;
    /**
     * All webhooks.
     *
     * @param variables - variables to pass into the WebhooksQuery
     * @returns WebhookConnection
     */
    webhooks(variables?: L.WebhooksQueryVariables): LinearFetch<WebhookConnection>;
    /**
     * One specific state.
     *
     * @param id - required id to pass to workflowState
     * @returns WorkflowState
     */
    workflowState(id: string): LinearFetch<WorkflowState>;
    /**
     * All issue workflow states.
     *
     * @param variables - variables to pass into the WorkflowStatesQuery
     * @returns WorkflowStateConnection
     */
    workflowStates(variables?: L.WorkflowStatesQueryVariables): LinearFetch<WorkflowStateConnection>;
    /**
     * [DEPRECATED] Archives an issue attachment.
     *
     * @param id - required id to pass to attachmentArchive
     * @returns ArchivePayload
     */
    attachmentArchive(id: string): LinearFetch<ArchivePayload>;
    /**
     * [Alpha] Creates a new attachment, or updates existing if the same `url` and `issueId` is used.
     *
     * @param input - required input to pass to attachmentCreate
     * @returns AttachmentPayload
     */
    attachmentCreate(input: L.AttachmentCreateInput): LinearFetch<AttachmentPayload>;
    /**
     * [Alpha] Deletes an issue attachment.
     *
     * @param id - required id to pass to attachmentDelete
     * @returns ArchivePayload
     */
    attachmentDelete(id: string): LinearFetch<ArchivePayload>;
    /**
     * Link an existing Front conversation to an issue.
     *
     * @param conversationId - required conversationId to pass to attachmentLinkFront
     * @param issueId - required issueId to pass to attachmentLinkFront
     * @returns FrontAttachmentPayload
     */
    attachmentLinkFront(conversationId: string, issueId: string): LinearFetch<FrontAttachmentPayload>;
    /**
     * Link an existing Intercom conversation to an issue.
     *
     * @param conversationId - required conversationId to pass to attachmentLinkIntercom
     * @param issueId - required issueId to pass to attachmentLinkIntercom
     * @returns AttachmentPayload
     */
    attachmentLinkIntercom(conversationId: string, issueId: string): LinearFetch<AttachmentPayload>;
    /**
     * Link an existing Jira issue to an issue.
     *
     * @param issueId - required issueId to pass to attachmentLinkJiraIssue
     * @param jiraIssueId - required jiraIssueId to pass to attachmentLinkJiraIssue
     * @returns AttachmentPayload
     */
    attachmentLinkJiraIssue(issueId: string, jiraIssueId: string): LinearFetch<AttachmentPayload>;
    /**
     * Link any url to an issue.
     *
     * @param issueId - required issueId to pass to attachmentLinkURL
     * @param url - required url to pass to attachmentLinkURL
     * @param variables - variables without 'issueId', 'url' to pass into the AttachmentLinkUrlMutation
     * @returns AttachmentPayload
     */
    attachmentLinkURL(issueId: string, url: string, variables?: Omit<L.AttachmentLinkUrlMutationVariables, "issueId" | "url">): LinearFetch<AttachmentPayload>;
    /**
     * Link an existing Zendesk ticket to an issue.
     *
     * @param issueId - required issueId to pass to attachmentLinkZendesk
     * @param ticketId - required ticketId to pass to attachmentLinkZendesk
     * @returns AttachmentPayload
     */
    attachmentLinkZendesk(issueId: string, ticketId: string): LinearFetch<AttachmentPayload>;
    /**
     * [Alpha] Updates an existing issue attachment.
     *
     * @param id - required id to pass to attachmentUpdate
     * @param input - required input to pass to attachmentUpdate
     * @returns AttachmentPayload
     */
    attachmentUpdate(id: string, input: L.AttachmentUpdateInput): LinearFetch<AttachmentPayload>;
    /**
     * Updates the billing email address for the customer.
     *
     * @param input - required input to pass to billingEmailUpdate
     * @returns BillingEmailPayload
     */
    billingEmailUpdate(input: L.BillingEmailUpdateInput): LinearFetch<BillingEmailPayload>;
    /**
     * Update collaborative document with client steps.
     *
     * @param input - required input to pass to collaborativeDocumentUpdate
     * @returns CollaborationDocumentUpdatePayload
     */
    collaborativeDocumentUpdate(input: L.CollaborationDocumentUpdateInput): LinearFetch<CollaborationDocumentUpdatePayload>;
    /**
     * Creates a new comment.
     *
     * @param input - required input to pass to commentCreate
     * @returns CommentPayload
     */
    commentCreate(input: L.CommentCreateInput): LinearFetch<CommentPayload>;
    /**
     * Deletes a comment.
     *
     * @param id - required id to pass to commentDelete
     * @returns ArchivePayload
     */
    commentDelete(id: string): LinearFetch<ArchivePayload>;
    /**
     * Updates a comment.
     *
     * @param id - required id to pass to commentUpdate
     * @param input - required input to pass to commentUpdate
     * @returns CommentPayload
     */
    commentUpdate(id: string, input: L.CommentUpdateInput): LinearFetch<CommentPayload>;
    /**
     * Saves user message.
     *
     * @param input - required input to pass to contactCreate
     * @returns ContactPayload
     */
    contactCreate(input: L.ContactCreateInput): LinearFetch<ContactPayload>;
    /**
     * Create CSV export report for the organization.
     *
     * @param variables - variables to pass into the CreateCsvExportReportMutation
     * @returns CreateCsvExportReportPayload
     */
    createCsvExportReport(variables?: L.CreateCsvExportReportMutationVariables): LinearFetch<CreateCsvExportReportPayload>;
    /**
     * Creates an organization from onboarding.
     *
     * @param input - required input to pass to createOrganizationFromOnboarding
     * @param variables - variables without 'input' to pass into the CreateOrganizationFromOnboardingMutation
     * @returns CreateOrJoinOrganizationResponse
     */
    createOrganizationFromOnboarding(input: L.CreateOrganizationInput, variables?: Omit<L.CreateOrganizationFromOnboardingMutationVariables, "input">): LinearFetch<CreateOrJoinOrganizationResponse>;
    /**
     * Creates a new custom view.
     *
     * @param input - required input to pass to customViewCreate
     * @returns CustomViewPayload
     */
    customViewCreate(input: L.CustomViewCreateInput): LinearFetch<CustomViewPayload>;
    /**
     * Deletes a custom view.
     *
     * @param id - required id to pass to customViewDelete
     * @returns ArchivePayload
     */
    customViewDelete(id: string): LinearFetch<ArchivePayload>;
    /**
     * Updates a custom view.
     *
     * @param id - required id to pass to customViewUpdate
     * @param input - required input to pass to customViewUpdate
     * @returns CustomViewPayload
     */
    customViewUpdate(id: string, input: L.CustomViewUpdateInput): LinearFetch<CustomViewPayload>;
    /**
     * Archives a cycle.
     *
     * @param id - required id to pass to cycleArchive
     * @returns ArchivePayload
     */
    cycleArchive(id: string): LinearFetch<ArchivePayload>;
    /**
     * Creates a new cycle.
     *
     * @param input - required input to pass to cycleCreate
     * @returns CyclePayload
     */
    cycleCreate(input: L.CycleCreateInput): LinearFetch<CyclePayload>;
    /**
     * Updates a cycle.
     *
     * @param id - required id to pass to cycleUpdate
     * @param input - required input to pass to cycleUpdate
     * @returns CyclePayload
     */
    cycleUpdate(id: string, input: L.CycleUpdateInput): LinearFetch<CyclePayload>;
    /**
     * Always fails with internal error. Used to debug logging.
     *
     * @returns DebugPayload
     */
    get debugFailWithInternalError(): LinearFetch<DebugPayload>;
    /**
     * Creates a new document.
     *
     * @param input - required input to pass to documentCreate
     * @returns DocumentPayload
     */
    documentCreate(input: L.DocumentCreateInput): LinearFetch<DocumentPayload>;
    /**
     * Deletes a document.
     *
     * @param id - required id to pass to documentDelete
     * @returns ArchivePayload
     */
    documentDelete(id: string): LinearFetch<ArchivePayload>;
    /**
     * Updates a document.
     *
     * @param id - required id to pass to documentUpdate
     * @param input - required input to pass to documentUpdate
     * @returns DocumentPayload
     */
    documentUpdate(id: string, input: L.DocumentUpdateInput): LinearFetch<DocumentPayload>;
    /**
     * Subscribes the email to the newsletter.
     *
     * @param input - required input to pass to emailSubscribe
     * @returns EmailSubscribePayload
     */
    emailSubscribe(input: L.EmailSubscribeInput): LinearFetch<EmailSubscribePayload>;
    /**
     * Authenticates a user account via email and authentication token.
     *
     * @param input - required input to pass to emailTokenUserAccountAuth
     * @returns AuthResolverResponse
     */
    emailTokenUserAccountAuth(input: L.TokenUserAccountAuthInput): LinearFetch<AuthResolverResponse>;
    /**
     * Unsubscribes the user from one type of emails.
     *
     * @param input - required input to pass to emailUnsubscribe
     * @returns EmailUnsubscribePayload
     */
    emailUnsubscribe(input: L.EmailUnsubscribeInput): LinearFetch<EmailUnsubscribePayload>;
    /**
     * Finds or creates a new user account by email and sends an email with token.
     *
     * @param input - required input to pass to emailUserAccountAuthChallenge
     * @returns EmailUserAccountAuthChallengeResponse
     */
    emailUserAccountAuthChallenge(input: L.EmailUserAccountAuthChallengeInput): LinearFetch<EmailUserAccountAuthChallengeResponse>;
    /**
     * Creates a custom emoji.
     *
     * @param input - required input to pass to emojiCreate
     * @returns EmojiPayload
     */
    emojiCreate(input: L.EmojiCreateInput): LinearFetch<EmojiPayload>;
    /**
     * Deletes an emoji.
     *
     * @param id - required id to pass to emojiDelete
     * @returns ArchivePayload
     */
    emojiDelete(id: string): LinearFetch<ArchivePayload>;
    /**
     * [Deprecated] Creates a new event.
     *
     * @param input - required input to pass to eventCreate
     * @returns EventPayload
     */
    eventCreate(input: L.EventCreateInput): LinearFetch<EventPayload>;
    /**
     * Creates a new favorite (project, cycle etc).
     *
     * @param input - required input to pass to favoriteCreate
     * @returns FavoritePayload
     */
    favoriteCreate(input: L.FavoriteCreateInput): LinearFetch<FavoritePayload>;
    /**
     * Deletes a favorite reference.
     *
     * @param id - required id to pass to favoriteDelete
     * @returns ArchivePayload
     */
    favoriteDelete(id: string): LinearFetch<ArchivePayload>;
    /**
     * Updates a favorite.
     *
     * @param id - required id to pass to favoriteUpdate
     * @param input - required input to pass to favoriteUpdate
     * @returns FavoritePayload
     */
    favoriteUpdate(id: string, input: L.FavoriteUpdateInput): LinearFetch<FavoritePayload>;
    /**
     * Saves user feedback.
     *
     * @param input - required input to pass to feedbackCreate
     * @returns FeedbackPayload
     */
    feedbackCreate(input: L.FeedbackCreateInput): LinearFetch<FeedbackPayload>;
    /**
     * XHR request payload to upload an images, video and other attachments directly to Linear's cloud storage.
     *
     * @param contentType - required contentType to pass to fileUpload
     * @param filename - required filename to pass to fileUpload
     * @param size - required size to pass to fileUpload
     * @param variables - variables without 'contentType', 'filename', 'size' to pass into the FileUploadMutation
     * @returns UploadPayload
     */
    fileUpload(contentType: string, filename: string, size: number, variables?: Omit<L.FileUploadMutationVariables, "contentType" | "filename" | "size">): LinearFetch<UploadPayload>;
    /**
     * Authenticate user account through Google OAuth. This is the 2nd step of OAuth flow.
     *
     * @param input - required input to pass to googleUserAccountAuth
     * @returns AuthResolverResponse
     */
    googleUserAccountAuth(input: L.GoogleUserAccountAuthInput): LinearFetch<AuthResolverResponse>;
    /**
     * Upload an image from an URL to Linear.
     *
     * @param url - required url to pass to imageUploadFromUrl
     * @returns ImageUploadFromUrlPayload
     */
    imageUploadFromUrl(url: string): LinearFetch<ImageUploadFromUrlPayload>;
    /**
     * Deletes an integration.
     *
     * @param id - required id to pass to integrationDelete
     * @returns ArchivePayload
     */
    integrationDelete(id: string): LinearFetch<ArchivePayload>;
    /**
     * Integrates the organization with Figma.
     *
     * @param code - required code to pass to integrationFigma
     * @param redirectUri - required redirectUri to pass to integrationFigma
     * @returns IntegrationPayload
     */
    integrationFigma(code: string, redirectUri: string): LinearFetch<IntegrationPayload>;
    /**
     * Integrates the organization with Front.
     *
     * @param code - required code to pass to integrationFront
     * @param redirectUri - required redirectUri to pass to integrationFront
     * @returns IntegrationPayload
     */
    integrationFront(code: string, redirectUri: string): LinearFetch<IntegrationPayload>;
    /**
     * Generates a webhook for the GitHub commit integration.
     *
     * @returns GitHubCommitIntegrationPayload
     */
    get integrationGithubCommitCreate(): LinearFetch<GitHubCommitIntegrationPayload>;
    /**
     * Connects the organization with the GitHub App.
     *
     * @param installationId - required installationId to pass to integrationGithubConnect
     * @returns IntegrationPayload
     */
    integrationGithubConnect(installationId: string): LinearFetch<IntegrationPayload>;
    /**
     * Connects the organization with a GitLab Access Token.
     *
     * @param accessToken - required accessToken to pass to integrationGitlabConnect
     * @param gitlabUrl - required gitlabUrl to pass to integrationGitlabConnect
     * @returns IntegrationPayload
     */
    integrationGitlabConnect(accessToken: string, gitlabUrl: string): LinearFetch<IntegrationPayload>;
    /**
     * Integrates the organization with Google Sheets.
     *
     * @param code - required code to pass to integrationGoogleSheets
     * @returns IntegrationPayload
     */
    integrationGoogleSheets(code: string): LinearFetch<IntegrationPayload>;
    /**
     * Integrates the organization with Intercom.
     *
     * @param code - required code to pass to integrationIntercom
     * @param redirectUri - required redirectUri to pass to integrationIntercom
     * @returns IntegrationPayload
     */
    integrationIntercom(code: string, redirectUri: string): LinearFetch<IntegrationPayload>;
    /**
     * Disconnects the organization from Intercom.
     *
     * @returns IntegrationPayload
     */
    get integrationIntercomDelete(): LinearFetch<IntegrationPayload>;
    /**
     * [DEPRECATED] Updates settings on the Intercom integration.
     *
     * @param input - required input to pass to integrationIntercomSettingsUpdate
     * @returns IntegrationPayload
     */
    integrationIntercomSettingsUpdate(input: L.IntercomSettingsInput): LinearFetch<IntegrationPayload>;
    /**
     * Enables Loom integration for the organization.
     *
     * @returns IntegrationPayload
     */
    get integrationLoom(): LinearFetch<IntegrationPayload>;
    /**
     * Archives an integration resource.
     *
     * @param id - required id to pass to integrationResourceArchive
     * @returns ArchivePayload
     */
    integrationResourceArchive(id: string): LinearFetch<ArchivePayload>;
    /**
     * Integrates the organization with Sentry.
     *
     * @param code - required code to pass to integrationSentryConnect
     * @param installationId - required installationId to pass to integrationSentryConnect
     * @param organizationSlug - required organizationSlug to pass to integrationSentryConnect
     * @returns IntegrationPayload
     */
    integrationSentryConnect(code: string, installationId: string, organizationSlug: string): LinearFetch<IntegrationPayload>;
    /**
     * [INTERNAL] Updates the integration.
     *
     * @param id - required id to pass to integrationSettingsUpdate
     * @param input - required input to pass to integrationSettingsUpdate
     * @returns IntegrationPayload
     */
    integrationSettingsUpdate(id: string, input: L.IntegrationSettingsInput): LinearFetch<IntegrationPayload>;
    /**
     * Integrates the organization with Slack.
     *
     * @param code - required code to pass to integrationSlack
     * @param redirectUri - required redirectUri to pass to integrationSlack
     * @param variables - variables without 'code', 'redirectUri' to pass into the IntegrationSlackMutation
     * @returns IntegrationPayload
     */
    integrationSlack(code: string, redirectUri: string, variables?: Omit<L.IntegrationSlackMutationVariables, "code" | "redirectUri">): LinearFetch<IntegrationPayload>;
    /**
     * Imports custom emojis from your Slack workspace.
     *
     * @param code - required code to pass to integrationSlackImportEmojis
     * @param redirectUri - required redirectUri to pass to integrationSlackImportEmojis
     * @returns IntegrationPayload
     */
    integrationSlackImportEmojis(code: string, redirectUri: string): LinearFetch<IntegrationPayload>;
    /**
     * Integrates your personal notifications with Slack.
     *
     * @param code - required code to pass to integrationSlackPersonal
     * @param redirectUri - required redirectUri to pass to integrationSlackPersonal
     * @returns IntegrationPayload
     */
    integrationSlackPersonal(code: string, redirectUri: string): LinearFetch<IntegrationPayload>;
    /**
     * Slack webhook integration.
     *
     * @param code - required code to pass to integrationSlackPost
     * @param redirectUri - required redirectUri to pass to integrationSlackPost
     * @param teamId - required teamId to pass to integrationSlackPost
     * @param variables - variables without 'code', 'redirectUri', 'teamId' to pass into the IntegrationSlackPostMutation
     * @returns IntegrationPayload
     */
    integrationSlackPost(code: string, redirectUri: string, teamId: string, variables?: Omit<L.IntegrationSlackPostMutationVariables, "code" | "redirectUri" | "teamId">): LinearFetch<IntegrationPayload>;
    /**
     * Slack integration for project notifications.
     *
     * @param code - required code to pass to integrationSlackProjectPost
     * @param projectId - required projectId to pass to integrationSlackProjectPost
     * @param redirectUri - required redirectUri to pass to integrationSlackProjectPost
     * @returns IntegrationPayload
     */
    integrationSlackProjectPost(code: string, projectId: string, redirectUri: string): LinearFetch<IntegrationPayload>;
    /**
     * Integrates the organization with Zendesk.
     *
     * @param code - required code to pass to integrationZendesk
     * @param redirectUri - required redirectUri to pass to integrationZendesk
     * @param scope - required scope to pass to integrationZendesk
     * @param subdomain - required subdomain to pass to integrationZendesk
     * @returns IntegrationPayload
     */
    integrationZendesk(code: string, redirectUri: string, scope: string, subdomain: string): LinearFetch<IntegrationPayload>;
    /**
     * Archives an issue.
     *
     * @param id - required id to pass to issueArchive
     * @param variables - variables without 'id' to pass into the IssueArchiveMutation
     * @returns ArchivePayload
     */
    issueArchive(id: string, variables?: Omit<L.IssueArchiveMutationVariables, "id">): LinearFetch<ArchivePayload>;
    /**
     * Updates multiple issues at once.
     *
     * @param ids - required ids to pass to issueBatchUpdate
     * @param input - required input to pass to issueBatchUpdate
     * @returns IssueBatchPayload
     */
    issueBatchUpdate(ids: L.Scalars["UUID"][], input: L.IssueUpdateInput): LinearFetch<IssueBatchPayload>;
    /**
     * Creates a new issue.
     *
     * @param input - required input to pass to issueCreate
     * @returns IssuePayload
     */
    issueCreate(input: L.IssueCreateInput): LinearFetch<IssuePayload>;
    /**
     * Deletes (trashes) an issue.
     *
     * @param id - required id to pass to issueDelete
     * @returns ArchivePayload
     */
    issueDelete(id: string): LinearFetch<ArchivePayload>;
    /**
     * Kicks off an Asana import job.
     *
     * @param asanaTeamName - required asanaTeamName to pass to issueImportCreateAsana
     * @param asanaToken - required asanaToken to pass to issueImportCreateAsana
     * @param teamId - required teamId to pass to issueImportCreateAsana
     * @param variables - variables without 'asanaTeamName', 'asanaToken', 'teamId' to pass into the IssueImportCreateAsanaMutation
     * @returns IssueImportPayload
     */
    issueImportCreateAsana(asanaTeamName: string, asanaToken: string, teamId: string, variables?: Omit<L.IssueImportCreateAsanaMutationVariables, "asanaTeamName" | "asanaToken" | "teamId">): LinearFetch<IssueImportPayload>;
    /**
     * Kicks off a Clubhouse import job.
     *
     * @param clubhouseTeamName - required clubhouseTeamName to pass to issueImportCreateClubhouse
     * @param clubhouseToken - required clubhouseToken to pass to issueImportCreateClubhouse
     * @param teamId - required teamId to pass to issueImportCreateClubhouse
     * @param variables - variables without 'clubhouseTeamName', 'clubhouseToken', 'teamId' to pass into the IssueImportCreateClubhouseMutation
     * @returns IssueImportPayload
     */
    issueImportCreateClubhouse(clubhouseTeamName: string, clubhouseToken: string, teamId: string, variables?: Omit<L.IssueImportCreateClubhouseMutationVariables, "clubhouseTeamName" | "clubhouseToken" | "teamId">): LinearFetch<IssueImportPayload>;
    /**
     * Kicks off a GitHub import job.
     *
     * @param githubRepoName - required githubRepoName to pass to issueImportCreateGithub
     * @param githubRepoOwner - required githubRepoOwner to pass to issueImportCreateGithub
     * @param githubToken - required githubToken to pass to issueImportCreateGithub
     * @param teamId - required teamId to pass to issueImportCreateGithub
     * @param variables - variables without 'githubRepoName', 'githubRepoOwner', 'githubToken', 'teamId' to pass into the IssueImportCreateGithubMutation
     * @returns IssueImportPayload
     */
    issueImportCreateGithub(githubRepoName: string, githubRepoOwner: string, githubToken: string, teamId: string, variables?: Omit<L.IssueImportCreateGithubMutationVariables, "githubRepoName" | "githubRepoOwner" | "githubToken" | "teamId">): LinearFetch<IssueImportPayload>;
    /**
     * Kicks off a Jira import job.
     *
     * @param jiraEmail - required jiraEmail to pass to issueImportCreateJira
     * @param jiraHostname - required jiraHostname to pass to issueImportCreateJira
     * @param jiraProject - required jiraProject to pass to issueImportCreateJira
     * @param jiraToken - required jiraToken to pass to issueImportCreateJira
     * @param teamId - required teamId to pass to issueImportCreateJira
     * @param variables - variables without 'jiraEmail', 'jiraHostname', 'jiraProject', 'jiraToken', 'teamId' to pass into the IssueImportCreateJiraMutation
     * @returns IssueImportPayload
     */
    issueImportCreateJira(jiraEmail: string, jiraHostname: string, jiraProject: string, jiraToken: string, teamId: string, variables?: Omit<L.IssueImportCreateJiraMutationVariables, "jiraEmail" | "jiraHostname" | "jiraProject" | "jiraToken" | "teamId">): LinearFetch<IssueImportPayload>;
    /**
     * Deletes an import job.
     *
     * @param issueImportId - required issueImportId to pass to issueImportDelete
     * @returns IssueImportDeletePayload
     */
    issueImportDelete(issueImportId: string): LinearFetch<IssueImportDeletePayload>;
    /**
     * Kicks off import processing.
     *
     * @param issueImportId - required issueImportId to pass to issueImportProcess
     * @param mapping - required mapping to pass to issueImportProcess
     * @returns IssueImportPayload
     */
    issueImportProcess(issueImportId: string, mapping: Record<string, unknown>): LinearFetch<IssueImportPayload>;
    /**
     * Updates the mapping for the issue import.
     *
     * @param id - required id to pass to issueImportUpdate
     * @param input - required input to pass to issueImportUpdate
     * @returns IssueImportPayload
     */
    issueImportUpdate(id: string, input: L.IssueImportUpdateInput): LinearFetch<IssueImportPayload>;
    /**
     * Archives an issue label.
     *
     * @param id - required id to pass to issueLabelArchive
     * @returns ArchivePayload
     */
    issueLabelArchive(id: string): LinearFetch<ArchivePayload>;
    /**
     * Creates a new label.
     *
     * @param input - required input to pass to issueLabelCreate
     * @param variables - variables without 'input' to pass into the IssueLabelCreateMutation
     * @returns IssueLabelPayload
     */
    issueLabelCreate(input: L.IssueLabelCreateInput, variables?: Omit<L.IssueLabelCreateMutationVariables, "input">): LinearFetch<IssueLabelPayload>;
    /**
     * Updates an label.
     *
     * @param id - required id to pass to issueLabelUpdate
     * @param input - required input to pass to issueLabelUpdate
     * @returns IssueLabelPayload
     */
    issueLabelUpdate(id: string, input: L.IssueLabelUpdateInput): LinearFetch<IssueLabelPayload>;
    /**
     * Creates a new issue relation.
     *
     * @param input - required input to pass to issueRelationCreate
     * @returns IssueRelationPayload
     */
    issueRelationCreate(input: L.IssueRelationCreateInput): LinearFetch<IssueRelationPayload>;
    /**
     * Deletes an issue relation.
     *
     * @param id - required id to pass to issueRelationDelete
     * @returns ArchivePayload
     */
    issueRelationDelete(id: string): LinearFetch<ArchivePayload>;
    /**
     * Updates an issue relation.
     *
     * @param id - required id to pass to issueRelationUpdate
     * @param input - required input to pass to issueRelationUpdate
     * @returns IssueRelationPayload
     */
    issueRelationUpdate(id: string, input: L.IssueRelationUpdateInput): LinearFetch<IssueRelationPayload>;
    /**
     * Unarchives an issue.
     *
     * @param id - required id to pass to issueUnarchive
     * @returns ArchivePayload
     */
    issueUnarchive(id: string): LinearFetch<ArchivePayload>;
    /**
     * Updates an issue.
     *
     * @param id - required id to pass to issueUpdate
     * @param input - required input to pass to issueUpdate
     * @returns IssuePayload
     */
    issueUpdate(id: string, input: L.IssueUpdateInput): LinearFetch<IssuePayload>;
    /**
     * [INTERNAL] Connects the organization with a Jira Personal Access Token.
     *
     * @param input - required input to pass to jiraIntegrationConnect
     * @returns IntegrationPayload
     */
    jiraIntegrationConnect(input: L.JiraConfigurationInput): LinearFetch<IntegrationPayload>;
    /**
     * Join an organization from onboarding.
     *
     * @param input - required input to pass to joinOrganizationFromOnboarding
     * @returns CreateOrJoinOrganizationResponse
     */
    joinOrganizationFromOnboarding(input: L.JoinOrganizationInput): LinearFetch<CreateOrJoinOrganizationResponse>;
    /**
     * Leave an organization.
     *
     * @param organizationId - required organizationId to pass to leaveOrganization
     * @returns CreateOrJoinOrganizationResponse
     */
    leaveOrganization(organizationId: string): LinearFetch<CreateOrJoinOrganizationResponse>;
    /**
     * Creates a new milestone.
     *
     * @param input - required input to pass to milestoneCreate
     * @returns MilestonePayload
     */
    milestoneCreate(input: L.MilestoneCreateInput): LinearFetch<MilestonePayload>;
    /**
     * Deletes a milestone.
     *
     * @param id - required id to pass to milestoneDelete
     * @returns ArchivePayload
     */
    milestoneDelete(id: string): LinearFetch<ArchivePayload>;
    /**
     * Updates a milestone.
     *
     * @param id - required id to pass to milestoneUpdate
     * @param input - required input to pass to milestoneUpdate
     * @returns MilestonePayload
     */
    milestoneUpdate(id: string, input: L.MilestoneUpdateInput): LinearFetch<MilestonePayload>;
    /**
     * Archives a notification.
     *
     * @param id - required id to pass to notificationArchive
     * @returns ArchivePayload
     */
    notificationArchive(id: string): LinearFetch<ArchivePayload>;
    /**
     * Creates a notification.
     *
     * @param id - required id to pass to notificationCreate
     * @param input - required input to pass to notificationCreate
     * @returns NotificationPayload
     */
    notificationCreate(id: string, input: L.NotificationUpdateInput): LinearFetch<NotificationPayload>;
    /**
     * Creates a new notification subscription for a team or a project.
     *
     * @param input - required input to pass to notificationSubscriptionCreate
     * @returns NotificationSubscriptionPayload
     */
    notificationSubscriptionCreate(input: L.NotificationSubscriptionCreateInput): LinearFetch<NotificationSubscriptionPayload>;
    /**
     * Deletes a notification subscription reference.
     *
     * @param id - required id to pass to notificationSubscriptionDelete
     * @returns ArchivePayload
     */
    notificationSubscriptionDelete(id: string): LinearFetch<ArchivePayload>;
    /**
     * Unarchives a notification.
     *
     * @param id - required id to pass to notificationUnarchive
     * @returns ArchivePayload
     */
    notificationUnarchive(id: string): LinearFetch<ArchivePayload>;
    /**
     * Updates a notification.
     *
     * @param id - required id to pass to notificationUpdate
     * @param input - required input to pass to notificationUpdate
     * @returns NotificationPayload
     */
    notificationUpdate(id: string, input: L.NotificationUpdateInput): LinearFetch<NotificationPayload>;
    /**
     * Archives an OAuth client.
     *
     * @param id - required id to pass to oauthClientArchive
     * @returns ArchivePayload
     */
    oauthClientArchive(id: string): LinearFetch<ArchivePayload>;
    /**
     * Creates a new OAuth client.
     *
     * @param input - required input to pass to oauthClientCreate
     * @returns OauthClientPayload
     */
    oauthClientCreate(input: L.OauthClientCreateInput): LinearFetch<OauthClientPayload>;
    /**
     * Updates an OAuth client.
     *
     * @param id - required id to pass to oauthClientRotateSecret
     * @returns RotateSecretPayload
     */
    oauthClientRotateSecret(id: string): LinearFetch<RotateSecretPayload>;
    /**
     * Updates an OAuth client.
     *
     * @param id - required id to pass to oauthClientUpdate
     * @param input - required input to pass to oauthClientUpdate
     * @returns OauthClientPayload
     */
    oauthClientUpdate(id: string, input: L.OauthClientUpdateInput): LinearFetch<OauthClientPayload>;
    /**
     * Revokes an OAuth token.
     *
     * @param appId - required appId to pass to oauthTokenRevoke
     * @param scope - required scope to pass to oauthTokenRevoke
     * @returns OauthTokenRevokePayload
     */
    oauthTokenRevoke(appId: string, scope: string[]): LinearFetch<OauthTokenRevokePayload>;
    /**
     * Cancels the deletion of an organization. Administrator privileges required.
     *
     * @returns OrganizationCancelDeletePayload
     */
    get organizationCancelDelete(): LinearFetch<OrganizationCancelDeletePayload>;
    /**
     * Delete's an organization. Administrator privileges required.
     *
     * @param input - required input to pass to organizationDelete
     * @returns OrganizationDeletePayload
     */
    organizationDelete(input: L.DeleteOrganizationInput): LinearFetch<OrganizationDeletePayload>;
    /**
     * Get an organization's delete confirmation token. Administrator privileges required.
     *
     * @returns OrganizationDeletePayload
     */
    get organizationDeleteChallenge(): LinearFetch<OrganizationDeletePayload>;
    /**
     * Adds a domain to be allowed for an organization.
     *
     * @param input - required input to pass to organizationDomainCreate
     * @returns OrganizationDomainPayload
     */
    organizationDomainCreate(input: L.OrganizationDomainCreateInput): LinearFetch<OrganizationDomainPayload>;
    /**
     * Deletes a domain.
     *
     * @param id - required id to pass to organizationDomainDelete
     * @returns ArchivePayload
     */
    organizationDomainDelete(id: string): LinearFetch<ArchivePayload>;
    /**
     * Verifies a domain to be added to an organization.
     *
     * @param input - required input to pass to organizationDomainVerify
     * @returns OrganizationDomainPayload
     */
    organizationDomainVerify(input: L.OrganizationDomainVerificationInput): LinearFetch<OrganizationDomainPayload>;
    /**
     * Creates a new organization invite.
     *
     * @param input - required input to pass to organizationInviteCreate
     * @returns OrganizationInvitePayload
     */
    organizationInviteCreate(input: L.OrganizationInviteCreateInput): LinearFetch<OrganizationInvitePayload>;
    /**
     * Deletes an organization invite.
     *
     * @param id - required id to pass to organizationInviteDelete
     * @returns ArchivePayload
     */
    organizationInviteDelete(id: string): LinearFetch<ArchivePayload>;
    /**
     * Updates the user's organization.
     *
     * @param input - required input to pass to organizationUpdate
     * @returns OrganizationPayload
     */
    organizationUpdate(input: L.UpdateOrganizationInput): LinearFetch<OrganizationPayload>;
    /**
     * Archives a project.
     *
     * @param id - required id to pass to projectArchive
     * @returns ArchivePayload
     */
    projectArchive(id: string): LinearFetch<ArchivePayload>;
    /**
     * Creates a new project.
     *
     * @param input - required input to pass to projectCreate
     * @returns ProjectPayload
     */
    projectCreate(input: L.ProjectCreateInput): LinearFetch<ProjectPayload>;
    /**
     * Creates a new project link.
     *
     * @param input - required input to pass to projectLinkCreate
     * @returns ProjectLinkPayload
     */
    projectLinkCreate(input: L.ProjectLinkCreateInput): LinearFetch<ProjectLinkPayload>;
    /**
     * Deletes a project link.
     *
     * @param id - required id to pass to projectLinkDelete
     * @returns ArchivePayload
     */
    projectLinkDelete(id: string): LinearFetch<ArchivePayload>;
    /**
     * Updates a project link.
     *
     * @param id - required id to pass to projectLinkUpdate
     * @param input - required input to pass to projectLinkUpdate
     * @returns ProjectLinkPayload
     */
    projectLinkUpdate(id: string, input: L.ProjectLinkUpdateInput): LinearFetch<ProjectLinkPayload>;
    /**
     * Unarchives a project.
     *
     * @param id - required id to pass to projectUnarchive
     * @returns ArchivePayload
     */
    projectUnarchive(id: string): LinearFetch<ArchivePayload>;
    /**
     * Updates a project.
     *
     * @param id - required id to pass to projectUpdate
     * @param input - required input to pass to projectUpdate
     * @returns ProjectPayload
     */
    projectUpdate(id: string, input: L.ProjectUpdateInput): LinearFetch<ProjectPayload>;
    /**
     * Creates a push subscription.
     *
     * @param input - required input to pass to pushSubscriptionCreate
     * @returns PushSubscriptionPayload
     */
    pushSubscriptionCreate(input: L.PushSubscriptionCreateInput): LinearFetch<PushSubscriptionPayload>;
    /**
     * Deletes a push subscription.
     *
     * @param id - required id to pass to pushSubscriptionDelete
     * @returns PushSubscriptionPayload
     */
    pushSubscriptionDelete(id: string): LinearFetch<PushSubscriptionPayload>;
    /**
     * Creates a new reaction.
     *
     * @param input - required input to pass to reactionCreate
     * @returns ReactionPayload
     */
    reactionCreate(input: L.ReactionCreateInput): LinearFetch<ReactionPayload>;
    /**
     * Deletes a reaction.
     *
     * @param id - required id to pass to reactionDelete
     * @returns ArchivePayload
     */
    reactionDelete(id: string): LinearFetch<ArchivePayload>;
    /**
     * Manually update Google Sheets data.
     *
     * @param id - required id to pass to refreshGoogleSheetsData
     * @returns IntegrationPayload
     */
    refreshGoogleSheetsData(id: string): LinearFetch<IntegrationPayload>;
    /**
     * Re-send an organization invite.
     *
     * @param id - required id to pass to resendOrganizationInvite
     * @returns ArchivePayload
     */
    resendOrganizationInvite(id: string): LinearFetch<ArchivePayload>;
    /**
     * Authenticates a user account via email and authentication token for SAML.
     *
     * @param input - required input to pass to samlTokenUserAccountAuth
     * @returns AuthResolverResponse
     */
    samlTokenUserAccountAuth(input: L.TokenUserAccountAuthInput): LinearFetch<AuthResolverResponse>;
    /**
     * Creates a new team. The user who creates the team will automatically be added as a member to the newly created team.
     *
     * @param input - required input to pass to teamCreate
     * @param variables - variables without 'input' to pass into the TeamCreateMutation
     * @returns TeamPayload
     */
    teamCreate(input: L.TeamCreateInput, variables?: Omit<L.TeamCreateMutationVariables, "input">): LinearFetch<TeamPayload>;
    /**
     * Deletes a team.
     *
     * @param id - required id to pass to teamDelete
     * @returns ArchivePayload
     */
    teamDelete(id: string): LinearFetch<ArchivePayload>;
    /**
     * Deletes a previously used team key.
     *
     * @param id - required id to pass to teamKeyDelete
     * @returns ArchivePayload
     */
    teamKeyDelete(id: string): LinearFetch<ArchivePayload>;
    /**
     * Creates a new team membership.
     *
     * @param input - required input to pass to teamMembershipCreate
     * @returns TeamMembershipPayload
     */
    teamMembershipCreate(input: L.TeamMembershipCreateInput): LinearFetch<TeamMembershipPayload>;
    /**
     * Deletes a team membership.
     *
     * @param id - required id to pass to teamMembershipDelete
     * @returns ArchivePayload
     */
    teamMembershipDelete(id: string): LinearFetch<ArchivePayload>;
    /**
     * Updates a team membership.
     *
     * @param id - required id to pass to teamMembershipUpdate
     * @param input - required input to pass to teamMembershipUpdate
     * @returns TeamMembershipPayload
     */
    teamMembershipUpdate(id: string, input: L.TeamMembershipUpdateInput): LinearFetch<TeamMembershipPayload>;
    /**
     * Updates a team.
     *
     * @param id - required id to pass to teamUpdate
     * @param input - required input to pass to teamUpdate
     * @returns TeamPayload
     */
    teamUpdate(id: string, input: L.TeamUpdateInput): LinearFetch<TeamPayload>;
    /**
     * Creates a new template.
     *
     * @param input - required input to pass to templateCreate
     * @returns TemplatePayload
     */
    templateCreate(input: L.TemplateCreateInput): LinearFetch<TemplatePayload>;
    /**
     * Deletes a template.
     *
     * @param id - required id to pass to templateDelete
     * @returns ArchivePayload
     */
    templateDelete(id: string): LinearFetch<ArchivePayload>;
    /**
     * Updates an existing template.
     *
     * @param id - required id to pass to templateUpdate
     * @param input - required input to pass to templateUpdate
     * @returns TemplatePayload
     */
    templateUpdate(id: string, input: L.TemplateUpdateInput): LinearFetch<TemplatePayload>;
    /**
     * Makes user a regular user. Can only be called by an admin.
     *
     * @param id - required id to pass to userDemoteAdmin
     * @returns UserAdminPayload
     */
    userDemoteAdmin(id: string): LinearFetch<UserAdminPayload>;
    /**
     * Updates a user's settings flag.
     *
     * @param flag - required flag to pass to userFlagUpdate
     * @param operation - required operation to pass to userFlagUpdate
     * @returns UserSettingsFlagPayload
     */
    userFlagUpdate(flag: L.UserFlagType, operation: L.UserFlagUpdateOperation): LinearFetch<UserSettingsFlagPayload>;
    /**
     * Makes user an admin. Can only be called by an admin.
     *
     * @param id - required id to pass to userPromoteAdmin
     * @returns UserAdminPayload
     */
    userPromoteAdmin(id: string): LinearFetch<UserAdminPayload>;
    /**
     * [Deprecated] Updates a user's settings flag.
     *
     * @param flag - required flag to pass to userSettingsFlagIncrement
     * @returns UserSettingsFlagPayload
     */
    userSettingsFlagIncrement(flag: string): LinearFetch<UserSettingsFlagPayload>;
    /**
     * Resets user's setting flags.
     *
     * @returns UserSettingsFlagsResetPayload
     */
    get userSettingsFlagsReset(): LinearFetch<UserSettingsFlagsResetPayload>;
    /**
     * Updates the user's settings.
     *
     * @param id - required id to pass to userSettingsUpdate
     * @param input - required input to pass to userSettingsUpdate
     * @returns UserSettingsPayload
     */
    userSettingsUpdate(id: string, input: L.UserSettingsUpdateInput): LinearFetch<UserSettingsPayload>;
    /**
     * Subscribes user to changelog newsletter.
     *
     * @returns UserSubscribeToNewsletterPayload
     */
    get userSubscribeToNewsletter(): LinearFetch<UserSubscribeToNewsletterPayload>;
    /**
     * Suspends a user. Can only be called by an admin.
     *
     * @param id - required id to pass to userSuspend
     * @returns UserAdminPayload
     */
    userSuspend(id: string): LinearFetch<UserAdminPayload>;
    /**
     * Un-suspends a user. Can only be called by an admin.
     *
     * @param id - required id to pass to userUnsuspend
     * @returns UserAdminPayload
     */
    userUnsuspend(id: string): LinearFetch<UserAdminPayload>;
    /**
     * Updates a user. Only available to organization admins and the user themselves.
     *
     * @param id - required id to pass to userUpdate
     * @param input - required input to pass to userUpdate
     * @returns UserPayload
     */
    userUpdate(id: string, input: L.UpdateUserInput): LinearFetch<UserPayload>;
    /**
     * Creates a new ViewPreferences object.
     *
     * @param input - required input to pass to viewPreferencesCreate
     * @returns ViewPreferencesPayload
     */
    viewPreferencesCreate(input: L.ViewPreferencesCreateInput): LinearFetch<ViewPreferencesPayload>;
    /**
     * Deletes a ViewPreferences.
     *
     * @param id - required id to pass to viewPreferencesDelete
     * @returns ArchivePayload
     */
    viewPreferencesDelete(id: string): LinearFetch<ArchivePayload>;
    /**
     * Updates an existing ViewPreferences object.
     *
     * @param id - required id to pass to viewPreferencesUpdate
     * @param input - required input to pass to viewPreferencesUpdate
     * @returns ViewPreferencesPayload
     */
    viewPreferencesUpdate(id: string, input: L.ViewPreferencesUpdateInput): LinearFetch<ViewPreferencesPayload>;
    /**
     * Creates a new webhook.
     *
     * @param input - required input to pass to webhookCreate
     * @returns WebhookPayload
     */
    webhookCreate(input: L.WebhookCreateInput): LinearFetch<WebhookPayload>;
    /**
     * Deletes a Webhook.
     *
     * @param id - required id to pass to webhookDelete
     * @returns ArchivePayload
     */
    webhookDelete(id: string): LinearFetch<ArchivePayload>;
    /**
     * Updates an existing Webhook.
     *
     * @param id - required id to pass to webhookUpdate
     * @param input - required input to pass to webhookUpdate
     * @returns WebhookPayload
     */
    webhookUpdate(id: string, input: L.WebhookUpdateInput): LinearFetch<WebhookPayload>;
    /**
     * Archives a state. Only states with issues that have all been archived can be archived.
     *
     * @param id - required id to pass to workflowStateArchive
     * @returns ArchivePayload
     */
    workflowStateArchive(id: string): LinearFetch<ArchivePayload>;
    /**
     * Creates a new state, adding it to the workflow of a team.
     *
     * @param input - required input to pass to workflowStateCreate
     * @returns WorkflowStatePayload
     */
    workflowStateCreate(input: L.WorkflowStateCreateInput): LinearFetch<WorkflowStatePayload>;
    /**
     * Updates a state.
     *
     * @param id - required id to pass to workflowStateUpdate
     * @param input - required input to pass to workflowStateUpdate
     * @returns WorkflowStatePayload
     */
    workflowStateUpdate(id: string, input: L.WorkflowStateUpdateInput): LinearFetch<WorkflowStatePayload>;
}
//# sourceMappingURL=_generated_sdk.d.ts.map